Generating folder structure...
-------------------------------------------
.
├── apidoc_summary.md
├── bash.sh
├── build.gradle.kts
├── createdomainlayers.sh
├── createproject1.sh
├── docker-compose.yml
├── generatecontent.py
├── generate_project_listing.sh
├── .gitattributes
├── .gitignore
├── .gradle
│   ├── 8.10.2
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── expanded
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── 8.2
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   ├── dependencies-accessors.lock
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── buildOutputCleanup
│   │   ├── buildOutputCleanup.lock
│   │   ├── cache.properties
│   │   └── outputFiles.bin
│   ├── file-system.probe
│   ├── kotlin
│   │   ├── errors
│   │   └── sessions
│   └── vcs-1
│       └── gc.properties
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── HELP.md
├── LICENSE
├── package-lock.json
├── project_documentation.txt
├── project_listing_cleaned.txt
├── project_listing_minimized.txt
├── project_summary.md
├── README.md
├── restore_tests.sh
├── settings.gradle.kts
├── src
│   ├── main
│   │   ├── kotlin
│   │   │   └── org
│   │   │       └── blackerp
│   │   │           ├── api
│   │   │           │   ├── controllers
│   │   │           │   │   └── TableController.kt
│   │   │           │   ├── dto
│   │   │           │   │   ├── request
│   │   │           │   │   │   └── CreateTableRequest.kt
│   │   │           │   │   └── response
│   │   │           │   │       └── TableResponses.kt
│   │   │           │   ├── error
│   │   │           │   │   └── ErrorHandler.kt
│   │   │           │   ├── mappers
│   │   │           │   │   └── TableMapper.kt
│   │   │           │   └── validation
│   │   │           ├── application
│   │   │           │   └── table
│   │   │           │       ├── CreateTableCommand.kt
│   │   │           │       └── CreateTableUseCase.kt
│   │   │           ├── BlackErpApplication.kt
│   │   │           ├── config
│   │   │           │   ├── EventConfig.kt
│   │   │           │   └── WebConfig.kt
│   │   │           ├── domain
│   │   │           │   ├── ad
│   │   │           │   │   ├── ADModule.kt
│   │   │           │   │   ├── ADObject.kt
│   │   │           │   │   ├── reference
│   │   │           │   │   │   ├── ADReference.kt
│   │   │           │   │   │   └── value
│   │   │           │   │   │       └── ReferenceName.kt
│   │   │           │   │   ├── tab
│   │   │           │   │   │   ├── ADTab.kt
│   │   │           │   │   │   ├── CreateTabParams.kt
│   │   │           │   │   │   ├── OrderBySpec.kt
│   │   │           │   │   │   ├── TabError.kt
│   │   │           │   │   │   ├── TabOperations.kt
│   │   │           │   │   │   └── value
│   │   │           │   │   │       └── TabName.kt
│   │   │           │   │   ├── value
│   │   │           │   │   │   └── ModuleName.kt
│   │   │           │   │   └── window
│   │   │           │   │       └── value
│   │   │           │   │           └── WindowName.kt
│   │   │           │   ├── common
│   │   │           │   ├── DomainEntity.kt
│   │   │           │   ├── DomainEvent.kt
│   │   │           │   ├── DomainException.kt
│   │   │           │   ├── EntityMetadata.kt
│   │   │           │   ├── error
│   │   │           │   │   └── DomainError.kt
│   │   │           │   ├── event
│   │   │           │   │   ├── DomainEvent.kt
│   │   │           │   │   ├── EventMetadata.kt
│   │   │           │   │   └── TableCreated.kt
│   │   │           │   ├── query
│   │   │           │   │   ├── QueryCriteria.kt
│   │   │           │   │   └── QueryResult.kt
│   │   │           │   ├── security
│   │   │           │   │   └── SecurityContext.kt
│   │   │           │   ├── table
│   │   │           │   │   ├── ADTable.kt
│   │   │           │   │   ├── behavior
│   │   │           │   │   │   └── TableBehavior.kt
│   │   │           │   │   ├── ColumnDefinition.kt
│   │   │           │   │   ├── constraint
│   │   │           │   │   │   ├── NotNullConstraint.kt
│   │   │           │   │   │   ├── ReferenceConstraint.kt
│   │   │           │   │   │   ├── TableConstraint.kt
│   │   │           │   │   │   └── UniqueConstraint.kt
│   │   │           │   │   ├── CreateColumnParams.kt
│   │   │           │   │   ├── definition
│   │   │           │   │   │   └── TableDefinition.kt
│   │   │           │   │   ├── extension
│   │   │           │   │   │   ├── TableExtension.kt
│   │   │           │   │   │   └── TableExtensionPoint.kt
│   │   │           │   │   ├── relationship
│   │   │           │   │   │   ├── constraint
│   │   │           │   │   │   │   └── IndexConstraint.kt
│   │   │           │   │   │   ├── CreateRelationshipParams.kt
│   │   │           │   │   │   ├── event
│   │   │           │   │   │   │   └── RelationshipEvent.kt
│   │   │           │   │   │   ├── RelationshipConstraint.kt
│   │   │           │   │   │   ├── RelationshipOperations.kt
│   │   │           │   │   │   ├── TableRelationshipError.kt
│   │   │           │   │   │   ├── TableRelationship.kt
│   │   │           │   │   │   └── value
│   │   │           │   │   │       ├── DeleteRule.kt
│   │   │           │   │   │       ├── RelationshipName.kt
│   │   │           │   │   │       ├── RelationType.kt
│   │   │           │   │   │       └── UpdateRule.kt
│   │   │           │   │   ├── TableCreated.kt
│   │   │           │   │   ├── TableError.kt
│   │   │           │   │   ├── TableId.kt
│   │   │           │   │   ├── TableOperations.kt
│   │   │           │   │   └── TenantAwareTable.kt
│   │   │           │   ├── tenant
│   │   │           │   │   ├── TenantAware.kt
│   │   │           │   │   ├── TenantContext.kt
│   │   │           │   │   └── TenantFilter.kt
│   │   │           │   ├── transaction
│   │   │           │   │   ├── TransactionError.kt
│   │   │           │   │   └── Transaction.kt
│   │   │           │   └── values
│   │   │           │       ├── AccessLevel.kt
│   │   │           │       ├── Amount.kt
│   │   │           │       ├── ColumnName.kt
│   │   │           │       ├── Currency.kt
│   │   │           │       ├── DataType.kt
│   │   │           │       ├── Description.kt
│   │   │           │       ├── DisplayName.kt
│   │   │           │       ├── EventMetadata.kt
│   │   │           │       ├── Length.kt
│   │   │           │       ├── Precision.kt
│   │   │           │       ├── Scale.kt
│   │   │           │       └── TableName.kt
│   │   │           ├── infrastructure
│   │   │           │   ├── cache
│   │   │           │   │   ├── CacheService.kt
│   │   │           │   │   └── InMemoryCacheService.kt
│   │   │           │   ├── event
│   │   │           │   │   ├── DefaultEventPublisher.kt
│   │   │           │   │   └── EventPublisher.kt
│   │   │           │   ├── persistence
│   │   │           │   │   └── store
│   │   │           │   │       ├── PostgresRelationshipOperations.kt
│   │   │           │   │       ├── PostgresTableOperations.kt
│   │   │           │   │       └── PostgresTabOperations.kt
│   │   │           │   └── store
│   │   │           ├── plugin
│   │   │           │   ├── discovery
│   │   │           │   │   ├── FileSystemPluginDiscovery.kt
│   │   │           │   │   └── PluginDiscovery.kt
│   │   │           │   ├── Extension.kt
│   │   │           │   ├── ExtensionRegistry.kt
│   │   │           │   ├── PluginError.kt
│   │   │           │   ├── PluginId.kt
│   │   │           │   ├── Plugin.kt
│   │   │           │   ├── PluginMetadata.kt
│   │   │           │   ├── registry
│   │   │           │   │   ├── DefaultPluginRegistry.kt
│   │   │           │   │   └── PluginRegistry.kt
│   │   │           │   └── Version.kt
│   │   │           └── shared
│   │   │               ├── ReferenceValidation.kt
│   │   │               ├── TimeBasedId.kt
│   │   │               └── ValidationError.kt
│   │   └── resources
│   │       ├── application.yml
│   │       └── db
│   │           └── migration
│   │               ├── V1__Create_table_schema.sql
│   │               ├── V2_create_relationship_schema.sql
│   │               └── V3__Create_tab_schema.sql
│   └── test
│       ├── kotlin
│       │   └── org
│       │       └── blackerp
│       │           ├── api
│       │           │   └── controllers
│       │           │       └── TableControllerTest.kt
│       │           ├── application
│       │           │   └── table
│       │           │       └── CreateTableUseCaseTest.kt
│       │           ├── config
│       │           │   ├── KotestProjectConfig.kt
│       │           │   ├── TestConfig.kt
│       │           │   ├── TestEventConfig.kt
│       │           │   └── UnifiedTestConfig.kt
│       │           ├── domain
│       │           │   ├── ad
│       │           │   │   ├── ADModuleTest.kt
│       │           │   │   ├── reference
│       │           │   │   │   ├── ADReferenceTest.kt
│       │           │   │   │   └── value
│       │           │   │   │       └── ReferenceNameTest.kt
│       │           │   │   ├── tab
│       │           │   │   │   ├── ADTabTest.kt
│       │           │   │   │   └── value
│       │           │   │   │       └── TabNameTest.kt
│       │           │   │   ├── value
│       │           │   │   │   └── ModuleNameTest.kt
│       │           │   │   └── window
│       │           │   │       └── value
│       │           │   │           └── WindowNameTest.kt
│       │           │   ├── EntityMetadataTest.kt
│       │           │   ├── error
│       │           │   │   └── DomainErrorTest.kt
│       │           │   ├── query
│       │           │   │   └── QueryCriteriaTest.kt
│       │           │   ├── table
│       │           │   │   ├── behavior
│       │           │   │   ├── constraint
│       │           │   │   │   ├── NotNullConstraintTest.kt
│       │           │   │   │   ├── ReferenceConstraintTest.kt
│       │           │   │   │   └── UniqueConstraintTest.kt
│       │           │   │   ├── definition
│       │           │   │   │   └── TableDefinitionTest.kt
│       │           │   │   ├── extension
│       │           │   │   │   └── TableExtensionPointTest.kt
│       │           │   │   ├── relationship
│       │           │   │   │   ├── RelationshipOperationsTest.kt
│       │           │   │   │   ├── RelationshipTestFactory.kt
│       │           │   │   │   └── TableRelationshipTest.kt
│       │           │   │   └── TableOperationsTest.kt
│       │           │   ├── tenant
│       │           │   │   ├── TenantAwareTableTest.kt
│       │           │   │   └── TenantContextTest.kt
│       │           │   ├── transaction
│       │           │   │   └── TransactionTest.kt
│       │           │   └── values
│       │           │       ├── AmountTest.kt
│       │           │       ├── CurrencyTest.kt
│       │           │       ├── DataTypeTest.kt
│       │           │       ├── DisplayNameTest.kt
│       │           │       └── TableNameTest.kt
│       │           ├── infrastructure
│       │           │   ├── cache
│       │           │   │   └── InMemoryCacheServiceTest.kt
│       │           │   └── persistence
│       │           │       ├── SimpleTest.kt
│       │           │       ├── store
│       │           │       │   ├── InMemoryRelationshipOperations.kt
│       │           │       │   ├── InMemoryTableOperations.kt
│       │           │       │   ├── InMemoryTabOperations.kt
│       │           │       │   └── PostgresTabOperationsTest.kt
│       │           │       └── TestDatabaseConfig.kt
│       │           ├── integration
│       │           │   ├── api
│       │           │   │   └── TableApiIntegrationTest.kt
│       │           │   ├── db
│       │           │   │   └── TableRepositoryIntegrationTest.kt
│       │           │   ├── IntegrationTestConfig.kt
│       │           │   └── plugin
│       │           │       └── PluginLifecycleIntegrationTest.kt
│       │           ├── plugin
│       │           │   ├── discovery
│       │           │   │   └── FileSystemPluginDiscoveryTest.kt
│       │           │   ├── InMemoryExtensionRegistry.kt
│       │           │   ├── integration
│       │           │   ├── PluginIdTest.kt
│       │           │   ├── PluginMetadataTest.kt
│       │           │   ├── PluginTest.kt
│       │           │   ├── registry
│       │           │   │   └── DefaultPluginRegistryTest.kt
│       │           │   ├── TestPlugin.kt
│       │           │   └── VersionTest.kt
│       │           └── shared
│       │               ├── TestFactory.kt
│       │               └── TimeBasedIdTest.kt
│       └── resources
│           ├── application-test.properties
│           ├── application-test.yml
│           ├── application.yml
│           ├── application.yml.backup.20241127_051405
│           ├── db
│           │   ├── h2-schema.sql
│           │   ├── migration
│           │   │   └── V4__create_test_tables.sql
│           │   └── schema.sql
│           └── logback-test.xml
├── testdebug.txt
├── verify-setup.sh
└── verify_test.sh

124 directories, 219 files

Generating file details...
-------------------------------------------
File: ./settings.gradle.kts
-------------------------------------------
rootProject.name = "blackerp"

File: ./docker-compose.yml
-------------------------------------------
version: '3.8'
services:
db:
image: postgres:14-alpine
environment:
POSTGRES_DB: blackerp
POSTGRES_USER: postgres
POSTGRES_PASSWORD: postgres
ports:
- "5432:5432"
volumes:
- postgres_data:/var/lib/postgresql/data
volumes:
postgres_data:

File: ./build.gradle.kts
-------------------------------------------
plugins {
kotlin("jvm") version "1.9.20"
kotlin("plugin.spring") version "1.9.20"
id("org.springframework.boot") version "3.2.0"
id("io.spring.dependency-management") version "1.1.4"
id("org.flywaydb.flyway") version "9.21.0"
id("jacoco")
}
group = "org.blackerp"
version = "0.0.1-SNAPSHOT"
java {
sourceCompatibility = JavaVersion.VERSION_17
}
repositories {
mavenCentral()
}
dependencies {
implementation("com.h2database:h2:2.1.214")
implementation("org.flywaydb:flyway-core")
implementation("com.fasterxml.uuid:java-uuid-generator:4.2.0")
// Kotlin
implementation("org.jetbrains.kotlin:kotlin-reflect")
implementation("org.jetbrains.kotlin:kotlin-stdlib")
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core")
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
// Spring
implementation("org.springframework.boot:spring-boot-starter")
implementation("org.springframework.boot:spring-boot-starter-web")
implementation("org.springframework.boot:spring-boot-starter-validation")
implementation("org.springframework.boot:spring-boot-starter-jdbc")
implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
// Arrow
implementation("io.arrow-kt:arrow-core:1.2.0")
implementation("io.arrow-kt:arrow-fx-coroutines:1.2.0")
// Testing
testImplementation("org.springframework.boot:spring-boot-starter-test")
testImplementation("org.springframework.boot:spring-boot-starter-test") {
exclude(module = "mockito-core")
}
testImplementation("com.ninja-squad:springmockk:4.0.2")
testImplementation("io.mockk:mockk:1.13.8")
testImplementation("com.h2database:h2:2.1.214")
// Kotest
testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
testImplementation("io.kotest:kotest-assertions-core:5.8.0")
testImplementation("io.kotest:kotest-property:5.8.0")
testImplementation("io.kotest:kotest-framework-datatest:5.8.0")
testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")
testImplementation("io.kotest.extensions:kotest-assertions-arrow:1.3.3")
testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
}
tasks.withType<Test> {
useJUnitPlatform()
}
tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
kotlinOptions {
freeCompilerArgs = listOf("-Xjsr305=strict")
jvmTarget = "17"
}
}
jacoco {
toolVersion = "0.8.9"
}
tasks.jacocoTestReport {
dependsOn(tasks.test)
reports {
xml.required.set(true)
html.required.set(true)
html.outputLocation.set(layout.buildDirectory.dir("reports/jacoco"))
}
classDirectories.setFrom(
files(classDirectories.files.map {
fileTree(it) {
exclude(
// Exclude classes that don't need test coverage
"**/BlackErpApplication*",
"**/config/**",
"**/dto/**",
"**/*Error*",
"**/infrastructure/persistence/store/PostgresTabOperations.kt"
)
}
})
)
}
tasks.test {
finalizedBy(tasks.jacocoTestReport)
}
flyway {
url = "jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL"
user = "sa"
password = ""
baselineOnMigrate = true
locations = arrayOf("classpath:db/migration")
}
// Add these dependencies if they're not already present
dependencies {
implementation("org.springframework.boot:spring-boot-starter-web")
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")
implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
}
dependencies {
implementation("org.springframework.boot:spring-boot-starter-validation")
}

File: ./src/main/resources/application.yml
-------------------------------------------
spring:
application:
name: blackerp
logging:
level:
org.blackerp: DEBUG
org.springframework.web: INFO

File: ./src/main/resources/db/migration/V3__Create_tab_schema.sql
-------------------------------------------
-- src/main/resources/db/migration/V3__Create_tab_schema.sql
CREATE TABLE ad_tab (
id UUID PRIMARY KEY,
name VARCHAR(100) NOT NULL,
display_name VARCHAR(100) NOT NULL,
description TEXT,
table_name VARCHAR(100) NOT NULL,
created TIMESTAMP NOT NULL,
created_by VARCHAR(100) NOT NULL,
updated TIMESTAMP NOT NULL,
updated_by VARCHAR(100) NOT NULL,
version INTEGER NOT NULL DEFAULT 0,
active BOOLEAN NOT NULL DEFAULT true,
CONSTRAINT uk_tab_name UNIQUE (name),
CONSTRAINT fk_tab_table FOREIGN KEY (table_name)
REFERENCES ad_table(name)
);
CREATE INDEX idx_tab_name ON ad_tab(name);
CREATE INDEX idx_tab_table ON ad_tab(table_name);
CREATE TABLE ad_tab_query_column (
tab_id UUID NOT NULL,
column_name VARCHAR(100) NOT NULL,
sequence INTEGER NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_query_tab FOREIGN KEY (tab_id)
REFERENCES ad_tab(id) ON DELETE CASCADE
);
CREATE TABLE ad_tab_display_column (
tab_id UUID NOT NULL,
column_name VARCHAR(100) NOT NULL,
sequence INTEGER NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_display_tab FOREIGN KEY (tab_id)
REFERENCES ad_tab(id) ON DELETE CASCADE
);
CREATE TABLE ad_tab_order_by (
tab_id UUID NOT NULL,
column_name VARCHAR(100) NOT NULL,
direction VARCHAR(4) NOT NULL,
sequence INTEGER NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_order_tab FOREIGN KEY (tab_id)
REFERENCES ad_tab(id) ON DELETE CASCADE,
CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);

File: ./src/main/resources/db/migration/V2_create_relationship_schema.sql
-------------------------------------------
-- File: src/main/resources/db/migration/V2__Create_relationship_schema.sql
CREATE TABLE ad_table_relationship (
id UUID PRIMARY KEY,
name VARCHAR(100) NOT NULL,
source_table VARCHAR(100) NOT NULL,
target_table VARCHAR(100) NOT NULL,
type VARCHAR(20) NOT NULL,
source_column VARCHAR(100) NOT NULL,
target_column VARCHAR(100) NOT NULL,
delete_rule VARCHAR(20) NOT NULL,
update_rule VARCHAR(20) NOT NULL,
junction_table VARCHAR(100),
created TIMESTAMP NOT NULL,
created_by VARCHAR(100) NOT NULL,
updated TIMESTAMP NOT NULL,
updated_by VARCHAR(100) NOT NULL,
version INTEGER NOT NULL DEFAULT 0,
active BOOLEAN NOT NULL DEFAULT true,
CONSTRAINT uk_relationship_name UNIQUE (name),
CONSTRAINT fk_source_table FOREIGN KEY (source_table) REFERENCES ad_table(name),
CONSTRAINT fk_target_table FOREIGN KEY (target_table) REFERENCES ad_table(name),
CONSTRAINT fk_junction_table FOREIGN KEY (junction_table) REFERENCES ad_table(name),
CONSTRAINT chk_relationship_type CHECK (type IN ('ONE_TO_ONE', 'ONE_TO_MANY', 'MANY_TO_MANY')),
CONSTRAINT chk_delete_rule CHECK (delete_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION')),
CONSTRAINT chk_update_rule CHECK (update_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION'))
);
CREATE INDEX idx_relationship_source ON ad_table_relationship(source_table);
CREATE INDEX idx_relationship_target ON ad_table_relationship(target_table);
CREATE INDEX idx_relationship_active ON ad_table_relationship(active);
COMMENT ON TABLE ad_table_relationship IS 'Table Relationship Definitions';

File: ./src/main/resources/db/migration/V1__Create_table_schema.sql
-------------------------------------------
CREATE TABLE ad_table (
id UUID PRIMARY KEY,
name VARCHAR(100) UNIQUE NOT NULL,
display_name VARCHAR(100) NOT NULL,
description TEXT,
access_level VARCHAR(50) NOT NULL,
created TIMESTAMP NOT NULL,
created_by VARCHAR(100) NOT NULL,
updated TIMESTAMP NOT NULL,
updated_by VARCHAR(100) NOT NULL,
version INTEGER NOT NULL DEFAULT 0,
active BOOLEAN NOT NULL DEFAULT true,
CONSTRAINT name_format CHECK (name ~ '^[a-z][a-z0-9_]*$')
);
CREATE INDEX idx_ad_table_name ON ad_table(name);
CREATE INDEX idx_ad_table_active ON ad_table(active);
COMMENT ON TABLE ad_table IS 'Application Dictionary Table Definitions';
COMMENT ON COLUMN ad_table.id IS 'Time-based UUID primary key';
COMMENT ON COLUMN ad_table.name IS 'Technical name (lowercase with underscores)';
COMMENT ON COLUMN ad_table.display_name IS 'Human readable name';
COMMENT ON COLUMN ad_table.description IS 'Optional description';
COMMENT ON COLUMN ad_table.access_level IS 'Access level (SYSTEM, CLIENT, ORGANIZATION, etc)';
COMMENT ON COLUMN ad_table.version IS 'Optimistic locking version';

File: ./src/main/kotlin/org/blackerp/infrastructure/event/DefaultEventPublisher.kt
-------------------------------------------
package org.blackerp.infrastructure.event
import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.event.DomainEvent
import org.blackerp.domain.table.TableError
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component
@Component
class DefaultEventPublisher : EventPublisher {
private val logger = LoggerFactory.getLogger(DefaultEventPublisher::class.java)
override suspend fun publish(event: DomainEvent): Either<TableError, Unit> {
logger.info("Publishing event: ${event::class.simpleName} with ID: ${event.metadata.id}")
// In a real implementation, you might:
// 1. Persist the event
// 2. Send to message broker
// 3. Notify subscribers
return Unit.right()
}
}

File: ./src/main/kotlin/org/blackerp/infrastructure/event/EventPublisher.kt
-------------------------------------------
package org.blackerp.infrastructure.event
import arrow.core.Either
import org.blackerp.domain.event.DomainEvent
import org.blackerp.domain.table.TableError
interface EventPublisher {
suspend fun publish(event: DomainEvent): Either<TableError, Unit>
}

File: ./src/main/kotlin/org/blackerp/infrastructure/cache/CacheService.kt
-------------------------------------------
package org.blackerp.infrastructure.cache
import arrow.core.Either
import org.blackerp.domain.error.DomainError
import java.time.Duration
interface CacheService {
suspend fun <T> get(key: String): Either<DomainError, T?>
suspend fun <T> set(key: String, value: T, ttl: Duration? = null): Either<DomainError, Unit>
suspend fun delete(key: String): Either<DomainError, Unit>
suspend fun clear(): Either<DomainError, Unit>
}

File: ./src/main/kotlin/org/blackerp/infrastructure/cache/InMemoryCacheService.kt
-------------------------------------------
package org.blackerp.infrastructure.cache
import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.error.DomainError
import java.time.Duration
import java.time.Instant
import java.util.concurrent.ConcurrentHashMap
class InMemoryCacheService : CacheService {
private data class CacheEntry<T>(
val value: T,
val expiry: Instant?
)
private val cache = ConcurrentHashMap<String, CacheEntry<Any>>()
@Suppress("UNCHECKED_CAST")
override suspend fun <T> get(key: String): Either<DomainError, T?> =
cache[key]?.let { entry ->
if (entry.expiry == null || entry.expiry > Instant.now()) {
(entry.value as T).right()
} else {
cache.remove(key)
null.right()
}
} ?: null.right()
override suspend fun <T> set(key: String, value: T, ttl: Duration?): Either<DomainError, Unit> {
val expiry = ttl?.let { Instant.now().plus(it) }
cache[key] = CacheEntry(value as Any, expiry)
return Unit.right()
}
override suspend fun delete(key: String): Either<DomainError, Unit> {
cache.remove(key)
return Unit.right()
}
override suspend fun clear(): Either<DomainError, Unit> {
cache.clear()
return Unit.right()
}
}

File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTableOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.TableOperations
import org.blackerp.domain.values.*
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.dao.EmptyResultDataAccessException
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.RowMapper
import org.springframework.stereotype.Repository
import java.sql.ResultSet
import java.time.Instant
import java.util.UUID
@Repository
class PostgresTableOperations(
private val jdbcTemplate: JdbcTemplate
) : TableOperations {
private val tableMapper = TableRowMapper()
override suspend fun findAll(): Either<TableError, List<ADTable>> = try {
val tables = jdbcTemplate.query(
"""
SELECT id, name, display_name, description, access_level,
created, created_by, updated, updated_by, version, active
FROM ad_table
WHERE active = true
""",
tableMapper
)
tables.right()
} catch (e: Exception) {
TableError.StorageError(e).left()
}
override suspend fun save(table: ADTable): Either<TableError, ADTable> = try {
jdbcTemplate.update("""
INSERT INTO ad_table (
id, name, display_name, description, access_level,
created, created_by, updated, updated_by, version, active
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
""",
table.metadata.id,
table.name.value,
table.displayName.value,
table.description?.value,
table.accessLevel.name,
table.metadata.created,
table.metadata.createdBy,
table.metadata.updated,
table.metadata.updatedBy,
table.metadata.version,
table.metadata.active
)
table.right()
} catch (e: DataIntegrityViolationException) {
when {
e.message?.contains("name_format") == true ->
TableError.StorageError(e).left()
e.message?.contains("unique") == true ->
TableError.DuplicateTable(table.name.value).left()
else -> TableError.StorageError(e).left()
}
} catch (e: Exception) {
TableError.StorageError(e).left()
}
override suspend fun findById(id: UUID): Either<TableError, ADTable?> = try {
val table = jdbcTemplate.queryForObject(
"""
SELECT id, name, display_name, description, access_level,
created, created_by, updated, updated_by, version, active
FROM ad_table WHERE id = ?
""",
tableMapper,
id
)
table?.right() ?: TableError.NotFound(id.toString()).left()
} catch (e: EmptyResultDataAccessException) {
TableError.NotFound(id.toString()).left()
} catch (e: Exception) {
TableError.StorageError(e).left()
}
override suspend fun findByName(name: String): Either<TableError, ADTable?> = try {
val table = jdbcTemplate.queryForObject(
"""
SELECT id, name, display_name, description, access_level,
created, created_by, updated, updated_by, version, active
FROM ad_table WHERE name = ?
""",
tableMapper,
name
)
table?.right() ?: TableError.NotFound(name).left()
} catch (e: EmptyResultDataAccessException) {
TableError.NotFound(name).left()
} catch (e: Exception) {
TableError.StorageError(e).left()
}
override suspend fun delete(id: UUID): Either<TableError, Unit> = try {
val count = jdbcTemplate.update("DELETE FROM ad_table WHERE id = ?", id)
if (count > 0) Unit.right() else TableError.NotFound(id.toString()).left()
} catch (e: Exception) {
TableError.StorageError(e).left()
}
private class TableRowMapper : RowMapper<ADTable> {
override fun mapRow(rs: ResultSet, rowNum: Int): ADTable {
val metadata = EntityMetadata(
id = UUID.fromString(rs.getString("id")),
created = rs.getTimestamp("created").toInstant(),
createdBy = rs.getString("created_by"),
updated = rs.getTimestamp("updated").toInstant(),
updatedBy = rs.getString("updated_by"),
version = rs.getInt("version"),
active = rs.getBoolean("active")
)
// Placeholder for fetching columns, replace with actual logic to retrieve columns from database
val columns = listOf<ColumnDefinition>()
return ADTable(
metadata = metadata,
name = TableName.create(rs.getString("name")).getOrNull()!!,
displayName = DisplayName.create(rs.getString("display_name")).getOrNull()!!,
description = rs.getString("description")?.let {
Description.create(it).getOrNull()
},
accessLevel = AccessLevel.fromString(rs.getString("access_level")),
columns = columns // Pass columns here
)
}
}
}

File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresRelationshipOperations.kt
-------------------------------------------
// File: src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresRelationshipOperations.kt
package org.blackerp.infrastructure.persistence.store
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.TableError
import org.blackerp.domain.values.*
import org.blackerp.domain.table.relationship.*
import org.blackerp.domain.table.relationship.value.*
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.dao.EmptyResultDataAccessException
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.RowMapper
import org.springframework.stereotype.Repository
import java.sql.ResultSet
import java.time.Instant
import java.util.UUID
@Repository
class PostgresRelationshipOperations(
private val jdbcTemplate: JdbcTemplate
) : RelationshipOperations {
private val relationshipMapper = RelationshipRowMapper()
override suspend fun save(relationship: TableRelationship): Either<TableError, TableRelationship> = try {
jdbcTemplate.update("""
INSERT INTO ad_table_relationship (
id, name, source_table, target_table, type,
source_column, target_column, delete_rule, update_rule,
junction_table, created, created_by, updated, updated_by,
version, active
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
""",
relationship.metadata.id,
relationship.name.value,
relationship.sourceTable.value,
relationship.targetTable.value,
relationship.type.name,
relationship.sourceColumn.value,
relationship.targetColumn.value,
relationship.deleteRule.name,
relationship.updateRule.name,
null, // junction_table is null for non-many-to-many relationships
relationship.metadata.created,
relationship.metadata.createdBy,
relationship.metadata.updated,
relationship.metadata.updatedBy,
relationship.metadata.version,
relationship.metadata.active
)
relationship.right()
} catch (e: DataIntegrityViolationException) {
when {
e.message?.contains("uk_relationship_name") == true ->
TableError.DuplicateTable(relationship.name.value).left()
else -> TableError.StorageError(e).left()
}
} catch (e: Exception) {
TableError.StorageError(e).left()
}
override suspend fun findById(id: UUID): Either<TableError, TableRelationship?> = try {
val relationship = jdbcTemplate.queryForObject(
"""
SELECT id, name, source_table, target_table, type,
source_column, target_column, delete_rule, update_rule,
junction_table, created, created_by, updated, updated_by,
version, active
FROM ad_table_relationship WHERE id = ?
""",
relationshipMapper,
id
)
relationship?.right() ?: TableError.NotFound(id.toString()).left()
} catch (e: EmptyResultDataAccessException) {
TableError.NotFound(id.toString()).left()
} catch (e: Exception) {
TableError.StorageError(e).left()
}
override suspend fun findByTable(tableName: TableName): Either<TableError, List<TableRelationship>> = try {
val relationships = jdbcTemplate.query(
"""
SELECT id, name, source_table, target_table, type,
source_column, target_column, delete_rule, update_rule,
junction_table, created, created_by, updated, updated_by,
version, active
FROM ad_table_relationship
WHERE source_table = ? OR target_table = ?
""",
relationshipMapper,
tableName.value,
tableName.value
)
relationships.right()
} catch (e: Exception) {
TableError.StorageError(e).left()
}
override suspend fun delete(id: UUID): Either<TableError, Unit> = try {
val count = jdbcTemplate.update("DELETE FROM ad_table_relationship WHERE id = ?", id)
if (count > 0) Unit.right() else TableError.NotFound(id.toString()).left()
} catch (e: Exception) {
TableError.StorageError(e).left()
}
private class RelationshipRowMapper : RowMapper<TableRelationship> {
override fun mapRow(rs: ResultSet, rowNum: Int): TableRelationship {
val metadata = EntityMetadata(
id = UUID.fromString(rs.getString("id")),
created = rs.getTimestamp("created").toInstant(),
createdBy = rs.getString("created_by"),
updated = rs.getTimestamp("updated").toInstant(),
updatedBy = rs.getString("updated_by"),
version = rs.getInt("version"),
active = rs.getBoolean("active")
)
return TableRelationship(
metadata = metadata,
name = RelationshipName.create(rs.getString("name")).getOrNull()!!,
sourceTable = TableName.create(rs.getString("source_table")).getOrNull()!!,
targetTable = TableName.create(rs.getString("target_table")).getOrNull()!!,
type = RelationType.valueOf(rs.getString("type")),
sourceColumn = ColumnName.create(rs.getString("source_column")).getOrNull()!!,
targetColumn = ColumnName.create(rs.getString("target_column")).getOrNull()!!,
constraints = emptyList(), // Load constraints if needed
deleteRule = DeleteRule.valueOf(rs.getString("delete_rule")),
updateRule = UpdateRule.valueOf(rs.getString("update_rule"))
)
}
}
}

File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTabOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.ad.tab.*
import org.blackerp.domain.ad.tab.value.TabName
import org.blackerp.domain.values.*
import org.blackerp.domain.table.TableOperations
import org.blackerp.shared.ValidationError
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.RowMapper
import org.springframework.stereotype.Repository
import java.sql.ResultSet
import java.time.Instant
import java.util.UUID
import java.io.File
@Repository
class PostgresTabOperations(
private val jdbcTemplate: JdbcTemplate,
private val tableOperations: TableOperations
) : TabOperations {
private fun debug(msg: String) {
File("testdebug.txt").appendText("${Instant.now()}: $msg\n")
}
override suspend fun save(tab: ADTab): Either<TabError, ADTab> =
Either.catch {
debug("Saving tab: ${tab.name.value}")
// First, verify the table exists
val tableExists = jdbcTemplate.queryForObject(
"SELECT COUNT(*) FROM ad_table WHERE name = ?",
Int::class.java,
tab.table.name.value
) ?: 0
debug("Table exists check: $tableExists")
if (tableExists == 0) {
throw IllegalStateException("Referenced table ${tab.table.name.value} does not exist")
}
// Insert/Update tab using MERGE
val mergeResult = jdbcTemplate.update("""
MERGE INTO ad_tab KEY(id) VALUES (
?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
""",
tab.metadata.id,
tab.name.value,
tab.displayName.value,
tab.description?.value,
tab.table.name.value,
tab.metadata.created,
tab.metadata.createdBy,
tab.metadata.updated,
tab.metadata.updatedBy,
tab.metadata.version,
tab.metadata.active
)
debug("Tab merge result: $mergeResult")
// Update query columns
jdbcTemplate.update("DELETE FROM ad_tab_query_column WHERE tab_id = ?", tab.metadata.id)
tab.queryColumns.forEachIndexed { index, column ->
val qcResult = jdbcTemplate.update("""
INSERT INTO ad_tab_query_column (tab_id, column_name, sequence)
VALUES (?, ?, ?)
""",
tab.metadata.id,
column.value,
index
)
debug("Query column insert result: $qcResult")
}
// Update display columns
jdbcTemplate.update("DELETE FROM ad_tab_display_column WHERE tab_id = ?", tab.metadata.id)
tab.displayColumns.forEachIndexed { index, column ->
val dcResult = jdbcTemplate.update("""
INSERT INTO ad_tab_display_column (tab_id, column_name, sequence)
VALUES (?, ?, ?)
""",
tab.metadata.id,
column.value,
index
)
debug("Display column insert result: $dcResult")
}
// Update order by specifications
jdbcTemplate.update("DELETE FROM ad_tab_order_by WHERE tab_id = ?", tab.metadata.id)
tab.orderBy.forEachIndexed { index, spec ->
val obResult = jdbcTemplate.update("""
INSERT INTO ad_tab_order_by (tab_id, column_name, direction, sequence)
VALUES (?, ?, ?, ?)
""",
tab.metadata.id,
spec.column.value,
spec.direction.name,
index
)
debug("Order by insert result: $obResult")
}
tab
}.mapLeft { e ->
debug("Error saving tab: ${e.message}")
e.printStackTrace(File("testdebug.txt").printWriter())
when (e) {
is IllegalStateException -> TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
else -> TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
}
}
override suspend fun findById(id: UUID): Either<TabError, ADTab?> =
Either.catch {
val results = jdbcTemplate.query(
"""
SELECT t.*,
array_agg(DISTINCT qc.column_name) as query_columns,
array_agg(DISTINCT dc.column_name) as display_columns,
array_agg(DISTINCT ob.column_name || ',' || ob.direction) as order_by
FROM ad_tab t
LEFT JOIN ad_tab_query_column qc ON t.id = qc.tab_id
LEFT JOIN ad_tab_display_column dc ON t.id = dc.tab_id
LEFT JOIN ad_tab_order_by ob ON t.id = ob.tab_id
WHERE t.id = ?
GROUP BY t.id, t.name, t.display_name, t.description, t.table_name,
t.created, t.created_by, t.updated, t.updated_by, t.version, t.active
""",
TabRowMapper(tableOperations),
id
)
results.firstOrNull()
}.mapLeft { e ->
TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
}
override suspend fun findByTable(tableName: TableName): Either<TabError, List<ADTab>> =
Either.catch {
jdbcTemplate.query(
"""
SELECT t.*,
array_agg(DISTINCT qc.column_name) as query_columns,
array_agg(DISTINCT dc.column_name) as display_columns,
array_agg(DISTINCT ob.column_name || ',' || ob.direction) as order_by
FROM ad_tab t
LEFT JOIN ad_tab_query_column qc ON t.id = qc.tab_id
LEFT JOIN ad_tab_display_column dc ON t.id = dc.tab_id
LEFT JOIN ad_tab_order_by ob ON t.id = ob.tab_id
WHERE t.table_name = ?
GROUP BY t.id, t.name, t.display_name, t.description, t.table_name,
t.created, t.created_by, t.updated, t.updated_by, t.version, t.active
""",
TabRowMapper(tableOperations),
tableName.value
)
}.mapLeft { e ->
TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
}
override suspend fun delete(id: UUID): Either<TabError, Unit> =
Either.catch {
val count = jdbcTemplate.update("DELETE FROM ad_tab WHERE id = ?", id)
if (count == 0) throw IllegalStateException("Tab not found: $id")
Unit
}.mapLeft { e ->
TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
}
private class TabRowMapper(
private val tableOperations: TableOperations
) : RowMapper<ADTab> {
override fun mapRow(rs: ResultSet, rowNum: Int): ADTab {
val metadata = EntityMetadata(
id = UUID.fromString(rs.getString("id")),
created = rs.getTimestamp("created").toInstant(),
createdBy = rs.getString("created_by"),
updated = rs.getTimestamp("updated").toInstant(),
updatedBy = rs.getString("updated_by"),
version = rs.getInt("version"),
active = rs.getBoolean("active")
)
val tableName = rs.getString("table_name")
val table = kotlinx.coroutines.runBlocking {
tableOperations.findByName(tableName).getOrNull()
?: throw IllegalStateException("Table not found: $tableName")
}
// Safe array handling
val queryColumns = (rs.getArray("query_columns")?.array as? Array<*>)
?.filterNotNull()
?.map { it.toString() }
?.map { ColumnName.create(it).getOrNull()!! }
?: emptyList()
val displayColumns = (rs.getArray("display_columns")?.array as? Array<*>)
?.filterNotNull()
?.map { it.toString() }
?.map { ColumnName.create(it).getOrNull()!! }
?: emptyList()
val orderBy = (rs.getArray("order_by")?.array as? Array<*>)
?.filterNotNull()
?.map { it.toString() }
?.map { spec ->
val (col, dir) = spec.split(",")
OrderBySpec(
column = ColumnName.create(col).getOrNull()!!,
direction = SortDirection.valueOf(dir)
)
}
?: emptyList()
return ADTab(
metadata = metadata,
name = TabName.create(rs.getString("name")).getOrNull()!!,
displayName = DisplayName.create(rs.getString("display_name")).getOrNull()!!,
description = rs.getString("description")?.let {
Description.create(it).getOrNull()
},
table = table,
queryColumns = queryColumns,
displayColumns = displayColumns,
orderBy = orderBy
)
}
}
}

File: ./src/main/kotlin/org/blackerp/BlackErpApplication.kt
-------------------------------------------
package org.blackerp
import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
@SpringBootApplication(
scanBasePackages = ["org.blackerp"]
)
class BlackErpApplication
fun main(args: Array<String>) {
runApplication<BlackErpApplication>(*args)
}

File: ./src/main/kotlin/org/blackerp/plugin/PluginError.kt
-------------------------------------------
package org.blackerp.plugin
import org.blackerp.shared.ValidationError
sealed interface PluginError {
data class NotFound(val id: String) : PluginError
data class ValidationFailed(val errors: List<ValidationError>) : PluginError
data class DuplicatePlugin(val id: String) : PluginError
data class IncompatibleVersion(val required: Version, val actual: Version) : PluginError
data class InitializationFailed(val id: String, val cause: Throwable) : PluginError
data class DiscoveryFailed(val message: String, val cause: Throwable? = null) : PluginError
data class LoadFailed(val message: String) : PluginError
}

File: ./src/main/kotlin/org/blackerp/plugin/Plugin.kt
-------------------------------------------
package org.blackerp.plugin
import arrow.core.Either
interface Plugin {
val metadata: PluginMetadata
/**
* Initialize the plugin with provided context
* @return Either an initialization error or Unit on success
*/
suspend fun initialize(): Either<PluginError, Unit>
/**
* Register plugin extensions with the registry
* @param registry Extension point registry
* @return Either a registration error or Unit on success
*/
suspend fun registerExtensions(registry: ExtensionRegistry): Either<PluginError, Unit>
/**
* Clean up plugin resources
* @return Either a cleanup error or Unit on success
*/
suspend fun shutdown(): Either<PluginError, Unit>
}

File: ./src/main/kotlin/org/blackerp/plugin/discovery/FileSystemPluginDiscovery.kt
-------------------------------------------
package org.blackerp.plugin.discovery
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.plugin.Plugin
import org.blackerp.plugin.PluginError
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.extension
import kotlin.io.path.isRegularFile
class FileSystemPluginDiscovery : PluginDiscovery {
override suspend fun discoverPlugins(directory: Path): Either<PluginError, List<Plugin>> =
try {
Files.walk(directory)
.filter { it.isRegularFile() && it.extension == "jar" }
.use { paths ->
paths.toList()
.map { loadPlugin(it) }
.filter { it.isRight() }
.map { it.getOrNull()!! }
.toList()
.right()
}
} catch (e: Exception) {
PluginError.DiscoveryFailed("Failed to discover plugins: ${e.message}", e).left()
}
override suspend fun loadPlugin(jarPath: Path): Either<PluginError, Plugin> =
try {
// Placeholder for actual JAR loading logic
// Will be implemented with proper classloading
PluginError.LoadFailed("Plugin loading not yet implemented").left()
} catch (e: Exception) {
PluginError.LoadFailed("Failed to load plugin: ${e.message}").left()
}
}

File: ./src/main/kotlin/org/blackerp/plugin/discovery/PluginDiscovery.kt
-------------------------------------------
package org.blackerp.plugin.discovery
import arrow.core.Either
import org.blackerp.plugin.Plugin
import org.blackerp.plugin.PluginError
import java.nio.file.Path
interface PluginDiscovery {
suspend fun discoverPlugins(directory: Path): Either<PluginError, List<Plugin>>
suspend fun loadPlugin(jarPath: Path): Either<PluginError, Plugin>
}

File: ./src/main/kotlin/org/blackerp/plugin/ExtensionRegistry.kt
-------------------------------------------
package org.blackerp.plugin
import arrow.core.Either
interface ExtensionRegistry {
/**
* Register an extension for a specific extension point
* @param extension The extension implementation
* @return Either a registration error or Unit on success
*/
suspend fun <T : Extension> register(extension: T): Either<PluginError, Unit>
/**
* Get all registered extensions for a specific type
* @return List of registered extensions
*/
fun <T : Extension> getExtensions(type: Class<T>): List<T>
}

File: ./src/main/kotlin/org/blackerp/plugin/PluginId.kt
-------------------------------------------
package org.blackerp.plugin
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class PluginId private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, PluginId> =
when {
!value.matches(Regex("^[a-z][a-z0-9-]*$")) ->
ValidationError.InvalidFormat(
"Plugin ID must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"
).left()
value.length !in 3..50 ->
ValidationError.InvalidLength("plugin id", 3, 50).left()
else -> PluginId(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/plugin/registry/PluginRegistry.kt
-------------------------------------------
package org.blackerp.plugin.registry
import arrow.core.Either
import org.blackerp.plugin.Plugin
import org.blackerp.plugin.PluginError
import org.blackerp.plugin.PluginId
interface PluginRegistry {
suspend fun register(plugin: Plugin): Either<PluginError, Unit>
suspend fun unregister(pluginId: PluginId): Either<PluginError, Unit>
suspend fun getPlugin(pluginId: PluginId): Either<PluginError, Plugin>
fun getPlugins(): List<Plugin>
}

File: ./src/main/kotlin/org/blackerp/plugin/registry/DefaultPluginRegistry.kt
-------------------------------------------
package org.blackerp.plugin.registry
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.plugin.Plugin
import org.blackerp.plugin.PluginError
import org.blackerp.plugin.PluginId
import java.util.concurrent.ConcurrentHashMap
class DefaultPluginRegistry : PluginRegistry {
private val plugins = ConcurrentHashMap<PluginId, Plugin>()
override suspend fun register(plugin: Plugin): Either<PluginError, Unit> =
when {
plugins.containsKey(plugin.metadata.id) ->
PluginError.DuplicatePlugin(plugin.metadata.id.value).left()
else -> {
plugins[plugin.metadata.id] = plugin
Unit.right()
}
}
override suspend fun unregister(pluginId: PluginId): Either<PluginError, Unit> =
plugins.remove(pluginId)?.let {
Unit.right()
} ?: PluginError.NotFound(pluginId.value).left()
override suspend fun getPlugin(pluginId: PluginId): Either<PluginError, Plugin> =
plugins[pluginId]?.right() ?: PluginError.NotFound(pluginId.value).left()
override fun getPlugins(): List<Plugin> = plugins.values.toList()
}

File: ./src/main/kotlin/org/blackerp/plugin/Version.kt
-------------------------------------------
package org.blackerp.plugin
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
data class Version private constructor(
val major: Int,
val minor: Int,
val patch: Int
) : Comparable<Version> {
override fun compareTo(other: Version): Int {
return when {
major != other.major -> major - other.major
minor != other.minor -> minor - other.minor
else -> patch - other.patch
}
}
companion object {
private val VERSION_PATTERN = Regex("^\\d+\\.\\d+\\.\\d+$")
fun create(version: String): Either<ValidationError, Version> {
if (!version.matches(VERSION_PATTERN)) {
return ValidationError.InvalidFormat("Version must be in format major.minor.patch").left()
}
return try {
val parts = version.split(".")
if (parts.size != 3) {
ValidationError.InvalidFormat("Version must be in format major.minor.patch").left()
} else {
Version(
major = parts[0].toInt(),
minor = parts[1].toInt(),
patch = parts[2].toInt()
).right()
}
} catch (e: NumberFormatException) {
ValidationError.InvalidFormat("Version components must be integers").left()
}
}
}
override fun toString(): String = "$major.$minor.$patch"
}

File: ./src/main/kotlin/org/blackerp/plugin/Extension.kt
-------------------------------------------
package org.blackerp.plugin
/**
* Base interface for all plugin extensions
*/
interface Extension {
val pluginId: PluginId
}

File: ./src/main/kotlin/org/blackerp/plugin/PluginMetadata.kt
-------------------------------------------
package org.blackerp.plugin
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
data class PluginMetadata private constructor(
val id: PluginId,
val version: Version,
val name: String,
val description: String,
val vendor: String
) {
companion object {
fun create(
id: PluginId,
version: Version,
name: String,
description: String,
vendor: String
): Either<ValidationError, PluginMetadata> =
when {
name.isBlank() ->
ValidationError.Required("name").left()
name.length !in 3..100 ->
ValidationError.InvalidLength("name", 3, 100).left()
description.length > 500 ->
ValidationError.InvalidLength("description", 0, 500).left()
vendor.isBlank() ->
ValidationError.Required("vendor").left()
vendor.length !in 3..100 ->
ValidationError.InvalidLength("vendor", 3, 100).left()
else -> PluginMetadata(id, version, name, description, vendor).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/ad/ADModule.kt
-------------------------------------------
package org.blackerp.domain.ad
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.ad.value.ModuleName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.shared.ValidationError
import org.blackerp.plugin.Version
data class ADModule(
override val metadata: EntityMetadata,
val name: ModuleName,
override val displayName: DisplayName,
override val description: Description?,
val version: Version
) : ADObject {
companion object {
fun create(params: CreateModuleParams): Either<ValidationError, ADModule> =
ADModule(
metadata = params.metadata,
name = params.name,
displayName = params.displayName,
description = params.description,
version = params.version
).right()
}
}
data class CreateModuleParams(
val metadata: EntityMetadata,
val name: ModuleName,
val displayName: DisplayName,
val description: Description?,
val version: Version
)

File: ./src/main/kotlin/org/blackerp/domain/ad/window/value/WindowName.kt
-------------------------------------------
package org.blackerp.domain.ad.window.value
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class WindowName private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, WindowName> =
when {
!value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
ValidationError.InvalidFormat(
"Window name must start with lowercase letter and contain only lowercase letters, numbers, and underscores"
).left()
value.length !in 3..50 ->
ValidationError.InvalidLength("window name", 3, 50).left()
else -> WindowName(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/ad/ADObject.kt
-------------------------------------------
package org.blackerp.domain.ad
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
interface ADObject : DomainEntity {
val displayName: DisplayName
val description: Description?
}

File: ./src/main/kotlin/org/blackerp/domain/ad/tab/TabOperations.kt
-------------------------------------------
package org.blackerp.domain.ad.tab
import arrow.core.Either
import org.blackerp.domain.values.TableName
import java.util.UUID
interface TabOperations {
suspend fun save(tab: ADTab): Either<TabError, ADTab>
suspend fun findById(id: UUID): Either<TabError, ADTab?>
suspend fun findByTable(tableName: TableName): Either<TabError, List<ADTab>>
suspend fun delete(id: UUID): Either<TabError, Unit>
}

File: ./src/main/kotlin/org/blackerp/domain/ad/tab/CreateTabParams.kt
-------------------------------------------
package org.blackerp.domain.ad.tab
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.domain.ad.tab.value.TabName
data class CreateTabParams(
val metadata: EntityMetadata,
val name: TabName,
val displayName: DisplayName,
val description: Description?,
val table: ADTable,
val queryColumns: List<ColumnName>,
val displayColumns: List<ColumnName>,
val orderBy: List<OrderBySpec>
)

File: ./src/main/kotlin/org/blackerp/domain/ad/tab/OrderBySpec.kt
-------------------------------------------
package org.blackerp.domain.ad.tab
import org.blackerp.domain.values.ColumnName
data class OrderBySpec(
val column: ColumnName,
val direction: SortDirection
)
enum class SortDirection {
ASC, DESC;
companion object {
fun fromString(value: String): SortDirection =
values().find { it.name.equals(value, ignoreCase = true) }
?: throw IllegalArgumentException("Invalid sort direction: $value")
}
}

File: ./src/main/kotlin/org/blackerp/domain/ad/tab/value/TabName.kt
-------------------------------------------
package org.blackerp.domain.ad.tab.value
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class TabName private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, TabName> =
when {
!value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
ValidationError.InvalidFormat(
"Tab name must start with lowercase letter and contain only lowercase letters, numbers, and underscores"
).left()
value.length !in 3..50 ->
ValidationError.InvalidLength("tab name", 3, 50).left()
else -> TabName(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/ad/tab/TabError.kt
-------------------------------------------
package org.blackerp.domain.ad.tab
import org.blackerp.domain.DomainException
import org.blackerp.shared.ValidationError
sealed class TabError(message: String) : DomainException(message) {
data class ValidationFailed(val errors: List<ValidationError>) :
TabError("Validation failed: ${errors.joinToString { it.message }}")
data class NotFound(val id: String) :
TabError("Tab not found: $id")
data class DuplicateTab(val name: String) :
TabError("Tab already exists: $name")
}

File: ./src/main/kotlin/org/blackerp/domain/ad/tab/ADTab.kt
-------------------------------------------
package org.blackerp.domain.ad.tab
import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.ad.ADObject
import org.blackerp.domain.ad.tab.value.TabName
import org.blackerp.domain.values.*
import org.blackerp.domain.table.ADTable
import org.blackerp.shared.ValidationError
data class ADTab(
override val metadata: EntityMetadata,
val name: TabName,
override val displayName: DisplayName,
override val description: Description?,
val table: ADTable,
val queryColumns: List<ColumnName>,
val displayColumns: List<ColumnName>,
val orderBy: List<OrderBySpec>
) : ADObject {
companion object {
fun create(params: CreateTabParams): Either<TabError, ADTab> {
val errors = mutableListOf<ValidationError>()
// Validate query columns exist in table
val invalidQueryColumns = params.queryColumns.filter { queryCol ->
!params.table.columns.any { it.name == queryCol }
}
if (invalidQueryColumns.isNotEmpty()) {
errors.add(ValidationError.InvalidValue(
"Query columns not found in table: ${invalidQueryColumns.joinToString { it.value }}"
))
}
// Validate display columns exist in table
val invalidDisplayColumns = params.displayColumns.filter { displayCol ->
!params.table.columns.any { it.name == displayCol }
}
if (invalidDisplayColumns.isNotEmpty()) {
errors.add(ValidationError.InvalidValue(
"Display columns not found in table: ${invalidDisplayColumns.joinToString { it.value }}"
))
}
// Validate order by columns exist in table
val invalidOrderColumns = params.orderBy.filter { orderSpec ->
!params.table.columns.any { it.name == orderSpec.column }
}
if (invalidOrderColumns.isNotEmpty()) {
errors.add(ValidationError.InvalidValue(
"Order by columns not found in table: ${invalidOrderColumns.joinToString { it.column.value }}"
))
}
if (errors.isNotEmpty()) {
return TabError.ValidationFailed(errors).left()
}
return ADTab(
metadata = params.metadata,
name = params.name,
displayName = params.displayName,
description = params.description,
table = params.table,
queryColumns = params.queryColumns,
displayColumns = params.displayColumns,
orderBy = params.orderBy
).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/ad/value/ModuleName.kt
-------------------------------------------
package org.blackerp.domain.ad.value
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class ModuleName private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, ModuleName> =
when {
!value.matches(Regex("^[a-z][a-z0-9-]*$")) ->
ValidationError.InvalidFormat(
"Module name must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"
).left()
value.length !in 3..50 ->
ValidationError.InvalidLength("module name", 3, 50).left()
else -> ModuleName(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/ad/reference/value/ReferenceName.kt
-------------------------------------------
package org.blackerp.domain.ad.reference.value
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class ReferenceName private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, ReferenceName> =
when {
!value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
ValidationError.InvalidFormat(
"Reference name must start with lowercase letter and contain only lowercase letters, numbers, and underscores"
).left()
value.length !in 3..50 ->
ValidationError.InvalidLength("reference name", 3, 50).left()
else -> ReferenceName(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/ad/reference/ADReference.kt
-------------------------------------------
package org.blackerp.domain.ad.reference
import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.ad.ADObject
import org.blackerp.domain.ad.reference.value.ReferenceName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.shared.ValidationError
data class ADReference(
override val metadata: EntityMetadata,
val name: ReferenceName,
override val displayName: DisplayName,
override val description: Description?,
val type: ReferenceType,
val validationRule: ValidationRule?
) : ADObject {
companion object {
fun create(params: CreateReferenceParams): Either<ReferenceError, ADReference> =
ADReference(
metadata = params.metadata,
name = params.name,
displayName = params.displayName,
description = params.description,
type = params.type,
validationRule = params.validationRule
).right()
}
}
data class ValidationRule(
val expression: String,
val errorMessage: String
)
sealed interface ReferenceType {
object List : ReferenceType
data class Table(val tableName: String, val keyColumn: String, val displayColumn: String) : ReferenceType
object Search : ReferenceType
data class Custom(val validatorClass: String) : ReferenceType
}
data class CreateReferenceParams(
val metadata: EntityMetadata,
val name: ReferenceName,
val displayName: DisplayName,
val description: Description?,
val type: ReferenceType,
val validationRule: ValidationRule? = null
)
sealed class ReferenceError {
data class ValidationFailed(val errors: List<ValidationError>) : ReferenceError()
data class DuplicateReference(val name: String) : ReferenceError()
data class ReferenceNotFound(val name: String) : ReferenceError()
}

File: ./src/main/kotlin/org/blackerp/domain/event/EventMetadata.kt
-------------------------------------------
package org.blackerp.domain.event
import java.time.Instant
import java.util.UUID
data class EventMetadata(
val id: UUID,
val timestamp: Instant,
val user: String
)

File: ./src/main/kotlin/org/blackerp/domain/event/DomainEvent.kt
-------------------------------------------
package org.blackerp.domain.event
interface DomainEvent {
val metadata: EventMetadata
}

File: ./src/main/kotlin/org/blackerp/domain/event/TableCreated.kt
-------------------------------------------
package org.blackerp.domain.event
import java.util.UUID
data class TableCreated(
override val metadata: EventMetadata,
val tableId: UUID,
val tableName: String
) : DomainEvent

File: ./src/main/kotlin/org/blackerp/domain/DomainException.kt
-------------------------------------------
package org.blackerp.domain
abstract class DomainException(message: String) : Exception(message)

File: ./src/main/kotlin/org/blackerp/domain/error/DomainError.kt
-------------------------------------------
package org.blackerp.domain.error
sealed interface DomainError {
val message: String
data class ValidationError(
override val message: String,
val field: String? = null
) : DomainError
data class NotFoundError(
override val message: String,
val id: String
) : DomainError
data class SecurityError(
override val message: String,
val reason: String
) : DomainError
data class CacheError(
override val message: String,
val cause: Throwable? = null
) : DomainError
data class QueryError(
override val message: String,
val reason: String
) : DomainError
data class SystemError(
override val message: String,
val cause: Throwable? = null
) : DomainError
}

File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantFilter.kt
-------------------------------------------
package org.blackerp.domain.tenant
import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.shared.ValidationError
data class TenantFilter(val tenantId: String?) {
companion object {
fun create(tenantId: String?): Either<ValidationError, TenantFilter> =
when {
tenantId == null -> TenantFilter(null).right()
!tenantId.matches(Regex("^[0-9a-fA-F-]{36}$")) ->
ValidationError.InvalidFormat("Invalid UUID format").left()
else -> TenantFilter(tenantId).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantContext.kt
-------------------------------------------
package org.blackerp.domain.tenant
import java.util.UUID
object TenantContext {
private val currentTenant = ThreadLocal<UUID>()
fun getCurrentTenant(): UUID? = currentTenant.get()
fun setCurrentTenant(tenantId: UUID) {
currentTenant.set(tenantId)
}
fun clear() {
currentTenant.remove()
}
}

File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantAware.kt
-------------------------------------------
package org.blackerp.domain.tenant
import java.util.UUID
interface TenantAware {
val tenantId: UUID
}

File: ./src/main/kotlin/org/blackerp/domain/values/DataType.kt
-------------------------------------------
package org.blackerp.domain.values
enum class DataType {
STRING,
INTEGER,
DECIMAL,
BOOLEAN,
DATE,
TIMESTAMP,
BINARY;
companion object {
fun fromString(value: String): DataType =
values().find { it.name.equals(value, ignoreCase = true) }
?: throw IllegalArgumentException("Invalid data type: $value")
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/Precision.kt
-------------------------------------------
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class Precision private constructor(val value: Int) {
companion object {
fun create(value: Int): Either<ValidationError, Precision> =
when {
value < 0 ->
ValidationError.InvalidValue("Precision cannot be negative").left()
value > 20 ->
ValidationError.InvalidValue("Precision cannot exceed 20").left()
else -> Precision(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/AccessLevel.kt
-------------------------------------------
package org.blackerp.domain.values
enum class AccessLevel {
SYSTEM,
CLIENT,
ORGANIZATION,
CLIENT_ORGANIZATION;
companion object {
fun fromString(value: String): AccessLevel =
values().find { it.name.equals(value, ignoreCase = true) }
?: throw IllegalArgumentException("Invalid access level: $value")
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/Description.kt
-------------------------------------------
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class Description private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, Description> =
when {
value.length > 255 ->
ValidationError.InvalidLength("description", 0, 255).left()
else -> Description(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/Amount.kt
-------------------------------------------
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
import java.math.BigDecimal
@JvmInline
value class Amount private constructor(val value: BigDecimal) {
companion object {
fun create(value: BigDecimal): Either<ValidationError, Amount> =
when {
value < BigDecimal.ZERO ->
ValidationError.InvalidValue("Amount cannot be negative").left()
else -> Amount(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/ColumnName.kt
-------------------------------------------
// File: src/main/kotlin/org/blackerp/domain/values/ColumnName.kt
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class ColumnName private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, ColumnName> =
when {
!value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
ValidationError.InvalidFormat("Column name must start with lowercase letter and contain only lowercase letters, numbers, and underscores").left()
value.length > 30 ->
ValidationError.InvalidLength("column name", 1, 30).left()
else -> ColumnName(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/Scale.kt
-------------------------------------------
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class Scale private constructor(val value: Int) {
companion object {
fun create(value: Int): Either<ValidationError, Scale> =
when {
value < 0 ->
ValidationError.InvalidValue("Scale cannot be negative").left()
value > 10 ->
ValidationError.InvalidValue("Scale cannot exceed 10").left()
else -> Scale(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/Length.kt
-------------------------------------------
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class Length private constructor(val value: Int) {
companion object {
fun create(value: Int): Either<ValidationError, Length> =
when {
value <= 0 ->
ValidationError.InvalidValue("Length must be positive").left()
else -> Length(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/EventMetadata.kt
-------------------------------------------
package org.blackerp.domain.values
import java.time.Instant
import java.util.UUID
data class EventMetadata(
val id: UUID,
val timestamp: Instant,
val user: String
)

File: ./src/main/kotlin/org/blackerp/domain/values/TableName.kt
-------------------------------------------
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class TableName private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, TableName> =
when {
!value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
ValidationError.InvalidFormat("Table name must start with lowercase letter and contain only lowercase letters, numbers, and underscores").left()
else -> TableName(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/Currency.kt
-------------------------------------------
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class Currency private constructor(val code: String) {
companion object {
fun create(code: String): Either<ValidationError, Currency> =
when {
!code.matches(Regex("^[A-Z]{3}$")) ->
ValidationError.InvalidFormat("Currency code must be 3 uppercase letters").left()
else -> Currency(code).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/values/DisplayName.kt
-------------------------------------------
package org.blackerp.domain.values
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class DisplayName private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, DisplayName> =
when {
value.isBlank() ->
ValidationError.Required("display name").left()
value.length !in 1..60 ->
ValidationError.InvalidLength("display name", 1, 60).left()
else -> DisplayName(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/transaction/Transaction.kt
-------------------------------------------
package org.blackerp.domain.transaction
import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.Amount
import org.blackerp.domain.values.Currency
import java.time.Instant
data class Transaction(
override val metadata: EntityMetadata,
val amount: Amount,
val currency: Currency,
val timestamp: Instant,
val description: String?
) : DomainEntity {
companion object {
fun create(params: CreateTransactionParams): Either<TransactionError, Transaction> =
Transaction(
metadata = params.metadata,
amount = params.amount,
currency = params.currency,
timestamp = params.timestamp,
description = params.description
).right()
}
}
data class CreateTransactionParams(
val metadata: EntityMetadata,
val amount: Amount,
val currency: Currency,
val timestamp: Instant = Instant.now(),
val description: String?
)

File: ./src/main/kotlin/org/blackerp/domain/transaction/TransactionError.kt
-------------------------------------------
package org.blackerp.domain.transaction
import org.blackerp.shared.ValidationError
sealed class TransactionError {
abstract val message: String
data class ValidationFailed(
override val message: String,
val errors: List<ValidationError>
) : TransactionError()
data class InvalidAmount(
val amount: String,
override val message: String = "Invalid amount: $amount"
) : TransactionError()
data class InvalidCurrency(
val currency: String,
override val message: String = "Invalid currency: $currency"
) : TransactionError()
}

File: ./src/main/kotlin/org/blackerp/domain/query/QueryResult.kt
-------------------------------------------
package org.blackerp.domain.query
import arrow.core.Either
import org.blackerp.domain.error.DomainError
data class QueryResult<T>(
val items: List<T>,
val total: Long,
val page: Int,
val pageSize: Int
)
interface QueryExecutor<T> {
suspend fun execute(criteria: QueryCriteria, page: Int, pageSize: Int): Either<DomainError, QueryResult<T>>
}

File: ./src/main/kotlin/org/blackerp/domain/query/QueryCriteria.kt
-------------------------------------------
package org.blackerp.domain.query
sealed interface QueryCriteria {
data class Equals(val field: String, val value: Any) : QueryCriteria
data class Like(val field: String, val pattern: String) : QueryCriteria
data class Between(val field: String, val start: Any, val end: Any) : QueryCriteria
data class In(val field: String, val values: List<Any>) : QueryCriteria
data class And(val criteria: List<QueryCriteria>) : QueryCriteria
data class Or(val criteria: List<QueryCriteria>) : QueryCriteria
}

File: ./src/main/kotlin/org/blackerp/domain/DomainEntity.kt
-------------------------------------------
package org.blackerp.domain
interface DomainEntity {
val metadata: EntityMetadata
}

File: ./src/main/kotlin/org/blackerp/domain/table/TableOperations.kt
-------------------------------------------
// File: src/main/kotlin/org/blackerp/domain/table/TableOperations.kt
package org.blackerp.domain.table
import arrow.core.Either
import java.util.UUID
interface TableOperations {
/**
* Returns all tables in the system
* @return Either an error or list of tables
*/
suspend fun findAll(): Either<TableError, List<ADTable>>
/**
* Saves a table to the store
* @param table The table to save
* @return Either an error or the saved table
*/
suspend fun save(table: ADTable): Either<TableError, ADTable>
/**
* Finds a table by its ID
* @param id The UUID of the table
* @return Either an error or the found table (null if not found)
*/
suspend fun findById(id: UUID): Either<TableError, ADTable?>
/**
* Finds a table by its name
* @param name The name of the table
* @return Either an error or the found table (null if not found)
*/
suspend fun findByName(name: String): Either<TableError, ADTable?>
/**
* Deletes a table by its ID
* @param id The UUID of the table to delete
* @return Either an error or Unit on success
*/
suspend fun delete(id: UUID): Either<TableError, Unit>
}

File: ./src/main/kotlin/org/blackerp/domain/table/ADTable.kt
-------------------------------------------
package org.blackerp.domain.table
import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.domain.values.AccessLevel
import org.blackerp.domain.table.ColumnDefinition
data class ADTable(
override val metadata: EntityMetadata,
val name: TableName,
val displayName: DisplayName,
val description: Description?,
val accessLevel: AccessLevel,
val columns: List<ColumnDefinition> // Added columns property
) : DomainEntity {
companion object {
fun create(params: CreateTableParams): Either<TableError, ADTable> =
ADTable(
metadata = params.metadata,
name = params.name,
displayName = params.displayName,
description = params.description,
accessLevel = params.accessLevel,
columns = params.columns // Initialize columns
).right()
}
}
data class CreateTableParams(
val metadata: EntityMetadata,
val name: TableName,
val displayName: DisplayName,
val description: Description?,
val accessLevel: AccessLevel,
val columns: List<ColumnDefinition>
)

File: ./src/main/kotlin/org/blackerp/domain/table/extension/TableExtensionPoint.kt
-------------------------------------------
package org.blackerp.domain.table.extension
import arrow.core.Either
import org.blackerp.domain.table.ADTable
import org.blackerp.plugin.Extension
import org.blackerp.plugin.PluginError
interface TableExtensionPoint {
suspend fun beforeCreate(table: ADTable): Either<PluginError, ADTable>
suspend fun afterCreate(table: ADTable)
suspend fun beforeUpdate(table: ADTable): Either<PluginError, ADTable>
suspend fun afterUpdate(table: ADTable)
suspend fun beforeDelete(table: ADTable): Either<PluginError, Unit>
suspend fun afterDelete(table: ADTable)
}

File: ./src/main/kotlin/org/blackerp/domain/table/extension/TableExtension.kt
-------------------------------------------
package org.blackerp.domain.table.extension
import org.blackerp.plugin.Extension
import org.blackerp.plugin.PluginId
interface TableExtension : Extension, TableExtensionPoint {
override val pluginId: PluginId
}

File: ./src/main/kotlin/org/blackerp/domain/table/CreateColumnParams.kt
-------------------------------------------
package org.blackerp.domain.table
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.values.DataType
import org.blackerp.domain.values.Length
import org.blackerp.domain.values.Precision
import org.blackerp.domain.values.Scale
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
// Unified CreateColumnParams definition
data class CreateColumnParams(
val metadata: EntityMetadata,
val name: ColumnName,
val displayName: DisplayName,
val description: Description?,
val dataType: DataType,
val length: Length?,
val precision: Precision?,
val scale: Scale?,
val mandatory: Boolean = false,
val defaultValue: String? = null
)

File: ./src/main/kotlin/org/blackerp/domain/table/TenantAwareTable.kt
-------------------------------------------
package org.blackerp.domain.table
import org.blackerp.domain.tenant.TenantAware
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.*
import java.util.UUID
data class TenantAwareTable(
override val metadata: EntityMetadata,
override val tenantId: UUID,
val delegate: ADTable
) : DomainEntity by delegate, TenantAware {
val name: TableName
get() = delegate.name
val displayName: DisplayName
get() = delegate.displayName
companion object {
fun from(table: ADTable, tenantId: UUID): TenantAwareTable =
TenantAwareTable(
metadata = table.metadata,
tenantId = tenantId,
delegate = table
)
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/constraint/TableConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.constraint
import arrow.core.Either
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.shared.ValidationError
interface TableConstraint : DomainEntity {
// Make the interface method suspend as well
suspend fun validate(table: TableDefinition): Either<ValidationError, Unit>
}

File: ./src/main/kotlin/org/blackerp/domain/table/constraint/UniqueConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.constraint
import org.blackerp.domain.table.definition.TableDefinition
import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.shared.ValidationError
data class UniqueConstraint(
override val metadata: EntityMetadata,
val columns: List<ColumnName>
) : TableConstraint {
override suspend fun validate(table: TableDefinition): Either<ValidationError, Unit> {
val tableColumns = table.columns.map { it.name }
val invalidColumns = columns.filter { it !in tableColumns }
return if (invalidColumns.isEmpty()) {
Unit.right()
} else {
ValidationError.InvalidValue(
"Columns not found in table: ${invalidColumns.joinToString { it.value }}"
).left()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/constraint/NotNullConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.constraint
import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.shared.ValidationError
import org.blackerp.domain.table.definition.TableDefinition
data class NotNullConstraint(
override val metadata: EntityMetadata,
val column: ColumnName
) : TableConstraint {
override suspend fun validate(table: TableDefinition): Either<ValidationError, Unit> {
val columnExists = table.columns.any { it.name == column }
return if (columnExists) {
Unit.right()
} else {
ValidationError.InvalidValue("Column not found in table: ${column.value}").left()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/constraint/ReferenceConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.constraint
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.*
import org.blackerp.domain.table.TableOperations
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.shared.ValidationError
import org.blackerp.shared.ReferenceValidation
data class ReferenceConstraint(
override val metadata: EntityMetadata,
val column: ColumnName,
val referenceTable: TableName,
val referenceColumn: ColumnName,
private val tableOperations: TableOperations
) : TableConstraint {
override suspend fun validate(table: TableDefinition): Either<ValidationError, Unit> {
// 1. Verify source column exists
val sourceColumn = table.columns.find { it.name == column }
?: return ReferenceValidation.ColumnNotFound(column.value).left()
// 2. Find reference table
when (val refTableResult = tableOperations.findByName(referenceTable.value)) {
is Either.Left -> return ReferenceValidation.ReferenceTableNotFound(referenceTable.value).left()
is Either.Right -> {
val refTable = refTableResult.value
?: return ReferenceValidation.ReferenceTableNotFound(referenceTable.value).left()
// Convert ADTable to TableDefinition
val refTableDef = toTableDefinition(refTable)
// 3. Verify reference column exists
val refColumn = refTableDef.columns.find { it.name == referenceColumn }
?: return ReferenceValidation.ReferenceColumnNotFound(
referenceTable.value,
referenceColumn.value
).left()
// 4. Check type compatibility
if (sourceColumn.dataType != refColumn.dataType) {
return ReferenceValidation.IncompatibleTypes(
sourceColumn.name.value,
sourceColumn.dataType.name,
refColumn.name.value,
refColumn.dataType.name
).left()
}
// 5. Check length/precision compatibility for certain types
when (sourceColumn.dataType) {
DataType.STRING -> {
val sourceLength = sourceColumn.length?.value ?: 0
val refLength = refColumn.length?.value ?: 0
if (sourceLength > refLength) {
return ValidationError.InvalidValue(
"Source column length ($sourceLength) cannot be greater than reference column length ($refLength)"
).left()
}
}
DataType.DECIMAL -> {
val sourcePrecision = sourceColumn.precision?.value ?: 0
val refPrecision = refColumn.precision?.value ?: 0
if (sourcePrecision > refPrecision) {
return ValidationError.InvalidValue(
"Source column precision ($sourcePrecision) cannot be greater than reference column precision ($refPrecision)"
).left()
}
val sourceScale = sourceColumn.scale?.value ?: 0
val refScale = refColumn.scale?.value ?: 0
if (sourceScale > refScale) {
return ValidationError.InvalidValue(
"Source column scale ($sourceScale) cannot be greater than reference column scale ($refScale)"
).left()
}
}
else -> Unit
}
return Unit.right()
}
}
}
private fun toTableDefinition(table: ADTable): TableDefinition {
return TableDefinition(
metadata = table.metadata,
name = table.name,
displayName = table.displayName,
description = table.description,
accessLevel = table.accessLevel,
columns = table.columns,
constraints = emptyList(),
behaviors = emptyList()
)
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/TableCreated.kt
-------------------------------------------
package org.blackerp.domain.table
import org.blackerp.domain.DomainEvent
import org.blackerp.domain.values.EventMetadata
import java.util.UUID
data class TableCreated(
override val metadata: EventMetadata,
val tableId: UUID,
val tableName: String
) : DomainEvent

File: ./src/main/kotlin/org/blackerp/domain/table/TableError.kt
-------------------------------------------
package org.blackerp.domain.table
import org.blackerp.domain.DomainException
import org.blackerp.shared.ValidationError
sealed class TableError(message: String) : DomainException(message) {
data class ValidationFailed(val errors: List<ValidationError>) :
TableError("Validation failed: ${errors.joinToString { it.message }}")
data class StorageError(override val cause: Throwable) :
TableError("Storage error: ${cause.message}")
data class DuplicateTable(val name: String) :
TableError("Table already exists: $name")
data class NotFound(val id: String) :
TableError("Table not found: $id")
data class ConcurrentModification(val id: String) :
TableError("Concurrent modification detected for table: $id")
}

File: ./src/main/kotlin/org/blackerp/domain/table/definition/TableDefinition.kt
-------------------------------------------
package org.blackerp.domain.table.definition
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.*
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.constraint.TableConstraint
import org.blackerp.domain.table.behavior.TableBehavior
import org.blackerp.shared.ValidationError
import kotlinx.coroutines.runBlocking
data class TableDefinition(
override val metadata: EntityMetadata,
val name: TableName,
val displayName: DisplayName,
val description: Description?,
val accessLevel: AccessLevel,
val columns: List<ColumnDefinition>,
val constraints: List<TableConstraint>,
val behaviors: List<TableBehavior>
) : DomainEntity {
companion object {
suspend fun create(params: CreateTableParams): Either<TableError, TableDefinition> {
val errors = mutableListOf<ValidationError>()
// Basic validation
if (params.columns.isEmpty()) {
errors.add(ValidationError.Required("at least one column"))
}
// Check for duplicate column names
val duplicateColumns = params.columns
.groupBy { it.name.value }
.filter { it.value.size > 1 }
.keys
if (duplicateColumns.isNotEmpty()) {
errors.add(ValidationError.InvalidValue(
"Duplicate column names: ${duplicateColumns.joinToString()}"
))
}
if (errors.isNotEmpty()) {
return TableError.ValidationFailed(errors).left()
}
val table = TableDefinition(
metadata = params.metadata,
name = params.name,
displayName = params.displayName,
description = params.description,
accessLevel = params.accessLevel,
columns = params.columns,
constraints = params.constraints,
behaviors = params.behaviors
)
// Validate all constraints
val constraintErrors = table.constraints
.map { it.validate(table) }
.filter { it.isLeft() }
.flatMap { (it as Either.Left).value.let { listOf(it) } }
if (constraintErrors.isNotEmpty()) {
return TableError.ValidationFailed(constraintErrors).left()
}
return table.right()
}
}
suspend fun validate(): Either<TableError, Unit> {
val errors = constraints
.map { it.validate(this) }
.filter { it.isLeft() }
.flatMap { (it as Either.Left).value.let { listOf(it) } }
return if (errors.isEmpty()) {
Unit.right()
} else {
TableError.ValidationFailed(errors).left()
}
}
}
data class CreateTableParams(
val metadata: EntityMetadata,
val name: TableName,
val displayName: DisplayName,
val description: Description?,
val accessLevel: AccessLevel,
val columns: List<ColumnDefinition>,
val constraints: List<TableConstraint> = emptyList(),
val behaviors: List<TableBehavior> = emptyList()
)

File: ./src/main/kotlin/org/blackerp/domain/table/behavior/TableBehavior.kt
-------------------------------------------
package org.blackerp.domain.table.behavior
import org.blackerp.domain.table.definition.TableDefinition
import arrow.core.Either
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.table.TableError
interface TableBehavior : DomainEntity {
fun beforeSave(table: TableDefinition): Either<TableError, TableDefinition>
fun afterSave(table: TableDefinition)
fun beforeDelete(table: TableDefinition): Either<TableError, Unit>
fun afterDelete(table: TableDefinition)
}

File: ./src/main/kotlin/org/blackerp/domain/table/TableId.kt
-------------------------------------------
package org.blackerp.domain.table
import java.util.UUID
@JvmInline
value class TableId(val value: UUID)

File: ./src/main/kotlin/org/blackerp/domain/table/ColumnDefinition.kt
-------------------------------------------
package org.blackerp.domain.table
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.domain.values.DataType
import org.blackerp.domain.values.Length
import org.blackerp.domain.values.Precision
import org.blackerp.domain.values.Scale
import org.blackerp.shared.ValidationError
data class ColumnDefinition(
override val metadata: EntityMetadata,
val name: ColumnName,
val displayName: DisplayName,
val description: Description?,
val dataType: DataType,
val length: Length?,
val precision: Precision?,
val scale: Scale?,
val mandatory: Boolean = false,
val defaultValue: String? = null
) : DomainEntity {
companion object {
fun create(params: CreateColumnParams): Either<ColumnError, ColumnDefinition> {
val errors = mutableListOf<ValidationError>()
when (params.dataType) {
DataType.STRING -> {
if (params.length == null)
errors.add(ValidationError.Required("length for string type"))
if (params.precision != null || params.scale != null)
errors.add(ValidationError.InvalidValue("string type cannot have precision or scale"))
}
DataType.DECIMAL -> {
if (params.precision == null)
errors.add(ValidationError.Required("precision for decimal type"))
if (params.length != null)
errors.add(ValidationError.InvalidValue("decimal type cannot have length"))
}
else -> {
if (params.length != null || params.precision != null || params.scale != null)
errors.add(ValidationError.InvalidValue("type ${params.dataType} cannot have length, precision, or scale"))
}
}
if (errors.isNotEmpty()) {
return ColumnError.ValidationFailed(errors).left()
}
return ColumnDefinition(
metadata = params.metadata,
name = params.name,
displayName = params.displayName,
description = params.description,
dataType = params.dataType,
length = params.length,
precision = params.precision,
scale = params.scale,
mandatory = params.mandatory,
defaultValue = params.defaultValue
).right()
}
}
}
sealed interface ColumnError {
data class ValidationFailed(val errors: List<ValidationError>) : ColumnError
data class NotFound(val columnName: String) : ColumnError
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/event/RelationshipEvent.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.event
import org.blackerp.domain.event.DomainEvent
import org.blackerp.domain.event.EventMetadata
import java.util.UUID
sealed interface RelationshipEvent : DomainEvent
data class RelationshipCreated(
override val metadata: EventMetadata,
val relationshipId: UUID,
val sourceTable: String,
val targetTable: String
) : RelationshipEvent
data class RelationshipDeleted(
override val metadata: EventMetadata,
val relationshipId: UUID
) : RelationshipEvent

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/CreateRelationshipParams.kt
-------------------------------------------
package org.blackerp.domain.table.relationship
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.value.RelationType
import org.blackerp.domain.table.relationship.value.RelationshipName
import org.blackerp.domain.table.relationship.value.DeleteRule
import org.blackerp.domain.table.relationship.value.UpdateRule
data class CreateRelationshipParams(
val metadata: EntityMetadata,
val name: RelationshipName,
val sourceTable: TableName,
val targetTable: TableName,
val type: RelationType,
val sourceColumn: ColumnName,
val targetColumn: ColumnName,
val deleteRule: DeleteRule = DeleteRule.RESTRICT,    // Added this
val updateRule: UpdateRule = UpdateRule.RESTRICT,    // Added this
val junctionTable: TableName? = null,
val constraints: List<RelationshipConstraint> = emptyList()
)

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/TableRelationship.kt
-------------------------------------------
package org.blackerp.domain.table.relationship
import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.TableError
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.value.RelationType
import org.blackerp.domain.table.relationship.value.RelationshipName
import org.blackerp.domain.table.relationship.value.DeleteRule
import org.blackerp.domain.table.relationship.value.UpdateRule
import org.blackerp.shared.ValidationError
data class TableRelationship(
override val metadata: EntityMetadata,
val name: RelationshipName,
val sourceTable: TableName,
val targetTable: TableName,
val type: RelationType,
val sourceColumn: ColumnName,
val targetColumn: ColumnName,
val constraints: List<RelationshipConstraint>,
val deleteRule: DeleteRule = DeleteRule.RESTRICT,    // Added this
val updateRule: UpdateRule = UpdateRule.RESTRICT     // Added this
) : DomainEntity {
companion object {
fun create(params: CreateRelationshipParams): Either<TableError, TableRelationship> {
// Basic validation first
val errors = mutableListOf<ValidationError>()
// Validate relationship consistency
when (params.type) {
RelationType.ONE_TO_ONE, RelationType.ONE_TO_MANY -> {
if (params.sourceTable == params.targetTable && params.sourceColumn == params.targetColumn) {
errors.add(ValidationError.InvalidValue("Self-referential relationships must use different column names"))
}
}
RelationType.MANY_TO_MANY -> {
// Many-to-many relationships might need additional validation
// Consider junction table requirements
}
}
if (errors.isNotEmpty()) {
return TableError.ValidationFailed(errors).left()
}
return TableRelationship(
metadata = params.metadata,
name = params.name,
sourceTable = params.sourceTable,
targetTable = params.targetTable,
type = params.type,
sourceColumn = params.sourceColumn,
targetColumn = params.targetColumn,
constraints = params.constraints
).right()
}
}
suspend fun validate(): Either<TableError, Unit> {
val errors = constraints
.map { it.validate(this) }
.filter { it.isLeft() }
.flatMap { (it as Either.Left).value.let { listOf(it) } }
return if (errors.isEmpty()) {
Unit.right()
} else {
TableError.ValidationFailed(errors).left()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/RelationshipConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.relationship
import arrow.core.Either
import org.blackerp.domain.DomainEntity
import org.blackerp.shared.ValidationError
interface RelationshipConstraint : DomainEntity {
suspend fun validate(relationship: TableRelationship): Either<ValidationError, Unit>
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/constraint/IndexConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.constraint
import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.RelationshipConstraint
import org.blackerp.domain.table.relationship.TableRelationship
import org.blackerp.shared.ValidationError
data class IndexConstraint(
override val metadata: EntityMetadata,
val columns: List<ColumnName>,
val unique: Boolean = false
) : RelationshipConstraint {
override suspend fun validate(relationship: TableRelationship): Either<ValidationError, Unit> = Unit.right()
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/RelationshipName.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.value
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
@JvmInline
value class RelationshipName private constructor(val value: String) {
companion object {
fun create(value: String): Either<ValidationError, RelationshipName> =
when {
!value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
ValidationError.InvalidFormat(
"Relationship name must start with lowercase letter and contain only lowercase letters, numbers, and underscores"
).left()
value.length !in 3..50 ->
ValidationError.InvalidLength("relationship name", 3, 50).left()
else -> RelationshipName(value).right()
}
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/RelationType.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.value
enum class RelationType {
ONE_TO_ONE,
ONE_TO_MANY,
MANY_TO_MANY;
companion object {
fun fromString(value: String): RelationType =
values().find { it.name.equals(value, ignoreCase = true) }
?: throw IllegalArgumentException("Invalid relationship type: $value")
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/DeleteRule.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.value
enum class DeleteRule {
RESTRICT,
CASCADE,
SET_NULL,
NO_ACTION;
companion object {
fun fromString(value: String): DeleteRule =
values().find { it.name.equals(value, ignoreCase = true) }
?: throw IllegalArgumentException("Invalid delete rule: $value")
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/UpdateRule.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.value
enum class UpdateRule {
RESTRICT,
CASCADE,
SET_NULL,
NO_ACTION;
companion object {
fun fromString(value: String): UpdateRule =
values().find { it.name.equals(value, ignoreCase = true) }
?: throw IllegalArgumentException("Invalid update rule: $value")
}
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/RelationshipOperations.kt
-------------------------------------------
package org.blackerp.domain.table.relationship
import arrow.core.Either
import org.blackerp.domain.table.TableError
import org.blackerp.domain.values.TableName
import java.util.UUID
interface RelationshipOperations {
suspend fun save(relationship: TableRelationship): Either<TableError, TableRelationship>
suspend fun findById(id: UUID): Either<TableError, TableRelationship?>
suspend fun findByTable(tableName: TableName): Either<TableError, List<TableRelationship>>
suspend fun delete(id: UUID): Either<TableError, Unit>
}

File: ./src/main/kotlin/org/blackerp/domain/table/relationship/TableRelationshipError.kt
-------------------------------------------
package org.blackerp.domain.table.relationship
import org.blackerp.shared.ValidationError
sealed interface TableRelationshipError {
data class ValidationFailed(val errors: List<ValidationError>) : TableRelationshipError
data class DuplicateRelationship(val name: String) : TableRelationshipError
data class InvalidRelationType(val message: String) : TableRelationshipError
data class CircularReference(val tableName: String) : TableRelationshipError
}

File: ./src/main/kotlin/org/blackerp/domain/DomainEvent.kt
-------------------------------------------
package org.blackerp.domain
import org.blackerp.domain.values.EventMetadata
interface DomainEvent {
val metadata: EventMetadata
}

File: ./src/main/kotlin/org/blackerp/domain/EntityMetadata.kt
-------------------------------------------
package org.blackerp.domain
import org.blackerp.shared.TimeBasedId
import java.time.Instant
import java.util.UUID
data class EntityMetadata(
val id: UUID = TimeBasedId.generate(),
val created: Instant = Instant.now(),
val createdBy: String,
val updated: Instant = Instant.now(),
val updatedBy: String,
val version: Int = 0,
val active: Boolean = true
)

File: ./src/main/kotlin/org/blackerp/domain/security/SecurityContext.kt
-------------------------------------------
package org.blackerp.domain.security
import arrow.core.Either
import org.blackerp.domain.error.DomainError
import java.util.UUID
interface SecurityContext {
suspend fun getCurrentUser(): Either<DomainError, User>
suspend fun hasPermission(permission: Permission): Either<DomainError, Boolean>
suspend fun authenticate(credentials: Credentials): Either<DomainError, User>
}
data class User(
val id: UUID,
val username: String,
val roles: Set<Role>,
val tenantId: UUID?
)
data class Role(
val id: UUID,
val name: String,
val permissions: Set<Permission>
)
data class Permission(
val id: UUID,
val name: String,
val resource: String,
val action: String
)
sealed interface Credentials {
data class Basic(val username: String, val password: String) : Credentials
data class Token(val token: String) : Credentials
}

File: ./src/main/kotlin/org/blackerp/config/WebConfig.kt
-------------------------------------------
package org.blackerp.config
import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.CorsRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer
@Configuration
class WebConfig : WebMvcConfigurer {
override fun addCorsMappings(registry: CorsRegistry) {
registry.addMapping("/api/**")
.allowedOrigins("http://localhost:5173") // Vite default port
.allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
.allowedHeaders("*")
}
}

File: ./src/main/kotlin/org/blackerp/config/EventConfig.kt
-------------------------------------------
package org.blackerp.config
import org.blackerp.infrastructure.event.DefaultEventPublisher
import org.blackerp.infrastructure.event.EventPublisher
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Profile
@Configuration
@Profile("!test")
class EventConfig {
@Bean
fun eventPublisher(): EventPublisher = DefaultEventPublisher()
}

File: ./src/main/kotlin/org/blackerp/api/mappers/TableMapper.kt
-------------------------------------------
// File: src/main/kotlin/org/blackerp/api/mappers/TableMapper.kt
package org.blackerp.api.mappers
import org.springframework.stereotype.Component
import org.blackerp.api.dto.request.CreateTableRequest
import org.blackerp.api.dto.request.CreateColumnRequest
import org.blackerp.api.dto.response.TableResponse
import org.blackerp.application.table.CreateTableCommand
import org.blackerp.application.table.CreateColumnCommand
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.values.AccessLevel
import org.blackerp.domain.values.DataType
@Component
class TableMapper {
fun toCommand(request: CreateTableRequest): CreateTableCommand =
CreateTableCommand(
name = request.name,
displayName = request.displayName,
description = request.description,
accessLevel = AccessLevel.valueOf(request.accessLevel.uppercase()),
createdBy = "system",
columns = request.columns.map { toColumnCommand(it) }
)
private fun toColumnCommand(request: CreateColumnRequest): CreateColumnCommand =
CreateColumnCommand(
name = request.name,
displayName = request.displayName,
description = request.description,
dataType = DataType.valueOf(request.dataType.uppercase()),
length = request.length,
precision = request.precision,
scale = request.scale
)
fun toResponse(table: ADTable): TableResponse =
TableResponse(
id = table.metadata.id,
name = table.name.value,
displayName = table.displayName.value,
description = table.description?.value,
accessLevel = table.accessLevel.name
)
}

File: ./src/main/kotlin/org/blackerp/api/dto/request/CreateTableRequest.kt
-------------------------------------------
package org.blackerp.api.dto.request
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size
import jakarta.validation.Valid
import jakarta.validation.constraints.NotEmpty
data class CreateTableRequest(
@field:NotBlank
@field:Pattern(regexp = "^[a-z][a-z0-9_]*$")
@field:Size(min = 1, max = 60)
val name: String,
@field:NotBlank
@field:Size(min = 1, max = 60)
val displayName: String,
val description: String?,
@field:NotBlank
val accessLevel: String,
@field:Valid
@field:NotEmpty
val columns: List<CreateColumnRequest>
)
data class CreateColumnRequest(
@field:NotBlank
@field:Pattern(regexp = "^[a-z][a-z0-9_]*$")
val name: String,
@field:NotBlank
val displayName: String,
val description: String?,
@field:NotBlank
val dataType: String,
val length: Int?,
val precision: Int?,
val scale: Int?
)

File: ./src/main/kotlin/org/blackerp/api/dto/response/TableResponses.kt
-------------------------------------------
package org.blackerp.api.dto.response
import java.util.UUID
data class TableResponse(
val id: UUID,
val name: String,
val displayName: String,
val description: String?,
val accessLevel: String
)
data class TablesResponse(
val tables: List<TableResponse>
)

File: ./src/main/kotlin/org/blackerp/api/error/ErrorHandler.kt
-------------------------------------------
package org.blackerp.api.error
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.blackerp.domain.DomainException
import org.blackerp.domain.table.TableError
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.http.HttpStatus
@ControllerAdvice
class ErrorHandler {
@ExceptionHandler(DomainException::class)
fun handleDomainException(ex: DomainException): ResponseEntity<ErrorResponse> =
when(ex) {
is TableError.ValidationFailed -> ResponseEntity.badRequest()
.body(ErrorResponse("Validation failed", ex.errors.map { it.message }))
is TableError.NotFound -> ResponseEntity.notFound()
.build()
else -> ResponseEntity.internalServerError()
.body(ErrorResponse("Internal error", listOf(ex.message ?: ex.toString())))
}
@ExceptionHandler(MethodArgumentNotValidException::class)
fun handleValidationExceptions(ex: MethodArgumentNotValidException): ResponseEntity<ErrorResponse> =
ResponseEntity.badRequest().body(
ErrorResponse(
message = "Validation failed",
details = ex.bindingResult.fieldErrors.map {
"${it.field}: ${it.defaultMessage}"
}
)
)
}
data class ErrorResponse(
val message: String,
val details: List<String>
)

File: ./src/main/kotlin/org/blackerp/api/controllers/TableController.kt
-------------------------------------------
// File: src/main/kotlin/org/blackerp/api/controllers/TableController.kt
package org.blackerp.api.controllers
import org.springframework.web.bind.annotation.*
import org.springframework.http.ResponseEntity
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.domain.table.TableOperations
import org.blackerp.api.dto.response.TableResponse
import org.blackerp.api.dto.response.TablesResponse
import org.blackerp.api.dto.request.CreateTableRequest
import org.blackerp.api.mappers.TableMapper
import jakarta.validation.Valid
import org.slf4j.LoggerFactory
@RestController
@RequestMapping("/api/tables")
class TableController(
private val tableOperations: TableOperations,
private val createTableUseCase: CreateTableUseCase,
private val tableMapper: TableMapper
) {
private val logger = LoggerFactory.getLogger(TableController::class.java)
@GetMapping
suspend fun getTables(): ResponseEntity<TablesResponse> {
logger.debug("Fetching all tables")
return tableOperations.findAll().fold(
{ error ->
logger.error("Error fetching tables: $error")
ResponseEntity.internalServerError().build()
},
{ tables ->
ResponseEntity.ok(
TablesResponse(
tables = tables.map { tableMapper.toResponse(it) }
)
)
}
)
}
@PostMapping
suspend fun createTable(@Valid @RequestBody request: CreateTableRequest): ResponseEntity<TableResponse> {
logger.debug("Creating table: ${request.name}")
val command = tableMapper.toCommand(request)
return createTableUseCase.execute(command).fold(
{ error ->
logger.error("Error creating table: $error")
ResponseEntity.badRequest().build()
},
{ table ->
ResponseEntity.ok(tableMapper.toResponse(table))
}
)
}
}

File: ./src/main/kotlin/org/blackerp/application/table/CreateTableUseCase.kt
-------------------------------------------
// File: src/main/kotlin/org/blackerp/application/table/CreateTableUseCase.kt
package org.blackerp.application.table
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.CreateTableParams
import org.blackerp.domain.table.CreateColumnParams
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.TableOperations
import org.blackerp.domain.values.*
import org.blackerp.domain.event.DomainEvent
import org.blackerp.domain.event.TableCreated
import org.blackerp.domain.event.EventMetadata
import org.blackerp.infrastructure.event.EventPublisher
import org.blackerp.shared.ValidationError
import java.time.Instant
import java.util.UUID
import org.springframework.stereotype.Service
@Service
class CreateTableUseCase(
private val operations: TableOperations,
private val eventPublisher: EventPublisher
) {
suspend fun execute(command: CreateTableCommand): Either<TableError, ADTable> {
val errors = mutableListOf<ValidationError>()
val name = TableName.create(command.name).fold(
{ errors.add(it); null },
{ it }
)
val displayName = DisplayName.create(command.displayName).fold(
{ errors.add(it); null },
{ it }
)
val description = command.description?.let { desc ->
Description.create(desc).fold(
{ errors.add(it); null },
{ it }
)
}
// If name or displayName is null, return validation errors immediately
if (name == null || displayName == null) {
return TableError.ValidationFailed(errors).left()
}
val metadata = EntityMetadata(
createdBy = command.createdBy,
updatedBy = command.createdBy
)
val columns = command.columns.mapNotNull { columnCommand ->
ColumnDefinition.create(
CreateColumnParams(
metadata = metadata,
name = ColumnName.create(columnCommand.name).getOrNull()!!,
displayName = DisplayName.create(columnCommand.displayName).getOrNull()!!,
description = columnCommand.description?.let { Description.create(it).getOrNull() },
dataType = columnCommand.dataType,
length = columnCommand.length?.let { Length.create(it).getOrNull() },
precision = columnCommand.precision?.let { Precision.create(it).getOrNull() },
scale = columnCommand.scale?.let { Scale.create(it).getOrNull() }
)
).getOrNull()
}
if (errors.isNotEmpty()) {
return TableError.ValidationFailed(errors).left()
}
val createResult: Either<TableError, ADTable> = ADTable.create(
CreateTableParams(
metadata = metadata,
name = name,
displayName = displayName,
description = description,
accessLevel = command.accessLevel,
columns = columns
)
)
return when (createResult) {
is Either.Left -> createResult
is Either.Right -> {
val savedTable: Either<TableError, ADTable> = operations.save(createResult.value)
when (savedTable) {
is Either.Right -> {
val event: DomainEvent = TableCreated(
metadata = EventMetadata(
id = UUID.randomUUID(),
timestamp = Instant.now(),
user = savedTable.value.metadata.createdBy
),
tableId = savedTable.value.metadata.id,
tableName = savedTable.value.name.value
)
eventPublisher.publish(event)
}
is Either.Left -> Unit
}
savedTable
}
}
}
}

File: ./src/main/kotlin/org/blackerp/application/table/CreateTableCommand.kt
-------------------------------------------
package org.blackerp.application.table
import org.blackerp.domain.values.AccessLevel
import org.blackerp.domain.values.DataType
// CreateTableCommand with added columns property
data class CreateTableCommand(
val name: String,
val displayName: String,
val description: String?,
val accessLevel: AccessLevel,
val createdBy: String,
val columns: List<CreateColumnCommand>
)
data class CreateColumnCommand(
val name: String,
val dataType: DataType,
val length: Int?,
val precision: Int?,
val displayName: String,
val description: String?,
val scale: Int?
)

File: ./src/main/kotlin/org/blackerp/shared/ValidationError.kt
-------------------------------------------
// File: src/main/kotlin/org/blackerp/shared/ValidationError.kt
package org.blackerp.shared
sealed class ValidationError(val message: String) {
data class InvalidFormat(val details: String) : ValidationError(details)
data class Required(val field: String) : ValidationError("Field $field is required")
data class InvalidLength(val field: String, val min: Int, val max: Int) :
ValidationError("Field $field must be between $min and $max characters")
data class InvalidValue(val details: String) : ValidationError(details)
}

File: ./src/main/kotlin/org/blackerp/shared/TimeBasedId.kt
-------------------------------------------
package org.blackerp.shared
import com.fasterxml.uuid.Generators
import java.util.UUID
object TimeBasedId {
private val timeBasedGenerator = Generators.timeBasedGenerator()
fun generate(): UUID = timeBasedGenerator.generate()
}

File: ./src/main/kotlin/org/blackerp/shared/ReferenceValidation.kt
-------------------------------------------
package org.blackerp.shared
sealed interface ReferenceValidation {
data class ColumnNotFound(val columnName: String) : ValidationError("Column not found: $columnName")
data class ReferenceTableNotFound(val tableName: String) : ValidationError("Reference table not found: $tableName")
data class ReferenceColumnNotFound(
val tableName: String,
val columnName: String
) : ValidationError("Column $columnName not found in table $tableName")
data class IncompatibleTypes(
val sourceColumn: String,
val sourceType: String,
val targetColumn: String,
val targetType: String
) : ValidationError("Incompatible types: $sourceColumn ($sourceType) cannot reference $targetColumn ($targetType)")
}

File: ./src/test/resources/application.yml
-------------------------------------------
spring:
datasource:
url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
username: sa
password:
driver-class-name: org.h2.Driver
jpa:
database-platform: org.hibernate.dialect.H2Dialect
hibernate:
ddl-auto: none
show-sql: true
properties:
hibernate:
format_sql: true
flyway:
enabled: false
locations: classpath:db/migration
baseline-on-migrate: true
h2:
console:
enabled: true
path: /h2-console
logging:
level:
org.springframework: INFO
org.blackerp: DEBUG
org.hibernate.SQL: DEBUG
org.hibernate.type.descriptor.sql: TRACE

File: ./src/test/resources/application-test.yml
-------------------------------------------
spring:
datasource:
url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
username: sa
password:
driver-class-name: org.h2.Driver
jpa:
database-platform: org.hibernate.dialect.H2Dialect
hibernate:
ddl-auto: none
show-sql: true
properties:
hibernate:
format_sql: true
flyway:
enabled: false
locations: classpath:db/migration
baseline-on-migrate: true
h2:
console:
enabled: true
path: /h2-console
logging:
level:
org.springframework: INFO
org.blackerp: DEBUG
org.hibernate.SQL: DEBUG
org.hibernate.type.descriptor.sql: TRACE
profiles:
active: test

File: ./src/test/resources/db/migration/V4__create_test_tables.sql
-------------------------------------------
CREATE TABLE IF NOT EXISTS ad_table (
id VARCHAR(36) PRIMARY KEY,
name VARCHAR(60) NOT NULL,
display_name VARCHAR(60) NOT NULL,
created_by VARCHAR(60) NOT NULL,
created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
CONSTRAINT uk_ad_table_name UNIQUE (name)
);

File: ./src/test/resources/db/h2-schema.sql
-------------------------------------------
-- Drop existing tables if they exist
DROP TABLE IF EXISTS ad_tab_order_by;
DROP TABLE IF EXISTS ad_tab_display_column;
DROP TABLE IF EXISTS ad_tab_query_column;
DROP TABLE IF EXISTS ad_tab;
DROP TABLE IF EXISTS ad_table_relationship;
DROP TABLE IF EXISTS ad_table;
-- Create ad_table with H2-compatible syntax
CREATE TABLE ad_table (
id UUID PRIMARY KEY,
name VARCHAR(100) NOT NULL,
display_name VARCHAR(100) NOT NULL,
description TEXT,
access_level VARCHAR(50) NOT NULL,
created TIMESTAMP NOT NULL,
created_by VARCHAR(100) NOT NULL,
updated TIMESTAMP NOT NULL,
updated_by VARCHAR(100) NOT NULL,
version INTEGER NOT NULL DEFAULT 0,
active BOOLEAN NOT NULL DEFAULT true,
CONSTRAINT uk_table_name UNIQUE (name)
);
-- Use REGEXP_LIKE for H2 name format check
ALTER TABLE ad_table ADD CONSTRAINT chk_table_name
CHECK (REGEXP_LIKE(name, '^[a-z][a-z0-9_]*$'));
-- Create relationship table
CREATE TABLE ad_table_relationship (
id UUID PRIMARY KEY,
name VARCHAR(100) NOT NULL,
source_table VARCHAR(100) NOT NULL,
target_table VARCHAR(100) NOT NULL,
type VARCHAR(20) NOT NULL,
source_column VARCHAR(100) NOT NULL,
target_column VARCHAR(100) NOT NULL,
delete_rule VARCHAR(20) NOT NULL,
update_rule VARCHAR(20) NOT NULL,
junction_table VARCHAR(100),
created TIMESTAMP NOT NULL,
created_by VARCHAR(100) NOT NULL,
updated TIMESTAMP NOT NULL,
updated_by VARCHAR(100) NOT NULL,
version INTEGER NOT NULL DEFAULT 0,
active BOOLEAN NOT NULL DEFAULT true,
CONSTRAINT uk_relationship_name UNIQUE (name),
CONSTRAINT fk_source_table FOREIGN KEY (source_table) REFERENCES ad_table(name),
CONSTRAINT fk_target_table FOREIGN KEY (target_table) REFERENCES ad_table(name),
CONSTRAINT fk_junction_table FOREIGN KEY (junction_table) REFERENCES ad_table(name),
CONSTRAINT chk_relationship_type CHECK (type IN ('ONE_TO_ONE', 'ONE_TO_MANY', 'MANY_TO_MANY')),
CONSTRAINT chk_delete_rule CHECK (delete_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION')),
CONSTRAINT chk_update_rule CHECK (update_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION'))
);
-- Create tab and related tables
CREATE TABLE ad_tab (
id UUID PRIMARY KEY,
name VARCHAR(100) NOT NULL,
display_name VARCHAR(100) NOT NULL,
description TEXT,
table_name VARCHAR(100) NOT NULL,
created TIMESTAMP NOT NULL,
created_by VARCHAR(100) NOT NULL,
updated TIMESTAMP NOT NULL,
updated_by VARCHAR(100) NOT NULL,
version INTEGER NOT NULL DEFAULT 0,
active BOOLEAN NOT NULL DEFAULT true,
CONSTRAINT uk_tab_name UNIQUE (name),
CONSTRAINT fk_tab_table FOREIGN KEY (table_name) REFERENCES ad_table(name)
);
CREATE TABLE ad_tab_query_column (
tab_id UUID NOT NULL,
column_name VARCHAR(100) NOT NULL,
sequence INTEGER NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE
);
CREATE TABLE ad_tab_display_column (
tab_id UUID NOT NULL,
column_name VARCHAR(100) NOT NULL,
sequence INTEGER NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE
);
CREATE TABLE ad_tab_order_by (
tab_id UUID NOT NULL,
column_name VARCHAR(100) NOT NULL,
direction VARCHAR(4) NOT NULL,
sequence INTEGER NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE,
CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);
-- Create indexes for better performance
CREATE INDEX idx_table_name ON ad_table(name);
CREATE INDEX idx_table_active ON ad_table(active);
CREATE INDEX idx_relationship_source ON ad_table_relationship(source_table);
CREATE INDEX idx_relationship_target ON ad_table_relationship(target_table);
CREATE INDEX idx_relationship_active ON ad_table_relationship(active);
CREATE INDEX idx_tab_name ON ad_tab(name);
CREATE INDEX idx_tab_table ON ad_tab(table_name);

File: ./src/test/resources/db/schema.sql
-------------------------------------------
-- src/test/resources/db/schema.sql
-- Add after existing tables
CREATE TABLE IF NOT EXISTS ad_tab (
id UUID PRIMARY KEY,
name VARCHAR(60) NOT NULL CONSTRAINT uk_tab_name UNIQUE,
display_name VARCHAR(60) NOT NULL,
description VARCHAR(255),
table_name VARCHAR(60) NOT NULL,
created TIMESTAMP NOT NULL,
created_by VARCHAR(60) NOT NULL,
updated TIMESTAMP NOT NULL,
updated_by VARCHAR(60) NOT NULL,
version INT NOT NULL DEFAULT 0,
active BOOLEAN NOT NULL DEFAULT true,
CONSTRAINT fk_tab_table FOREIGN KEY (table_name)
REFERENCES ad_table(name)
);
CREATE TABLE IF NOT EXISTS ad_tab_query_column (
tab_id UUID NOT NULL,
column_name VARCHAR(60) NOT NULL,
sequence INT NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_query_tab FOREIGN KEY (tab_id)
REFERENCES ad_tab(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS ad_tab_display_column (
tab_id UUID NOT NULL,
column_name VARCHAR(60) NOT NULL,
sequence INT NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_display_tab FOREIGN KEY (tab_id)
REFERENCES ad_tab(id) ON DELETE CASCADE
);
CREATE TABLE IF NOT EXISTS ad_tab_order_by (
tab_id UUID NOT NULL,
column_name VARCHAR(60) NOT NULL,
direction VARCHAR(4) NOT NULL,
sequence INT NOT NULL,
PRIMARY KEY (tab_id, column_name),
CONSTRAINT fk_order_tab FOREIGN KEY (tab_id)
REFERENCES ad_tab(id) ON DELETE CASCADE,
CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);

File: ./src/test/kotlin/org/blackerp/infrastructure/cache/InMemoryCacheServiceTest.kt
-------------------------------------------
package org.blackerp.infrastructure.cache
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
import java.time.Duration
class InMemoryCacheServiceTest : DescribeSpec({
lateinit var cacheService: CacheService
beforeTest {
cacheService = InMemoryCacheService()
}
describe("InMemoryCacheService") {
it("should store and retrieve values") {
runTest {
cacheService.set("test", "value")
val result = cacheService.get<String>("test")
result.getOrNull() shouldBe "value"
}
}
it("should handle TTL") {
runTest {
cacheService.set("test", "value", Duration.ofMillis(1))
Thread.sleep(10)
val result = cacheService.get<String>("test")
result.getOrNull() shouldBe null
}
}
}
})

File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/TestDatabaseConfig.kt
-------------------------------------------
// File: src/test/kotlin/org/blackerp/infrastructure/persistence/TestDatabaseConfig.kt
package org.blackerp.infrastructure.persistence
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType
import org.springframework.context.annotation.Primary
import javax.sql.DataSource
@TestConfiguration
class TestDatabaseConfig {
@Bean
@Primary
fun dataSource(): DataSource =
EmbeddedDatabaseBuilder()
.setType(EmbeddedDatabaseType.H2)
.addScript("db/h2-schema.sql")
.build()
@Bean
fun jdbcTemplate(dataSource: DataSource): JdbcTemplate =
JdbcTemplate(dataSource)
}

File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/SimpleTest.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import org.blackerp.config.TestConfig
import org.springframework.jdbc.core.JdbcTemplate
import java.time.Instant
import java.util.UUID
class SimpleTest : DescribeSpec({
val jdbcTemplate = TestConfig().jdbcTemplate(TestConfig().dataSource())
beforeSpec {
// Create test table if it doesn't exist
jdbcTemplate.execute("""
CREATE TABLE IF NOT EXISTS ad_table (
id VARCHAR(36) PRIMARY KEY,
name VARCHAR(100) NOT NULL,
display_name VARCHAR(100) NOT NULL,
description VARCHAR(255),
access_level VARCHAR(50),
created TIMESTAMP NOT NULL,
created_by VARCHAR(100) NOT NULL,
updated TIMESTAMP,
updated_by VARCHAR(100),
version INTEGER DEFAULT 0,
active BOOLEAN DEFAULT true
)
""")
}
afterSpec {
jdbcTemplate.execute("DROP TABLE IF EXISTS ad_table")
}
describe("Database Operations") {
it("should verify database connection") {
val result = jdbcTemplate.queryForObject("SELECT 1", Int::class.java)
result shouldBe 1
}
it("should insert into ad_table") {
// given
val id = UUID.randomUUID()
val now = Instant.now()
// when
val insertCount = jdbcTemplate.update("""
INSERT INTO ad_table (
id, name, display_name, created, created_by
) VALUES (?, ?, ?, ?, ?)
""",
id,
"test_table",
"Test Table",
now,
"test-user"
)
// then
insertCount shouldBe 1
val result = jdbcTemplate.queryForMap(
"SELECT * FROM ad_table WHERE id = ?",
id
)
result["name"] shouldBe "test_table"
result["display_name"] shouldBe "Test Table"
}
}
})

File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryTabOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.ad.tab.*
import org.blackerp.domain.values.TableName
import org.blackerp.shared.ValidationError
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
class InMemoryTabOperations : TabOperations {
private val tabs = ConcurrentHashMap<UUID, ADTab>()
private val tabsByTable = ConcurrentHashMap<String, MutableSet<UUID>>()
override suspend fun save(tab: ADTab): Either<TabError, ADTab> =
Either.catch {
// Check for duplicate name
val existingTab = tabs.values.find {
it.name == tab.name && it.metadata.id != tab.metadata.id
}
if (existingTab != null) {
return TabError.DuplicateTab(tab.name.value).left()
}
tabs[tab.metadata.id] = tab
tabsByTable.computeIfAbsent(tab.table.name.value) { mutableSetOf() }
.add(tab.metadata.id)
tab
}.mapLeft { e ->
TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
}
override suspend fun findById(id: UUID): Either<TabError, ADTab?> =
Either.catch {
tabs[id]
}.mapLeft { e ->
TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
}
override suspend fun findByTable(tableName: TableName): Either<TabError, List<ADTab>> =
Either.catch {
tabsByTable[tableName.value]?.mapNotNull { tabs[it] } ?: emptyList()
}.mapLeft { e ->
TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
}
override suspend fun delete(id: UUID): Either<TabError, Unit> =
Either.catch {
tabs[id]?.let { tab ->
tabs.remove(id)
tabsByTable[tab.table.name.value]?.remove(id)
Unit
} ?: throw IllegalStateException("Tab not found: $id")
}.mapLeft { e ->
TabError.ValidationFailed(
listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
)
}
}

File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryRelationshipOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store
import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.table.TableError
import org.blackerp.domain.values.TableName
import org.blackerp.domain.table.relationship.TableRelationship
import org.blackerp.domain.table.relationship.RelationshipOperations
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
class InMemoryRelationshipOperations : RelationshipOperations {
private val relationships = ConcurrentHashMap<UUID, TableRelationship>()
private val relationshipsByTable = ConcurrentHashMap<String, MutableSet<UUID>>()
override suspend fun save(relationship: TableRelationship): Either<TableError, TableRelationship> =
Either.catch {
// Check for duplicate name
if (relationships.values.any {
it.name == relationship.name && it.metadata.id != relationship.metadata.id
}) {
return TableError.DuplicateTable(relationship.name.value).left()
}
relationships[relationship.metadata.id] = relationship
// Index by source table
relationshipsByTable.computeIfAbsent(relationship.sourceTable.value) {
mutableSetOf()
}.add(relationship.metadata.id)
// Index by target table
relationshipsByTable.computeIfAbsent(relationship.targetTable.value) {
mutableSetOf()
}.add(relationship.metadata.id)
relationship
}.mapLeft {
TableError.StorageError(it)
}
override suspend fun findById(id: UUID): Either<TableError, TableRelationship?> =
Either.catch {
relationships[id]
}.mapLeft {
TableError.StorageError(it)
}
override suspend fun findByTable(tableName: TableName): Either<TableError, List<TableRelationship>> =
Either.catch {
relationshipsByTable[tableName.value]?.mapNotNull {
relationships[it]
} ?: emptyList()
}.mapLeft {
TableError.StorageError(it)
}
override suspend fun delete(id: UUID): Either<TableError, Unit> =
Either.catch {
relationships[id]?.let { relationship ->
relationships.remove(id)
relationshipsByTable[relationship.sourceTable.value]?.remove(id)
relationshipsByTable[relationship.targetTable.value]?.remove(id)
Unit
} ?: return TableError.NotFound(id.toString()).left()
}.mapLeft {
TableError.StorageError(it)
}
}

File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryTableOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store
import arrow.core.left
import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.TableOperations
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap
class InMemoryTableOperations : TableOperations {
private val tables = ConcurrentHashMap<UUID, ADTable>()
private val nameIndex = ConcurrentHashMap<String, UUID>()
override suspend fun findAll(): Either<TableError, List<ADTable>> =
Either.catch {
tables.values.toList()
}.mapLeft {
TableError.StorageError(it)
}
override suspend fun save(table: ADTable): Either<TableError, ADTable> =
findByName(table.name.value).fold(
{ error -> error.left() },
{ existing ->
if (existing != null && existing.metadata.id != table.metadata.id) {
TableError.DuplicateTable(table.name.value).left()
} else {
tables[table.metadata.id] = table
nameIndex[table.name.value] = table.metadata.id
table.right()
}
}
)
override suspend fun findById(id: UUID): Either<TableError, ADTable?> =
Either.catch {
tables[id]
}.mapLeft {
TableError.StorageError(it)
}
override suspend fun findByName(name: String): Either<TableError, ADTable?> =
Either.catch {
nameIndex[name]?.let { tables[it] }
}.mapLeft {
TableError.StorageError(it)
}
override suspend fun delete(id: UUID): Either<TableError, Unit> =
Either.catch {
tables[id]?.let { table ->
nameIndex.remove(table.name.value)
tables.remove(id)
}
Unit
}.mapLeft {
TableError.StorageError(it)
}
}

File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTabOperationsTest.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.ad.tab.*
import org.blackerp.domain.ad.tab.value.TabName
import org.blackerp.domain.table.TableOperations
import org.blackerp.domain.values.*
import org.blackerp.shared.TestFactory
import org.blackerp.config.UnifiedTestConfig
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.jdbc.core.JdbcTemplate
import org.slf4j.LoggerFactory
import java.util.UUID
@SpringBootTest(classes = [UnifiedTestConfig::class])
@ActiveProfiles("test")
class PostgresTabOperationsTest(
private val jdbcTemplate: JdbcTemplate,
private val tableOperations: TableOperations
) : DescribeSpec({
val logger = LoggerFactory.getLogger(PostgresTabOperationsTest::class.java)
lateinit var tabOperations: PostgresTabOperations
beforeTest {
tabOperations = PostgresTabOperations(jdbcTemplate, tableOperations)
// Clean up test data
listOf(
"DELETE FROM ad_tab_query_column",
"DELETE FROM ad_tab_display_column",
"DELETE FROM ad_tab_order_by",
"DELETE FROM ad_tab",
"DELETE FROM ad_table"
).forEach { sql ->
try {
jdbcTemplate.execute(sql)
} catch (e: Exception) {
logger.warn("Failed to execute cleanup SQL: $sql", e)
}
}
}
describe("PostgresTabOperations") {
context("save") {
it("should save tab with all related data") {
runTest {
// Create and save the table first
val table = TestFactory.createTestTable()
logger.debug("Created test table: ${table.name.value}")
val savedTableResult = tableOperations.save(table)
savedTableResult.shouldBeRight()
logger.debug("Saved test table successfully")
// Verify the table exists
val tableCount = jdbcTemplate.queryForObject(
"SELECT COUNT(*) FROM ad_table WHERE name = ?",
Int::class.java,
table.name.value
)
tableCount shouldBe 1
logger.debug("Verified table exists in database")
// Create the tab
val columnName = table.columns.first().name
val tab = ADTab(
metadata = TestFactory.createMetadata(),
name = TabName.create("test_tab").getOrNull()!!,
displayName = DisplayName.create("Test Tab").getOrNull()!!,
description = Description.create("Test Description").getOrNull(),
table = table,
queryColumns = listOf(columnName),
displayColumns = listOf(columnName),
orderBy = listOf(
OrderBySpec(columnName, SortDirection.ASC)
)
)
logger.debug("Created test tab object")
// Save the tab
val saveResult = tabOperations.save(tab)
logger.debug("Save result: $saveResult")
saveResult.shouldBeRight().also { savedTab ->
logger.debug("Verifying saved tab...")
savedTab.name.value shouldBe "test_tab"
savedTab.queryColumns.size shouldBe 1
savedTab.queryColumns.first().value shouldBe columnName.value
savedTab.displayColumns.size shouldBe 1
savedTab.displayColumns.first().value shouldBe columnName.value
savedTab.orderBy.size shouldBe 1
savedTab.orderBy.first().column.value shouldBe columnName.value
}
// Verify in database
val tabCount = jdbcTemplate.queryForObject(
"SELECT COUNT(*) FROM ad_tab WHERE name = ?",
Int::class.java,
"test_tab"
)
tabCount shouldBe 1
logger.debug("Verified tab exists in database")
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/plugin/TestPlugin.kt
-------------------------------------------
// Classpath: src/test/kotlin/org/blackerp/plugin/TestPlugin.kt
package org.blackerp.plugin
import arrow.core.Either
import arrow.core.right
class TestPlugin(
override val metadata: PluginMetadata,
private val extensions: List<Extension> = emptyList()
) : Plugin {
var initialized = false
var shutdown = false
override suspend fun initialize(): Either<PluginError, Unit> {
initialized = true
return Unit.right()
}
override suspend fun registerExtensions(registry: ExtensionRegistry): Either<PluginError, Unit> {
extensions.forEach { extension ->
registry.register(extension)
}
return Unit.right()
}
override suspend fun shutdown(): Either<PluginError, Unit> {
shutdown = true
return Unit.right()
}
}

File: ./src/test/kotlin/org/blackerp/plugin/discovery/FileSystemPluginDiscoveryTest.kt
-------------------------------------------
package org.blackerp.plugin.discovery
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
import java.nio.file.Files
import kotlin.io.path.createTempDirectory
import kotlin.io.path.writeText
class FileSystemPluginDiscoveryTest : DescribeSpec({
describe("FileSystemPluginDiscovery") {
val discovery = FileSystemPluginDiscovery()
it("should discover jar files") {
runTest {
val tempDir = createTempDirectory()
val jarFile = tempDir.resolve("test.jar")
jarFile.writeText("dummy jar content")
val result = discovery.discoverPlugins(tempDir)
result.isRight() shouldBe true
Files.deleteIfExists(jarFile)
Files.deleteIfExists(tempDir)
}
}
}
})

File: ./src/test/kotlin/org/blackerp/plugin/InMemoryExtensionRegistry.kt
-------------------------------------------
// Classpath: src/test/kotlin/org/blackerp/plugin/InMemoryExtensionRegistry.kt
package org.blackerp.plugin
import arrow.core.Either
import arrow.core.right
import java.util.concurrent.ConcurrentHashMap
class InMemoryExtensionRegistry : ExtensionRegistry {
private val extensions = ConcurrentHashMap<Class<*>, MutableList<Extension>>()
override suspend fun <T : Extension> register(extension: T): Either<PluginError, Unit> {
extensions.computeIfAbsent(extension::class.java) { mutableListOf() }
.add(extension)
return Unit.right()
}
@Suppress("UNCHECKED_CAST")
override fun <T : Extension> getExtensions(type: Class<T>): List<T> =
extensions[type]?.map { it as T } ?: emptyList()
}

File: ./src/test/kotlin/org/blackerp/plugin/PluginIdTest.kt
-------------------------------------------
package org.blackerp.plugin
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError
class PluginIdTest : DescribeSpec({
describe("PluginId") {
describe("create") {
it("should create valid plugin id") {
val result = PluginId.create("valid-plugin")
result.shouldBeRight().also { id ->
id.value shouldBe "valid-plugin"
}
}
it("should reject invalid format") {
val invalidFormats = listOf(
"Invalid Plugin",  // Contains spaces
"1invalid",        // Starts with number
"INVALID",         // Contains uppercase
"invalid!plugin"   // Contains special characters
)
invalidFormats.forEach { invalid ->
val result = PluginId.create(invalid)
result.shouldBeLeft().also { error ->
error shouldBe ValidationError.InvalidFormat(
"Plugin ID must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"
)
}
}
}
it("should enforce length constraints") {
// Too short
PluginId.create("ab").shouldBeLeft().also { error ->
error shouldBe ValidationError.InvalidLength("plugin id", 3, 50)
}
// Too long
PluginId.create("a".repeat(51)).shouldBeLeft().also { error ->
error shouldBe ValidationError.InvalidLength("plugin id", 3, 50)
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/plugin/VersionTest.kt
-------------------------------------------
package org.blackerp.plugin
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError
class VersionTest : DescribeSpec({
describe("Version") {
describe("create") {
it("should create valid version") {
val result = Version.create("1.2.3")
result.shouldBeRight().also { version ->
version.major shouldBe 1
version.minor shouldBe 2
version.patch shouldBe 3
}
}
it("should reject invalid format") {
val testCases = listOf(
"1" to "Version must be in format major.minor.patch",
"1.2" to "Version must be in format major.minor.patch",
"1.2.3.4" to "Version must be in format major.minor.patch",
"a.b.c" to "Version must be in format major.minor.patch",
"1.2.x" to "Version must be in format major.minor.patch",
".1.2" to "Version must be in format major.minor.patch"
)
testCases.forEach { (input, expectedMessage) ->
Version.create(input).shouldBeLeft().also { error ->
error shouldBe ValidationError.InvalidFormat(expectedMessage)
}
}
}
}
describe("comparison") {
it("should compare versions correctly") {
val v1 = Version.create("1.0.0").getOrNull()!!
val v2 = Version.create("2.0.0").getOrNull()!!
val v3 = Version.create("2.1.0").getOrNull()!!
val v4 = Version.create("2.1.1").getOrNull()!!
(v1 < v2) shouldBe true
(v2 < v3) shouldBe true
(v3 < v4) shouldBe true
(v4 > v1) shouldBe true
}
it("should handle equal versions") {
val v1 = Version.create("1.0.0").getOrNull()!!
val v2 = Version.create("1.0.0").getOrNull()!!
(v1 == v2) shouldBe true
(v1 >= v2) shouldBe true
(v1 <= v2) shouldBe true
}
}
}
})

File: ./src/test/kotlin/org/blackerp/plugin/PluginTest.kt
-------------------------------------------
// Classpath: src/test/kotlin/org/blackerp/plugin/PluginTest.kt
package org.blackerp.plugin
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
class PluginTest : DescribeSpec({
describe("Plugin") {
val validId = PluginId.create("test-plugin").getOrNull()!!
val validVersion = Version.create("1.0.0").getOrNull()!!
val validMetadata = PluginMetadata.create(
id = validId,
version = validVersion,
name = "Test Plugin",
description = "A test plugin",
vendor = "Test Vendor"
).getOrNull()!!
lateinit var plugin: TestPlugin
beforeTest {
plugin = TestPlugin(validMetadata)
}
describe("lifecycle") {
it("should handle initialization") {
runTest {
val result = plugin.initialize()
result.isRight() shouldBe true
plugin.initialized shouldBe true
}
}
it("should handle shutdown") {
runTest {
val result = plugin.shutdown()
result.isRight() shouldBe true
plugin.shutdown shouldBe true
}
}
}
describe("extension registration") {
it("should register extensions") {
runTest {
val registry = InMemoryExtensionRegistry()
val result = plugin.registerExtensions(registry)
result.isRight() shouldBe true
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/plugin/PluginMetadataTest.kt
-------------------------------------------
package org.blackerp.plugin
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError
class PluginMetadataTest : DescribeSpec({
describe("PluginMetadata") {
describe("create") {
val validId = PluginId.create("test-plugin").getOrNull()!!
val validVersion = Version.create("1.0.0").getOrNull()!!
it("should create valid metadata") {
val result = PluginMetadata.create(
id = validId,
version = validVersion,
name = "Test Plugin",
description = "A test plugin",
vendor = "Test Vendor"
)
result.shouldBeRight().also { metadata ->
metadata.id shouldBe validId
metadata.version shouldBe validVersion
metadata.name shouldBe "Test Plugin"
metadata.description shouldBe "A test plugin"
metadata.vendor shouldBe "Test Vendor"
}
}
it("should validate name") {
val result = PluginMetadata.create(
id = validId,
version = validVersion,
name = "",
description = "A test plugin",
vendor = "Test Vendor"
)
result.shouldBeLeft().also { error ->
error shouldBe ValidationError.Required("name")
}
}
it("should validate description length") {
val result = PluginMetadata.create(
id = validId,
version = validVersion,
name = "Test Plugin",
description = "a".repeat(501),
vendor = "Test Vendor"
)
result.shouldBeLeft().also { error ->
error shouldBe ValidationError.InvalidLength("description", 0, 500)
}
}
it("should validate vendor") {
// Empty vendor
PluginMetadata.create(
id = validId,
version = validVersion,
name = "Test Plugin",
description = "A test plugin",
vendor = ""
).shouldBeLeft().also { error ->
error shouldBe ValidationError.Required("vendor")
}
// Too long vendor
PluginMetadata.create(
id = validId,
version = validVersion,
name = "Test Plugin",
description = "A test plugin",
vendor = "a".repeat(101)
).shouldBeLeft().also { error ->
error shouldBe ValidationError.InvalidLength("vendor", 3, 100)
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/plugin/registry/DefaultPluginRegistryTest.kt
-------------------------------------------
package org.blackerp.plugin.registry
import arrow.core.Either
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
import org.blackerp.plugin.*
class DefaultPluginRegistryTest : DescribeSpec({
describe("DefaultPluginRegistry") {
val registry = DefaultPluginRegistry()
val pluginId = PluginId.create("test-plugin").getOrNull()!!
val version = Version.create("1.0.0").getOrNull()!!
val metadata = PluginMetadata.create(
id = pluginId,
version = version,
name = "Test Plugin",
description = "Test plugin description",
vendor = "Test Vendor"
).getOrNull()!!
val plugin = TestPlugin(metadata)
it("should register plugin") {
runTest {
registry.register(plugin).isRight() shouldBe true
registry.getPlugins().size shouldBe 1
}
}
it("should prevent duplicate registration") {
runTest {
registry.register(plugin)
registry.register(plugin).isLeft() shouldBe true
}
}
it("should retrieve registered plugin") {
runTest {
registry.register(plugin)
registry.getPlugin(pluginId).isRight() shouldBe true
}
}
it("should unregister plugin") {
runTest {
registry.register(plugin)
registry.unregister(pluginId).isRight() shouldBe true
registry.getPlugins().isEmpty() shouldBe true
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/ad/window/value/WindowNameTest.kt
-------------------------------------------
package org.blackerp.domain.ad.window.value
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError
class WindowNameTest : DescribeSpec({
describe("WindowName") {
describe("create") {
it("should create valid window name") {
val result = WindowName.create("valid_window")
result.shouldBeRight()
}
it("should reject invalid format") {
val result = WindowName.create("Invalid Window")
result.shouldBeLeft()
}
it("should enforce length constraints") {
WindowName.create("ab").shouldBeLeft()
WindowName.create("a".repeat(51)).shouldBeLeft()
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/ad/tab/value/TabNameTest.kt
-------------------------------------------
package org.blackerp.domain.ad.tab.value
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError
class TabNameTest : DescribeSpec({
describe("TabName") {
describe("create") {
it("should create valid tab name") {
val result = TabName.create("valid_tab")
result.shouldBeRight()
}
it("should reject invalid format") {
val result = TabName.create("Invalid Tab")
result.shouldBeLeft()
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/ad/tab/ADTabTest.kt
-------------------------------------------
package org.blackerp.domain.ad.tab
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.domain.values.*
import org.blackerp.domain.ad.tab.value.TabName
import org.blackerp.shared.TestFactory
class ADTabTest : DescribeSpec({
describe("ADTab") {
it("should create valid tab") {
// given
val table = TestFactory.createTestTable()
val columnName = table.columns.first().name
val params = CreateTabParams(
metadata = TestFactory.createMetadata(),
name = TabName.create("test_tab").getOrNull()!!,
displayName = DisplayName.create("Test Tab").getOrNull()!!,
description = null,
table = table,
queryColumns = listOf(columnName),
displayColumns = listOf(columnName),
orderBy = listOf(
OrderBySpec(columnName, SortDirection.ASC)
)
)
// when
val result = ADTab.create(params)
// then
result.shouldBeRight()
}
it("should validate column existence") {
// given
val table = TestFactory.createTestTable()
val invalidColumnName = ColumnName.create("invalid_column").getOrNull()!!
val params = CreateTabParams(
metadata = TestFactory.createMetadata(),
name = TabName.create("test_tab").getOrNull()!!,
displayName = DisplayName.create("Test Tab").getOrNull()!!,
description = null,
table = table,
queryColumns = listOf(invalidColumnName),
displayColumns = emptyList(),
orderBy = emptyList()
)
// when
val result = ADTab.create(params)
// then
result.shouldBeLeft()
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/ad/ADModuleTest.kt
-------------------------------------------
package org.blackerp.domain.ad
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import org.blackerp.domain.ad.value.ModuleName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.plugin.Version
import org.blackerp.shared.TestFactory
class ADModuleTest : DescribeSpec({
describe("ADModule") {
describe("create") {
it("should create valid module") {
// Given
val name = ModuleName.create("test-module").getOrNull()!!
val displayName = DisplayName.create("Test Module").getOrNull()!!
val description = Description.create("Test Description").getOrNull()!!
val version = Version.create("1.0.0").getOrNull()!!
val params = CreateModuleParams(
metadata = TestFactory.createMetadata(),
name = name,
displayName = displayName,
description = description,
version = version
)
// When
val result = ADModule.create(params)
// Then
result.shouldBeRight().also { module ->
module.name shouldBe name
module.displayName shouldBe displayName
module.description shouldBe description
module.version shouldBe version
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/ad/value/ModuleNameTest.kt
-------------------------------------------
package org.blackerp.domain.ad.value
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError
class ModuleNameTest : DescribeSpec({
describe("ModuleName") {
describe("create") {
it("should create valid module name") {
val result = ModuleName.create("valid-module")
result.shouldBeRight().also { name ->
name.value shouldBe "valid-module"
}
}
it("should reject invalid format") {
val result = ModuleName.create("Invalid Module")
result.shouldBeLeft().also { error ->
error.message shouldBe "Module name must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"
}
}
it("should enforce length constraints") {
ModuleName.create("ab").shouldBeLeft().also { error ->
error shouldBe ValidationError.InvalidLength("module name", 3, 50)
}
ModuleName.create("a".repeat(51)).shouldBeLeft().also { error ->
error shouldBe ValidationError.InvalidLength("module name", 3, 50)
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/ad/reference/ADReferenceTest.kt
-------------------------------------------
package org.blackerp.domain.ad.reference
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeTypeOf
import io.kotest.assertions.arrow.core.shouldBeRight
import org.blackerp.domain.ad.reference.value.ReferenceName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.shared.TestFactory
class ADReferenceTest : DescribeSpec({
describe("ADReference") {
it("should create list reference") {
// given
val name = ReferenceName.create("test_reference").getOrNull()!!
val displayName = DisplayName.create("Test Reference").getOrNull()!!
val description = Description.create("Test reference description").getOrNull()
val params = CreateReferenceParams(
metadata = TestFactory.createMetadata(),
name = name,
displayName = displayName,
description = description,
type = ReferenceType.List
)
// when
val result = ADReference.create(params)
// then
result.shouldBeRight().also { reference ->
reference.name shouldBe name
reference.displayName shouldBe displayName
reference.description shouldBe description
reference.type shouldBe ReferenceType.List
}
}
it("should create table reference") {
// given
val name = ReferenceName.create("table_reference").getOrNull()!!
val displayName = DisplayName.create("Table Reference").getOrNull()!!
val params = CreateReferenceParams(
metadata = TestFactory.createMetadata(),
name = name,
displayName = displayName,
description = null,
type = ReferenceType.Table(
tableName = "test_table",
keyColumn = "id",
displayColumn = "name"
)
)
// when
val result = ADReference.create(params)
// then
result.shouldBeRight().also { reference ->
val tableRef = reference.type as ReferenceType.Table
tableRef.tableName shouldBe "test_table"
tableRef.keyColumn shouldBe "id"
tableRef.displayColumn shouldBe "name"
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/ad/reference/value/ReferenceNameTest.kt
-------------------------------------------
package org.blackerp.domain.ad.reference.value
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError
class ReferenceNameTest : DescribeSpec({
describe("ReferenceName") {
describe("create") {
it("should create valid reference name") {
val result = ReferenceName.create("valid_reference")
result.shouldBeRight()
}
it("should reject invalid format") {
val result = ReferenceName.create("Invalid Reference")
result.shouldBeLeft()
}
it("should enforce length constraints") {
ReferenceName.create("ab").shouldBeLeft()
ReferenceName.create("a".repeat(51)).shouldBeLeft()
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/error/DomainErrorTest.kt
-------------------------------------------
package org.blackerp.domain.error
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeTypeOf
class DomainErrorTest : DescribeSpec({
describe("DomainError") {
it("should create validation error") {
val error = DomainError.ValidationError("Invalid input", "field1")
error.shouldBeTypeOf<DomainError.ValidationError>()
error.message shouldBe "Invalid input"
error.field shouldBe "field1"
}
it("should create security error") {
val error = DomainError.SecurityError(
message = "Access denied",
reason = "Insufficient permissions"
)
error.shouldBeTypeOf<DomainError.SecurityError>()
error.message shouldBe "Access denied"
error.reason shouldBe "Insufficient permissions"
}
it("should create system error with cause") {
val cause = RuntimeException("Test exception")
val error = DomainError.SystemError("System failure", cause)
error.shouldBeTypeOf<DomainError.SystemError>()
error.message shouldBe "System failure"
error.cause shouldBe cause
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/tenant/TenantAwareTableTest.kt
-------------------------------------------
package org.blackerp.domain.tenant
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import org.blackerp.shared.TestFactory
import org.blackerp.domain.table.TenantAwareTable
import java.util.UUID
class TenantAwareTableTest : DescribeSpec({
describe("TenantAwareTable") {
it("should wrap ADTable with tenant ID") {
// given
val table = TestFactory.createTestTable()
val tenantId = UUID.randomUUID()
// when
val tenantAwareTable = TenantAwareTable.from(table, tenantId)
// then
tenantAwareTable.tenantId shouldBe tenantId
tenantAwareTable.metadata shouldBe table.metadata
tenantAwareTable.name.value shouldBe table.name.value
tenantAwareTable.displayName.value shouldBe table.displayName.value
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/tenant/TenantContextTest.kt
-------------------------------------------
package org.blackerp.domain.tenant
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import java.util.UUID
class TenantContextTest : DescribeSpec({
afterTest {
TenantContext.clear()
}
describe("TenantContext") {
it("should manage current tenant") {
// given
val tenantId = UUID.randomUUID()
// when
TenantContext.setCurrentTenant(tenantId)
// then
TenantContext.getCurrentTenant() shouldBe tenantId
}
it("should clear tenant context") {
// given
val tenantId = UUID.randomUUID()
TenantContext.setCurrentTenant(tenantId)
// when
TenantContext.clear()
// then
TenantContext.getCurrentTenant() shouldBe null
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/values/AmountTest.kt
-------------------------------------------
package org.blackerp.domain.values
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import java.math.BigDecimal
class AmountTest : DescribeSpec({
describe("Amount") {
describe("create") {
it("should create valid amount") {
val result = Amount.create(BigDecimal("100.00"))
result.shouldBeRight()
}
it("should reject negative amount") {
val result = Amount.create(BigDecimal("-100.00"))
result.shouldBeLeft()
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/values/DisplayNameTest.kt
-------------------------------------------
package org.blackerp.domain.values
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import arrow.core.Either
class DisplayNameTest : DescribeSpec({
describe("DisplayName") {
describe("create") {
it("should create valid display name") {
val result = DisplayName.create("Valid Display Name")
result.isRight() shouldBe true
}
it("should reject blank name") {
val result = DisplayName.create("   ")
result.isLeft() shouldBe true
}
it("should reject too long name") {
val result = DisplayName.create("a".repeat(61))
result.isLeft() shouldBe true
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/values/TableNameTest.kt
-------------------------------------------
package org.blackerp.domain.values
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import arrow.core.Either
class TableNameTest : DescribeSpec({
describe("TableName") {
describe("create") {
it("should create valid table name") {
val result = TableName.create("valid_table_name")
result.isRight() shouldBe true
}
it("should reject invalid format") {
val result = TableName.create("Invalid Table")
result.isLeft() shouldBe true
}
it("should reject name starting with number") {
val result = TableName.create("1invalid")
result.isLeft() shouldBe true
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/values/CurrencyTest.kt
-------------------------------------------
package org.blackerp.domain.values
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
class CurrencyTest : DescribeSpec({
describe("Currency") {
describe("create") {
it("should create valid currency code") {
val result = Currency.create("USD")
result.shouldBeRight()
}
it("should reject invalid format") {
val result = Currency.create("usd")
result.shouldBeLeft()
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/values/DataTypeTest.kt
-------------------------------------------
package org.blackerp.domain.values
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.throwables.shouldThrow
class DataTypeTest : DescribeSpec({
describe("DataType") {
describe("fromString") {
it("should create valid data type from string") {
DataType.fromString("STRING") shouldBe DataType.STRING
DataType.fromString("string") shouldBe DataType.STRING
}
it("should throw exception for invalid type") {
shouldThrow<IllegalArgumentException> {
DataType.fromString("INVALID_TYPE")
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/transaction/TransactionTest.kt
-------------------------------------------
package org.blackerp.domain.transaction
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import org.blackerp.domain.values.Amount
import org.blackerp.domain.values.Currency
import org.blackerp.shared.TestFactory
import java.math.BigDecimal
import java.time.Instant
class TransactionTest : DescribeSpec({
describe("Transaction") {
describe("create") {
it("should create valid transaction") {
val amount = Amount.create(BigDecimal("100.00")).getOrNull()!!
val currency = Currency.create("USD").getOrNull()!!
val params = CreateTransactionParams(
metadata = TestFactory.createMetadata(),
amount = amount,
currency = currency,
timestamp = Instant.now(),
description = "Test transaction"
)
val result = Transaction.create(params)
result.shouldBeRight()
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/query/QueryCriteriaTest.kt
-------------------------------------------
package org.blackerp.domain.query
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.should
import io.kotest.matchers.types.beInstanceOf
class QueryCriteriaTest : DescribeSpec({
describe("QueryCriteria") {
it("should create complex criteria") {
val criteria = QueryCriteria.And(
listOf(
QueryCriteria.Equals("name", "test"),
QueryCriteria.Or(
listOf(
QueryCriteria.Like("description", "%test%"),
QueryCriteria.In("status", listOf("active", "pending"))
)
)
)
)
criteria should beInstanceOf<QueryCriteria.And>()
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/extension/TableExtensionPointTest.kt
-------------------------------------------
package org.blackerp.domain.table.extension
import arrow.core.Either
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.table.ADTable
import org.blackerp.plugin.PluginId
class TableExtensionPointTest : DescribeSpec({
describe("TableExtension") {
val mockTable = mockk<ADTable>()
val mockPluginId = PluginId.create("test-plugin").getOrNull()!!
it("should implement extension interface") {
val extension = object : TableExtension {
override val pluginId = mockPluginId
override suspend fun beforeCreate(table: ADTable) = Either.Right(table)
override suspend fun afterCreate(table: ADTable) {}
override suspend fun beforeUpdate(table: ADTable) = Either.Right(table)
override suspend fun afterUpdate(table: ADTable) {}
override suspend fun beforeDelete(table: ADTable) = Either.Right(Unit)
override suspend fun afterDelete(table: ADTable) {}
}
runTest {
extension.beforeCreate(mockTable).isRight() shouldBe true
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/constraint/ReferenceConstraintTest.kt
-------------------------------------------
package org.blackerp.domain.table.constraint
import arrow.core.right
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeTypeOf
import io.mockk.coEvery
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.table.*
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.domain.values.*
import org.blackerp.shared.TestFactory
import org.blackerp.shared.ReferenceValidation
class ReferenceConstraintTest : DescribeSpec({
describe("validate") {
it("should fail when source column does not exist") {
runTest {
// given
val mockTableOps = mockk<TableOperations>()
val sourceTableDef = mockk<TableDefinition>()
val columnName = ColumnName.create("test_column").getOrNull()!!
val refTableName = TableName.create("ref_table").getOrNull()!!
val refColumnName = ColumnName.create("ref_column").getOrNull()!!
every { sourceTableDef.columns } returns emptyList()
val constraint = ReferenceConstraint(
metadata = TestFactory.createMetadata(),
column = columnName,
referenceTable = refTableName,
referenceColumn = refColumnName,
tableOperations = mockTableOps
)
// when
val result = constraint.validate(sourceTableDef)
// then
result.isLeft() shouldBe true
result.fold(
{ error -> error.shouldBeTypeOf<ReferenceValidation.ColumnNotFound>() },
{ throw AssertionError("Should not succeed") }
)
}
}
it("should fail when reference table not found") {
runTest {
// given
val mockTableOps = mockk<TableOperations>()
val sourceTableDef = mockk<TableDefinition>()
val columnName = ColumnName.create("test_column").getOrNull()!!
val refTableName = TableName.create("ref_table").getOrNull()!!
val refColumnName = ColumnName.create("ref_column").getOrNull()!!
// Set up source column to exist
val sourceColumn = mockk<ColumnDefinition>()
every { sourceColumn.name } returns columnName
every { sourceColumn.dataType } returns DataType.STRING
every { sourceTableDef.columns } returns listOf(sourceColumn)
// Set up reference table to not be found
coEvery { mockTableOps.findByName(refTableName.value) } returns null.right()
val constraint = ReferenceConstraint(
metadata = TestFactory.createMetadata(),
column = columnName,
referenceTable = refTableName,
referenceColumn = refColumnName,
tableOperations = mockTableOps
)
// when
val result = constraint.validate(sourceTableDef)
// then
result.isLeft() shouldBe true
result.fold(
{ error -> error.shouldBeTypeOf<ReferenceValidation.ReferenceTableNotFound>() },
{ throw AssertionError("Should not succeed") }
)
}
}
it("should fail when column types are incompatible") {
runTest {
// given
val mockTableOps = mockk<TableOperations>()
val sourceTableDef = mockk<TableDefinition>()
val columnName = ColumnName.create("test_column").getOrNull()!!
val refTableName = TableName.create("ref_table").getOrNull()!!
val refColumnName = ColumnName.create("ref_column").getOrNull()!!
// Source column with STRING type
val sourceColumn = mockk<ColumnDefinition>()
every { sourceColumn.name } returns columnName
every { sourceColumn.dataType } returns DataType.STRING
every { sourceTableDef.columns } returns listOf(sourceColumn)
// Reference table setup
val refTable = mockk<ADTable>()
val refColumn = mockk<ColumnDefinition>()
every { refColumn.name } returns refColumnName
every { refColumn.dataType } returns DataType.INTEGER // Intentionally incompatible type
every { refTable.columns } returns listOf(refColumn)
every { refTable.metadata } returns TestFactory.createMetadata()
every { refTable.name } returns refTableName
every { refTable.displayName } returns DisplayName.create("Reference Table").getOrNull()!!
every { refTable.description } returns null
every { refTable.accessLevel } returns AccessLevel.SYSTEM
// Set up TableOperations to return our mock table
coEvery { mockTableOps.findByName(refTableName.value) } returns refTable.right()
val constraint = ReferenceConstraint(
metadata = TestFactory.createMetadata(),
column = columnName,
referenceTable = refTableName,
referenceColumn = refColumnName,
tableOperations = mockTableOps
)
// when
val result = constraint.validate(sourceTableDef)
// then
result.isLeft() shouldBe true
result.fold(
{ error -> error.shouldBeTypeOf<ReferenceValidation.IncompatibleTypes>() },
{ throw AssertionError("Should not succeed") }
)
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/constraint/UniqueConstraintTest.kt
-------------------------------------------
package org.blackerp.domain.table.constraint
import arrow.core.right
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.domain.values.ColumnName
import org.blackerp.shared.TestFactory
import java.time.Instant  // Required by EntityMetadata
import java.util.UUID    // Required by EntityMetadata
class UniqueConstraintTest : DescribeSpec({
describe("UniqueConstraint") {
it("should validate when all columns exist") {
// given
val columnName = ColumnName.create("test_column").getOrNull()!!
val mockColumn = mockk<ColumnDefinition>()
every { mockColumn.name } returns columnName
val mockTable = mockk<TableDefinition>()
every { mockTable.columns } returns listOf(mockColumn)
val constraint = UniqueConstraint(
metadata = TestFactory.createMetadata(),
columns = listOf(columnName)
)
// when
val result = constraint.validate(mockTable)
// then
result.isRight() shouldBe true
}
it("should fail when columns dont exist") {
// given
val columnName = ColumnName.create("test_column").getOrNull()!!
val mockTable = mockk<TableDefinition>()
every { mockTable.columns } returns emptyList()
val constraint = UniqueConstraint(
metadata = TestFactory.createMetadata(),
columns = listOf(columnName)
)
// when
val result = constraint.validate(mockTable)
// then
result.isLeft() shouldBe true
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/constraint/NotNullConstraintTest.kt
-------------------------------------------
package org.blackerp.domain.table.constraint
import arrow.core.right
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.domain.values.ColumnName
import org.blackerp.shared.TestFactory
import java.time.Instant  // Required by EntityMetadata
import java.util.UUID    // Required by EntityMetadata
class NotNullConstraintTest : DescribeSpec({
describe("NotNullConstraint") {
it("should validate when column exists") {
// given
val columnName = ColumnName.create("test_column").getOrNull()!!
val mockColumn = mockk<ColumnDefinition>()
every { mockColumn.name } returns columnName
val mockTable = mockk<TableDefinition>()
every { mockTable.columns } returns listOf(mockColumn)
val constraint = NotNullConstraint(
metadata = TestFactory.createMetadata(),
column = columnName
)
// when
val result = constraint.validate(mockTable)
// then
result.isRight() shouldBe true
}
it("should fail when column doesnt exist") {
// given
val columnName = ColumnName.create("test_column").getOrNull()!!
val mockTable = mockk<TableDefinition>()
every { mockTable.columns } returns emptyList()
val constraint = NotNullConstraint(
metadata = TestFactory.createMetadata(),
column = columnName
)
// when
val result = constraint.validate(mockTable)
// then
result.isLeft() shouldBe true
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/definition/TableDefinitionTest.kt
-------------------------------------------
package org.blackerp.domain.table.definition
import arrow.core.right
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.mockk
import io.mockk.every
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.values.*
import org.blackerp.shared.TestFactory
import java.time.Instant
import java.util.UUID
class TableDefinitionTest : DescribeSpec({
describe("TableDefinition") {
describe("create") {
it("should create valid table definition") {
// given
val columnName = ColumnName.create("test_column").getOrNull()!!
val mockColumn = mockk<ColumnDefinition> {
// Configure the mock to return values when accessed
every { name } returns columnName
every { metadata } returns TestFactory.createMetadata()
// Add any other necessary properties that might be accessed
}
val params = CreateTableParams(
metadata = TestFactory.createMetadata(),
name = TestFactory.createValidTableName(),
displayName = TestFactory.createValidDisplayName(),
description = null,
accessLevel = AccessLevel.SYSTEM,
columns = listOf(mockColumn)
)
// when
val result = TableDefinition.create(params)
// then
result.isRight() shouldBe true
result.map { table ->
table.columns.size shouldBe 1
table.columns.first().name shouldBe columnName
}
}
it("should fail with no columns") {
// given
val params = CreateTableParams(
metadata = TestFactory.createMetadata(),
name = TestFactory.createValidTableName(),
displayName = TestFactory.createValidDisplayName(),
description = null,
accessLevel = AccessLevel.SYSTEM,
columns = emptyList()
)
// when
val result = TableDefinition.create(params)
// then
result.isLeft() shouldBe true
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/TableOperationsTest.kt
-------------------------------------------
// File: src/test/kotlin/org/blackerp/domain/table/TableOperationsTest.kt
package org.blackerp.domain.table
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.*
import org.blackerp.shared.TestFactory
import org.blackerp.infrastructure.persistence.store.InMemoryTableOperations
class TableOperationsTest : DescribeSpec({
lateinit var operations: InMemoryTableOperations
beforeTest {
operations = InMemoryTableOperations()
}
describe("TableOperations") {
context("saving and retrieving tables") {
it("should save and retrieve table") {
runTest {
// Create test table
val table = TestFactory.createTestTable()
// Save table
val savedResult = operations.save(table)
savedResult.isRight() shouldBe true
// Retrieve table
val retrievedResult = operations.findById(table.metadata.id)
retrievedResult.isRight() shouldBe true
val retrievedTable = retrievedResult.getOrNull()!!
retrievedTable.name.value shouldBe table.name.value
retrievedTable.displayName.value shouldBe table.displayName.value
retrievedTable.description?.value shouldBe table.description?.value
}
}
}
context("finding by name") {
it("should find table by name") {
runTest {
// Create and save test table
val table = TestFactory.createTestTable()
operations.save(table)
// Find by name
val foundResult = operations.findByName(table.name.value)
foundResult.isRight() shouldBe true
val foundTable = foundResult.getOrNull()!!
foundTable.metadata.id shouldBe table.metadata.id
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/relationship/TableRelationshipTest.kt
-------------------------------------------
package org.blackerp.domain.table.relationship
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.value.RelationType
import org.blackerp.domain.table.relationship.value.RelationshipName
import org.blackerp.shared.TestFactory
class TableRelationshipTest : DescribeSpec({
describe("TableRelationship") {
context("creation") {
it("should create valid relationship") {
// Create test parameters
val params = CreateRelationshipParams(
metadata = TestFactory.createMetadata(),
name = RelationshipName.create("test_relation").getOrNull()!!,
sourceTable = TableName.create("source_table").getOrNull()!!,
targetTable = TableName.create("target_table").getOrNull()!!,
type = RelationType.ONE_TO_MANY,
sourceColumn = ColumnName.create("source_id").getOrNull()!!,
targetColumn = ColumnName.create("target_id").getOrNull()!!
)
// Create relationship
val result = TableRelationship.create(params)
// Verify
result.isRight() shouldBe true
result.map { relationship ->
relationship.name.value shouldBe "test_relation"
relationship.type shouldBe RelationType.ONE_TO_MANY
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipOperationsTest.kt
-------------------------------------------
package org.blackerp.domain.table.relationship
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.collections.shouldNotBeEmpty
import io.kotest.matchers.types.shouldBeTypeOf
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.table.TableError
import org.blackerp.infrastructure.persistence.store.InMemoryRelationshipOperations
import org.slf4j.LoggerFactory
class RelationshipOperationsTest : DescribeSpec({
val logger = LoggerFactory.getLogger(RelationshipOperationsTest::class.java)
lateinit var operations: RelationshipOperations
beforeTest {
operations = InMemoryRelationshipOperations()
}
describe("RelationshipOperations") {
it("should save and retrieve relationship") {
runTest {
val relationship = RelationshipTestFactory.createValidRelationship()
logger.debug("Created test relationship: ${relationship.name.value}")
val saveResult = operations.save(relationship)
val findResult = operations.findById(relationship.metadata.id)
saveResult.shouldBeRight().also { saved ->
saved.metadata.id shouldBe relationship.metadata.id
saved.name shouldBe relationship.name
}
findResult.shouldBeRight().also { found ->
found shouldNotBe null
found?.metadata?.id shouldBe relationship.metadata.id
found?.name shouldBe relationship.name
}
}
}
it("should find relationships by table") {
runTest {
val relationship = RelationshipTestFactory.createValidRelationship()
operations.save(relationship).shouldBeRight()
val result = operations.findByTable(relationship.sourceTable)
result.shouldBeRight().also { relationships ->
relationships.shouldNotBeEmpty()
relationships.size shouldBe 1
val foundRelationship = relationships[0]
foundRelationship.shouldBeTypeOf<TableRelationship>()
foundRelationship.sourceTable.value shouldBe relationship.sourceTable.value
foundRelationship.metadata.id shouldBe relationship.metadata.id
}
}
}
it("should prevent duplicate relationship names") {
runTest {
val first = RelationshipTestFactory.createValidRelationship()
val second = RelationshipTestFactory.createValidRelationship()
operations.save(first).shouldBeRight()
operations.save(second).shouldBeLeft().also { error ->
error shouldBe TableError.DuplicateTable(second.name.value)
}
}
}
it("should delete relationship") {
runTest {
val relationship = RelationshipTestFactory.createValidRelationship()
operations.save(relationship).shouldBeRight()
operations.delete(relationship.metadata.id).shouldBeRight()
operations.findById(relationship.metadata.id).shouldBeRight() shouldBe null
}
}
}
})

File: ./src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipTestFactory.kt
-------------------------------------------
// File: src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipTestFactory.kt
package org.blackerp.domain.table.relationship
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.value.*
import org.blackerp.domain.table.relationship.constraint.IndexConstraint
import org.blackerp.shared.TestFactory
import org.blackerp.domain.table.relationship.value.DeleteRule
import org.blackerp.domain.table.relationship.value.UpdateRule
object RelationshipTestFactory {
fun createValidRelationship(): TableRelationship {
val metadata = TestFactory.createMetadata()
return TableRelationship(
metadata = metadata,
name = createValidRelationshipName(),
sourceTable = createValidTableName("source_table"),
targetTable = createValidTableName("target_table"),
type = RelationType.ONE_TO_MANY,
sourceColumn = createValidColumnName("source_id"),
targetColumn = createValidColumnName("target_id"),
constraints = listOf(createValidIndexConstraint("target_id")),
deleteRule = DeleteRule.RESTRICT,
updateRule = UpdateRule.RESTRICT
)
}
fun createValidRelationshipParams(): CreateRelationshipParams {
return CreateRelationshipParams(
metadata = TestFactory.createMetadata(),
name = createValidRelationshipName(),
sourceTable = createValidTableName("source_table"),
targetTable = createValidTableName("target_table"),
type = RelationType.ONE_TO_MANY,
sourceColumn = createValidColumnName("source_id"),
targetColumn = createValidColumnName("target_id"),
constraints = listOf(createValidIndexConstraint("target_id")),
deleteRule = DeleteRule.RESTRICT,
updateRule = UpdateRule.RESTRICT
)
}
private fun createValidRelationshipName(): RelationshipName =
RelationshipName.create("test_relation").getOrNull()
?: throw IllegalStateException("Failed to create valid relationship name")
private fun createValidTableName(name: String): TableName =
TableName.create(name).getOrNull()
?: throw IllegalStateException("Failed to create valid table name: $name")
private fun createValidColumnName(name: String): ColumnName =
ColumnName.create(name).getOrNull()
?: throw IllegalStateException("Failed to create valid column name: $name")
private fun createValidIndexConstraint(columnName: String): IndexConstraint {
val column = createValidColumnName(columnName)
return IndexConstraint(
metadata = TestFactory.createMetadata(),
columns = listOf(column)
)
}
fun createManyToManyParams(): CreateRelationshipParams {
return CreateRelationshipParams(
metadata = TestFactory.createMetadata(),
name = createValidRelationshipName(),
sourceTable = createValidTableName("table_a"),
targetTable = createValidTableName("table_b"),
type = RelationType.MANY_TO_MANY,
sourceColumn = createValidColumnName("a_id"),
targetColumn = createValidColumnName("b_id"),
junctionTable = createValidTableName("junction_table")
)
}
fun createSelfReferenceParams(): CreateRelationshipParams {
val tableName = createValidTableName("self_ref_table")
return CreateRelationshipParams(
metadata = TestFactory.createMetadata(),
name = createValidRelationshipName(),
sourceTable = tableName,
targetTable = tableName,
type = RelationType.ONE_TO_MANY,
sourceColumn = createValidColumnName("parent_id"),
targetColumn = createValidColumnName("child_id"),
constraints = listOf(createValidIndexConstraint("child_id"))
)
}
}

File: ./src/test/kotlin/org/blackerp/domain/EntityMetadataTest.kt
-------------------------------------------
package org.blackerp.domain
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
class EntityMetadataTest : DescribeSpec({
describe("EntityMetadata") {
it("should create with default values") {
val metadata = EntityMetadata(
createdBy = "test-user",
updatedBy = "test-user"
)
metadata.createdBy shouldBe "test-user"
metadata.updatedBy shouldBe "test-user"
metadata.version shouldBe 0
metadata.active shouldBe true
metadata.id shouldNotBe null
}
it("should create with custom values") {
val metadata = EntityMetadata(
createdBy = "test-user",
updatedBy = "test-user",
version = 1,
active = false
)
metadata.version shouldBe 1
metadata.active shouldBe false
}
}
})

File: ./src/test/kotlin/org/blackerp/config/UnifiedTestConfig.kt
-------------------------------------------
package org.blackerp.config
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType
import javax.sql.DataSource
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.domain.table.TableOperations
import org.blackerp.infrastructure.event.EventPublisher
import org.blackerp.infrastructure.persistence.store.*
import org.springframework.boot.test.web.client.TestRestTemplate
import io.mockk.mockk
import org.springframework.boot.autoconfigure.flyway.FlywayMigrationStrategy
@TestConfiguration
class UnifiedTestConfig {
@Bean
@Primary
fun dataSource(): DataSource {
return EmbeddedDatabaseBuilder()
.setType(EmbeddedDatabaseType.H2)
.addScript("db/h2-schema.sql")
.build()
}
@Bean
fun jdbcTemplate(dataSource: DataSource): JdbcTemplate =
JdbcTemplate(dataSource)
@Bean
fun testRestTemplate(): TestRestTemplate =
TestRestTemplate()
@Bean
fun eventPublisher(): EventPublisher =
mockk(relaxed = true)
@Bean
@Primary
fun tableOperations(jdbcTemplate: JdbcTemplate): TableOperations =
PostgresTableOperations(jdbcTemplate)
@Bean
fun postgresTabOperations(
jdbcTemplate: JdbcTemplate,
tableOperations: TableOperations
): PostgresTabOperations =
PostgresTabOperations(jdbcTemplate, tableOperations)
@Bean
fun createTableUseCase(
tableOperations: TableOperations,
eventPublisher: EventPublisher
): CreateTableUseCase =
CreateTableUseCase(tableOperations, eventPublisher)
@Bean
fun flywayMigrationStrategy(): FlywayMigrationStrategy =
FlywayMigrationStrategy { _ -> /* disable automatic migrations */ }
}

File: ./src/test/kotlin/org/blackerp/config/TestConfig.kt
-------------------------------------------
// File: src/test/kotlin/org/blackerp/config/TestConfig.kt
package org.blackerp.config
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType
import javax.sql.DataSource
import com.fasterxml.jackson.databind.ObjectMapper
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.api.mappers.TableMapper
import org.blackerp.infrastructure.event.EventPublisher
import org.blackerp.infrastructure.persistence.store.InMemoryTableOperations
import io.mockk.mockk
// File: src/test/kotlin/org/blackerp/config/TestConfig.kt
@TestConfiguration
class TestConfig {
@Bean
@Primary
fun dataSource(): DataSource =
EmbeddedDatabaseBuilder()
.setType(EmbeddedDatabaseType.H2)
.build()
@Bean
fun jdbcTemplate(dataSource: DataSource): JdbcTemplate =
JdbcTemplate(dataSource)
@Bean
fun objectMapper(): ObjectMapper {
val mapper = ObjectMapper()
mapper.registerModule(JavaTimeModule()) // Add Java 8 time support
return mapper
}
@Bean
fun tableMapper(): TableMapper = TableMapper()
@Bean
fun eventPublisher(): EventPublisher = mockk(relaxed = true)
@Bean
fun tableOperations(): TableOperations = mockk(relaxed = true)
@Bean
fun createTableUseCase(
tableOperations: TableOperations,
eventPublisher: EventPublisher
): CreateTableUseCase = CreateTableUseCase(
operations = tableOperations,
eventPublisher = eventPublisher
)
}

File: ./src/test/kotlin/org/blackerp/config/KotestProjectConfig.kt
-------------------------------------------
// File: src/test/kotlin/org/blackerp/config/KotestProjectConfig.kt
package org.blackerp.config
import io.kotest.core.config.AbstractProjectConfig
import io.kotest.core.spec.IsolationMode
import io.kotest.extensions.spring.SpringExtension
class KotestProjectConfig : AbstractProjectConfig() {
override val isolationMode = IsolationMode.InstancePerLeaf
override fun extensions() = listOf(SpringExtension)
}

File: ./src/test/kotlin/org/blackerp/config/TestEventConfig.kt
-------------------------------------------
package org.blackerp.config
import org.springframework.test.context.ActiveProfiles
import io.mockk.mockk
import org.blackerp.infrastructure.event.EventPublisher
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
@ActiveProfiles("test")
class TestEventConfig {
@Bean
@Primary
fun testEventPublisher(): EventPublisher = mockk(relaxed = true)
}

File: ./src/test/kotlin/org/blackerp/api/controllers/TableControllerTest.kt
-------------------------------------------
// File: src/test/kotlin/org/blackerp/api/controllers/TableControllerTest.kt
package org.blackerp.api.controllers
import com.ninjasquad.springmockk.MockkBean
import io.kotest.core.spec.style.DescribeSpec
import io.mockk.coEvery
import kotlinx.coroutines.test.runTest
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.domain.table.TableOperations
import org.blackerp.api.mappers.TableMapper
import org.blackerp.shared.TestFactory
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.test.web.servlet.MockMvc
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.MediaType
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.content
import arrow.core.right
import com.fasterxml.jackson.databind.ObjectMapper
import org.blackerp.api.dto.response.*
import java.io.File
// File: src/test/kotlin/org/blackerp/api/controllers/TableControllerTest.kt
@WebMvcTest(TableController::class)
@AutoConfigureMockMvc(addFilters = false)
class TableControllerTest : DescribeSpec() {
@Autowired
private lateinit var mockMvc: MockMvc
@Autowired
private lateinit var objectMapper: ObjectMapper
@MockkBean
private lateinit var tableOperations: TableOperations
@MockkBean
private lateinit var createTableUseCase: CreateTableUseCase
@MockkBean
private lateinit var tableMapper: TableMapper
init {
describe("TableController") {
context("GET /api/tables") {
it("should return list of tables") {
runTest {
val table = TestFactory.createTestTable()
val response = TestFactory.createTableResponse()
val tablesResponse = TablesResponse(listOf(response))
coEvery { tableOperations.findAll() } returns listOf(table).right()
coEvery { tableMapper.toResponse(table) } returns response
mockMvc.perform(get("/api/tables"))
.andExpect(status().isOk)
.andExpect(content().json(objectMapper.writeValueAsString(tablesResponse)))
}
}
}
context("POST /api/tables") {
it("should create table successfully") {
runTest {
val request = TestFactory.createTableRequest()
val command = TestFactory.createTableCommand()
val table = TestFactory.createTestTable()
val response = TestFactory.createTableResponse()
coEvery { tableMapper.toCommand(request) } returns command
coEvery { createTableUseCase.execute(command) } returns table.right()
coEvery { tableMapper.toResponse(table) } returns response
mockMvc.perform(post("/api/tables")
.contentType(MediaType.APPLICATION_JSON)
.content(objectMapper.writeValueAsString(request)))
.andExpect(status().isOk)
.andExpect(content().json(objectMapper.writeValueAsString(response)))
}
}
}
}
}
}

File: ./src/test/kotlin/org/blackerp/application/table/CreateTableUseCaseTest.kt
-------------------------------------------
package org.blackerp.application.table
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeTypeOf
import io.mockk.coEvery
import io.mockk.mockk
import io.mockk.slot
import arrow.core.Either
import arrow.core.right
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.values.AccessLevel
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.values.DataType
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.TableOperations
import org.blackerp.infrastructure.event.EventPublisher
class CreateTableUseCaseTest : DescribeSpec({
lateinit var operations: TableOperations
lateinit var eventPublisher: EventPublisher
lateinit var useCase: CreateTableUseCase
beforeTest {
operations = mockk(relaxed = true) {
coEvery { save(any()) } returns mockk<ADTable>().right()
}
eventPublisher = mockk(relaxed = true)
useCase = CreateTableUseCase(operations, eventPublisher)
}
describe("execute") {
context("with valid command") {
val columns = listOf(
CreateColumnCommand(
name = "column_name",
displayName = "Column Name",
description = "A test column",
dataType = DataType.STRING,
length = 50,
precision = null,
scale = null
)
)
val command = CreateTableCommand(
name = "test_table",
displayName = "Test Table",
description = "A test table",
accessLevel = AccessLevel.SYSTEM,
createdBy = "test-user",
columns = columns
)
it("should create and store table") {
runTest {
// given
val tableSlot = slot<ADTable>()
coEvery { operations.save(capture(tableSlot)) } answers {
tableSlot.captured.right()
}
// when
val result = useCase.execute(command)
// then
result.fold(
{ error -> throw AssertionError("Should not fail: $error") },
{ table ->
table.name.value shouldBe "test_table"
table.displayName.value shouldBe "Test Table"
table.description?.value shouldBe "A test table"
table.accessLevel shouldBe AccessLevel.SYSTEM
table.metadata.createdBy shouldBe "test-user"
}
)
}
}
}
context("with invalid command") {
val columns = listOf(
CreateColumnCommand(
name = "column_name",
displayName = "",
description = "A test column with an invalid name",
dataType = DataType.STRING,
length = 50,
precision = null,
scale = null
)
)
val command = CreateTableCommand(
name = "Invalid Name!",
displayName = "",
description = "A".repeat(300),
accessLevel = AccessLevel.SYSTEM,
createdBy = "test-user",
columns = columns
)
it("should return validation errors") {
runTest {
// when
val result = useCase.execute(command)
// then
result.fold(
{ error ->
error.shouldBeTypeOf<TableError.ValidationFailed>()
error.errors.size shouldBe 3
},
{ throw AssertionError("Should not succeed") }
)
}
}
}
}
})

File: ./src/test/kotlin/org/blackerp/shared/TimeBasedIdTest.kt
-------------------------------------------
package org.blackerp.shared
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import java.util.UUID
class TimeBasedIdTest : DescribeSpec({
describe("TimeBasedId") {
describe("generate") {
it("should generate time-based UUIDs") {
// Generate two IDs with a small delay
val id1 = TimeBasedId.generate()
Thread.sleep(1) // Minimal delay
val id2 = TimeBasedId.generate()
// Verify they are different
id1 shouldNotBe id2
// Verify version 1 (time-based) UUID
(id1.version() == 1) shouldBe true
(id2.version() == 1) shouldBe true
}
}
}
})

File: ./src/test/kotlin/org/blackerp/shared/TestFactory.kt
-------------------------------------------
package org.blackerp.shared
import org.blackerp.api.dto.request.CreateTableRequest
import org.blackerp.api.dto.request.CreateColumnRequest
import org.blackerp.api.dto.response.TableResponse
import org.blackerp.application.table.CreateTableCommand
import org.blackerp.application.table.CreateColumnCommand
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.values.*
import java.time.Instant
import java.util.UUID
object TestFactory {
fun createMetadata(
id: UUID = TimeBasedId.generate(),
createdBy: String = "test-user",
updatedBy: String = createdBy,
version: Int = 0,
active: Boolean = true
) = EntityMetadata(
id = id,
created = Instant.now(),
createdBy = createdBy,
updated = Instant.now(),
updatedBy = updatedBy,
version = version,
active = active
)
fun createValidTableName(name: String = "test_table") =
TableName.create(name).getOrNull()
?: throw IllegalStateException("Failed to create valid table name: $name")
fun createValidDisplayName(name: String = "Test Table") =
DisplayName.create(name).getOrNull()
?: throw IllegalStateException("Failed to create valid display name: $name")
fun createValidDescription(text: String = "Test description") =
Description.create(text).getOrNull()
fun createTestColumn(): ColumnDefinition {
val metadata = createMetadata()
val name = ColumnName.create("test_column").getOrNull()!!
val displayName = DisplayName.create("Test Column").getOrNull()!!
val description = Description.create("Test column description").getOrNull()
val length = Length.create(50).getOrNull()!!
return ColumnDefinition(
metadata = metadata,
name = name,
displayName = displayName,
description = description,
dataType = DataType.STRING,
length = length,
precision = null,
scale = null,
mandatory = false,
defaultValue = null
)
}
// Add inside TestFactory object
fun createTableRequest() = CreateTableRequest(
name = "test_table",
displayName = "Test Table",
description = "Test Description",
accessLevel = "SYSTEM",
columns = listOf(
CreateColumnRequest(
name = "test_column",
displayName = "Test Column",
description = "Test column description",
dataType = "STRING",
length = 50,
precision = null,
scale = null
)
)
)
fun createTableCommand() = CreateTableCommand(
name = "test_table",
displayName = "Test Table",
description = "Test Description",
accessLevel = AccessLevel.SYSTEM,
createdBy = "test-user",
columns = listOf(
CreateColumnCommand(
name = "test_column",
displayName = "Test Column",
description = "Test column description",
dataType = DataType.STRING,
length = 50,
precision = null,
scale = null
)
)
)
fun createTableResponse() = TableResponse(
id = UUID.randomUUID(),
name = "test_table",
displayName = "Test Table",
description = "Test Description",
accessLevel = "SYSTEM"
)
fun createTestTable(
id: UUID = TimeBasedId.generate(),
name: String = "test_table",
displayName: String = "Test Table",
description: String? = "Test Description",
accessLevel: AccessLevel = AccessLevel.SYSTEM,
createdBy: String = "test-user",
updatedBy: String = createdBy
): ADTable {
val metadata = createMetadata(
id = id,
createdBy = createdBy,
updatedBy = updatedBy
)
return ADTable(
metadata = metadata,
name = createValidTableName(name),
displayName = createValidDisplayName(displayName),
description = description?.let { createValidDescription(it) },
accessLevel = accessLevel,
columns = listOf(createTestColumn())
)
}
}

File: ./src/test/kotlin/org/blackerp/integration/plugin/PluginLifecycleIntegrationTest.kt
-------------------------------------------
package org.blackerp.integration.plugin
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.assertions.arrow.core.shouldBeRight
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.blackerp.integration.IntegrationTestConfig
import org.springframework.context.annotation.Import
import org.blackerp.plugin.*
import org.blackerp.plugin.registry.DefaultPluginRegistry
import org.blackerp.plugin.registry.PluginRegistry
@SpringBootTest
@ActiveProfiles("test")
@Import(IntegrationTestConfig::class)
class PluginLifecycleIntegrationTest : DescribeSpec({
val pluginRegistry: PluginRegistry = DefaultPluginRegistry()
describe("Plugin Lifecycle") {
it("should load and initialize plugin") {
// given
val pluginId = PluginId.create("test-plugin").getOrNull()!!
val version = Version.create("1.0.0").getOrNull()!!
val metadata = PluginMetadata.create(
id = pluginId,
version = version,
name = "Test Plugin",
description = "Test plugin",
vendor = "Test Vendor"
).getOrNull()!!
val plugin = TestPlugin(metadata)
// when
val registerResult = pluginRegistry.register(plugin)
// then
registerResult.shouldBeRight()
}
}
})

File: ./src/test/kotlin/org/blackerp/integration/api/TableApiIntegrationTest.kt
-------------------------------------------
package org.blackerp.integration.api
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.web.client.TestRestTemplate
import org.springframework.boot.test.web.server.LocalServerPort
import org.springframework.http.HttpStatus
import org.springframework.test.context.ActiveProfiles
import org.blackerp.integration.IntegrationTestConfig
import org.springframework.context.annotation.Import
import org.blackerp.shared.TestFactory
import org.blackerp.api.dto.request.CreateTableRequest
import org.blackerp.api.dto.response.TableResponse
import org.blackerp.api.dto.response.TablesResponse
import io.kotest.matchers.shouldNotBe
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@Import(IntegrationTestConfig::class)
class TableApiIntegrationTest(
private val restTemplate: TestRestTemplate,
@LocalServerPort private val port: Int
) : DescribeSpec({
describe("Table API") {
context("POST /api/tables") {
it("should create table successfully") {
// given
val request = TestFactory.createTableRequest()
// when
val response = restTemplate.postForEntity(
"http://localhost:$port/api/tables",
request,
TableResponse::class.java
)
// then
response.statusCode shouldBe HttpStatus.OK
response.body shouldNotBe null
response.body?.name shouldBe request.name
}
}
context("GET /api/tables") {
it("should return list of tables") {
// when
val response = restTemplate.getForEntity(
"http://localhost:$port/api/tables",
TablesResponse::class.java
)
// then
response.statusCode shouldBe HttpStatus.OK
response.body shouldNotBe null
}
}
}
})

File: ./src/test/kotlin/org/blackerp/integration/db/TableRepositoryIntegrationTest.kt
-------------------------------------------
package org.blackerp.integration.db
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.blackerp.integration.IntegrationTestConfig
import org.springframework.context.annotation.Import
import org.blackerp.infrastructure.persistence.store.PostgresTableOperations
import org.blackerp.shared.TestFactory
import org.springframework.jdbc.core.JdbcTemplate
@SpringBootTest
@ActiveProfiles("test")
@Import(IntegrationTestConfig::class)
class TableRepositoryIntegrationTest(
private val jdbcTemplate: JdbcTemplate
) : DescribeSpec({
lateinit var tableOperations: PostgresTableOperations
beforeTest {
tableOperations = PostgresTableOperations(jdbcTemplate)
}
describe("TableRepository") {
it("should save and retrieve table") {
// given
val table = TestFactory.createTestTable()
// when
val saveResult = tableOperations.save(table)
val findResult = tableOperations.findById(table.metadata.id)
// then
saveResult.shouldBeRight()
findResult.shouldBeRight()
}
}
})

File: ./src/test/kotlin/org/blackerp/integration/IntegrationTestConfig.kt
-------------------------------------------
package org.blackerp.integration
import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import javax.sql.DataSource
import org.springframework.boot.test.web.client.TestRestTemplate
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType
import org.springframework.jdbc.core.JdbcTemplate
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.infrastructure.event.EventPublisher
import org.blackerp.infrastructure.persistence.store.PostgresTableOperations
import io.mockk.mockk
@TestConfiguration
class IntegrationTestConfig {
@Bean
@Primary
fun dataSource(): DataSource =
EmbeddedDatabaseBuilder()
.setType(EmbeddedDatabaseType.H2)
.addScript("db/h2-schema.sql")
.build()
@Bean
fun jdbcTemplate(dataSource: DataSource): JdbcTemplate =
JdbcTemplate(dataSource)
@Bean
fun testRestTemplate() = TestRestTemplate()
@Bean
fun eventPublisher(): EventPublisher = mockk(relaxed = true)
@Bean
fun tableOperations(jdbcTemplate: JdbcTemplate): PostgresTableOperations =
PostgresTableOperations(jdbcTemplate)
@Bean
fun createTableUseCase(
tableOperations: PostgresTableOperations,
eventPublisher: EventPublisher
): CreateTableUseCase = CreateTableUseCase(tableOperations, eventPublisher)
}

