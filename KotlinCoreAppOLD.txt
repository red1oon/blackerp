Generating folder structure...
-------------------------------------------
.
├── application
│   ├── api
│   │   ├── advice
│   │   │   └── ErrorHandler.kt
│   │   ├── auth
│   │   │   ├── controllers
│   │   │   │   └── AuthController.kt
│   │   │   └── dto
│   │   │   └── AuthDtos.kt
│   │   ├── common
│   │   │   ├── ApiImports.kt
│   │   │   ├── BaseService.kt
│   │   │   ├── DomainImports.kt
│   │   │   ├── Imports.kt
│   │   │   ├── ServiceImports.kt
│   │   │   ├── SharedImports.kt
│   │   │   ├── StandardImports.kt
│   │   │   └── WebImports.kt
│   │   ├── controllers
│   │   │   ├── DocumentController.kt
│   │   │   ├── DocumentLifecycleController.kt
│   │   │   ├── Imports.kt
│   │   │   ├── ProcessController.kt
│   │   │   ├── ReferenceController.kt
│   │   │   ├── TableController.kt
│   │   │   └── WorkflowController.kt
│   │   ├── dto
│   │   │   ├── ParameterMapping.kt
│   │   │   ├── requests
│   │   │   │   ├── CreateDocumentRequest.kt
│   │   │   │   ├── CreateProcessRequest.kt
│   │   │   │   └── TableRequests.kt
│   │   │   ├── responses
│   │   │   │   └── TableResponses.kt
│   │   │   └── TableDTO.kt
│   │   ├── extensions
│   │   │   ├── DomainExtensions.kt
│   │   │   └── ProcessExtensions.kt
│   │   ├── mappers
│   │   │   └── TableMapper.kt
│   │   └── process
│   │   ├── ApiCreateProcessCommand.kt
│   │   ├── commands.kt
│   │   ├── CreateProcessCommand.kt
│   │   ├── DomainProcessParameter.kt
│   │   ├── ProcessExtensions.kt
│   │   ├── types.kt
│   │   └── WorkflowCommands.kt
│   ├── Application.kt
│   ├── build.gradle.kts
│   ├── config
│   │   ├── CacheConfig.kt
│   │   └── DatabaseConfig.kt
│   ├── .env
│   ├── services
│   │   ├── ADMetadataService.kt
│   │   ├── audit
│   │   │   └── AuditService.kt
│   │   ├── auth
│   │   │   ├── AuthService.kt
│   │   │   └── JwtService.kt
│   │   ├── base
│   │   │   └── CoroutineBaseService.kt
│   │   ├── cache
│   │   │   ├── CacheStrategy.kt
│   │   │   └── WindowCacheStrategy.kt
│   │   ├── common
│   │   │   ├── ServiceBase.kt
│   │   │   └── ServiceImports.kt
│   │   ├── config
│   │   │   └── SecurityConfig.kt
│   │   ├── core
│   │   │   ├── ServiceBase.kt
│   │   │   └── ServiceImports.kt
│   │   ├── CoroutineConfig.kt
│   │   ├── docaction
│   │   │   └── DocActionService.kt
│   │   ├── docstatus
│   │   │   └── DocStatusService.kt
│   │   ├── DocumentLifecycleService.kt
│   │   ├── DocumentService.kt
│   │   ├── error
│   │   │   └── DomainProcessError.kt
│   │   ├── impl
│   │   ├── ImportTransactional.kt
│   │   ├── interfaces
│   │   │   └── ProcessInterfaces.kt
│   │   ├── JwtProperties.kt
│   │   ├── plugin
│   │   │   └── PluginService.kt
│   │   ├── process
│   │   │   ├── ProcessExecutionService.kt
│   │   │   └── ProcessServiceImpl.kt
│   │   ├── ProcessService.kt
│   │   ├── ReferenceService.kt
│   │   ├── SecurityFilter.kt
│   │   ├── SecurityService.kt
│   │   ├── table
│   │   │   └── TableManagementService.kt
│   │   ├── TableMetrics.kt
│   │   ├── TableService.kt
│   │   ├── TransactionalImports.kt
│   │   ├── window
│   │   │   └── WindowServiceImpl.kt
│   │   ├── workflow
│   │   │   ├── WorkflowExecutionEngine.kt
│   │   │   ├── WorkflowExecutionTracker.kt
│   │   │   ├── WorkflowExtensions.kt
│   │   │   ├── WorkflowServiceImpl.kt
│   │   │   └── WorkflowService.kt
│   │   └── WorkflowService.kt
│   ├── usecases
│   │   ├── document
│   │   │   ├── CreateDocumentCommand.kt
│   │   │   └── CreateDocumentUseCase.kt
│   │   ├── process
│   │   │   ├── CreateProcessUseCase.kt
│   │   │   └── ProcessExtensions.kt
│   │   ├── table
│   │   ├── window
│   │   └── workflow
│   │   ├── CreateWorkflowUseCase.kt
│   │   └── WorkflowExtensions.kt
│   └── workflow
│   └── engine
│   └── WorkflowEngine.kt
├── build_errors.txt
├── build.gradle.kts
├── check_imports.sh
├── compile_output.txt
├── compile.sh
├── CoreApp.txt
├── correct_importlist.txt
├── diff.patch
├── domain
│   ├── build.gradle.kts
│   ├── core
│   │   ├── ad
│   │   │   ├── base
│   │   │   │   ├── ADModule.kt
│   │   │   │   ├── ADObject.kt
│   │   │   │   ├── ModuleName.kt
│   │   │   │   └── ModuleService.kt
│   │   │   ├── docaction
│   │   │   │   ├── DocActionError.kt
│   │   │   │   ├── DocAction.kt
│   │   │   │   ├── DocActionOperations.kt
│   │   │   │   └── DocActionRegistry.kt
│   │   │   ├── docstatus
│   │   │   │   ├── AD_DocStatus.kt
│   │   │   │   ├── DocStatusError.kt
│   │   │   │   └── DocStatus.kt
│   │   │   ├── document
│   │   │   │   ├── DocumentCommands.kt
│   │   │   │   ├── DocumentError.kt
│   │   │   │   ├── DocumentEvents.kt
│   │   │   │   ├── Document.kt
│   │   │   │   ├── DocumentModel.kt
│   │   │   │   ├── DocumentOperations.kt
│   │   │   │   ├── DocumentProcessHandler.kt
│   │   │   │   ├── DocumentStatus.kt
│   │   │   │   ├── DocumentType.kt
│   │   │   │   └── DocumentType.kt.bak
│   │   │   ├── extension
│   │   │   ├── metadata
│   │   │   │   ├── entities
│   │   │   │   │   ├── ADRule.kt
│   │   │   │   │   ├── ADStatusLine.kt
│   │   │   │   │   └── ADValidationRule.kt
│   │   │   │   ├── expression
│   │   │   │   │   ├── ExpressionEngine.kt
│   │   │   │   │   └── ExpressionParser.kt
│   │   │   │   ├── operations
│   │   │   │   │   └── MetadataOperations.kt
│   │   │   │   ├── repositories
│   │   │   │   │   └── MetadataRepository.kt
│   │   │   │   └── services
│   │   │   │   ├── MetadataService.kt
│   │   │   │   └── RuleEvaluator.kt
│   │   │   ├── process
│   │   │   │   ├── ADParameter.kt
│   │   │   │   ├── ADProcess.kt
│   │   │   │   ├── ProcessError.kt
│   │   │   │   ├── ProcessOperations.kt
│   │   │   │   ├── ProcessRepository.kt
│   │   │   │   └── ProcessTypes.kt
│   │   │   ├── reference
│   │   │   │   ├── ADReference.kt
│   │   │   │   ├── ReferenceOperations.kt
│   │   │   │   ├── ReferenceTypes.kt
│   │   │   │   └── value
│   │   │   │   └── ReferenceName.kt
│   │   │   ├── shared
│   │   │   │   └── values
│   │   │   │   └── ProcessName.kt
│   │   │   ├── tab
│   │   │   │   ├── ADTab.kt
│   │   │   │   ├── OrderBySpec.kt
│   │   │   │   ├── TabError.kt
│   │   │   │   ├── TabOperations.kt
│   │   │   │   ├── TabService.kt
│   │   │   │   └── value
│   │   │   │   └── TabName.kt
│   │   │   ├── table
│   │   │   │   ├── ADTable.kt
│   │   │   │   ├── ColumnDefinition.kt
│   │   │   │   ├── commands.kt
│   │   │   │   ├── ConstraintOperations.kt
│   │   │   │   ├── RelationshipOperations.kt
│   │   │   │   ├── TableConstraint.kt
│   │   │   │   ├── TableOperations.kt
│   │   │   │   └── TableRelationship.kt
│   │   │   ├── window
│   │   │   │   ├── ADWindow.kt
│   │   │   │   ├── commands.kt
│   │   │   │   ├── WindowName.kt
│   │   │   │   ├── WindowOperations.kt
│   │   │   │   └── WindowService.kt
│   │   │   └── workflow
│   │   │   ├── commands.kt
│   │   │   ├── metadata
│   │   │   │   ├── WorkflowMetadata.kt
│   │   │   │   └── WorkflowMetadataProvider.kt
│   │   │   ├── NodeAction.kt
│   │   │   ├── NodeType.kt
│   │   │   ├── WorkflowError.kt
│   │   │   ├── WorkflowNode.kt
│   │   │   ├── WorkflowOperations.kt
│   │   │   ├── WorkflowService.kt
│   │   │   └── WorkflowTransition.kt
│   │   ├── audit
│   │   │   └── AuditLog.kt
│   │   ├── client
│   │   ├── DomainEntity.kt
│   │   ├── DomainException.kt
│   │   ├── error
│   │   │   ├── DomainError.kt
│   │   │   ├── PluginError.kt
│   │   │   ├── ProcessError.kt
│   │   │   ├── TableErrors.kt
│   │   │   ├── UnexpectedError.kt
│   │   │   ├── WindowError.kt
│   │   │   └── WorkflowErrors.kt
│   │   ├── metadata
│   │   │   └── ChangeTracking.kt
│   │   ├── plugin
│   │   │   ├── PluginDefinition.kt
│   │   │   └── PluginRegistry.kt
│   │   ├── reference
│   │   │   └── ReferenceError.kt
│   │   ├── repository
│   │   │   └── ColumnOperations.kt
│   │   ├── rules
│   │   ├── security
│   │   │   ├── DocumentAccessControl.kt
│   │   │   ├── events
│   │   │   │   └── UserEvent.kt
│   │   │   ├── SecurityModel.kt
│   │   │   ├── SecurityOperations.kt
│   │   │   └── UserRepository.kt
│   │   ├── service
│   │   │   └── TableManagementService.kt
│   │   ├── shared
│   │   │   ├── ChangePair.kt
│   │   │   ├── EntityMetadata.kt
│   │   │   └── ValidationError.kt
│   │   ├── tenant
│   │   │   └── TenantAware.kt
│   │   ├── values
│   │   │   ├── AccessLevel.kt
│   │   │   ├── Amount.kt
│   │   │   ├── ColumnName.kt
│   │   │   ├── Currency.kt
│   │   │   ├── DataType.kt
│   │   │   ├── Description.kt
│   │   │   ├── DisplayName.kt
│   │   │   ├── Length.kt
│   │   │   ├── Precision.kt
│   │   │   ├── Scale.kt
│   │   │   ├── TableName.kt
│   │   │   └── TabName.kt
│   │   ├── Version.kt
│   │   └── workflow
│   │   ├── execution
│   │   │   └── WorkflowExecutionTracker.kt
│   │   ├── state
│   │   │   └── WorkflowStateMachine.kt
│   │   ├── tracking
│   │   │   ├── ExecutionStatus.kt
│   │   │   └── WorkflowExecution.kt
│   │   └── transition
│   │   ├── StateTransition.kt
│   │   └── TransitionValidator.kt
│   ├── events
│   │   ├── ConstraintEvents.kt
│   │   ├── DocumentEvents.kt
│   │   ├── DomainEvent.kt
│   │   ├── EventMetadata.kt
│   │   ├── handlers
│   │   ├── publishers
│   │   ├── RelationshipEvents.kt
│   │   ├── WindowEvents.kt
│   │   └── WorkflowEvents.kt
│   ├── .gradle
│   │   ├── 4.4.1
│   │   │   ├── fileChanges
│   │   │   │   └── last-build.bin
│   │   │   ├── fileHashes
│   │   │   │   ├── fileHashes.bin
│   │   │   │   └── fileHashes.lock
│   │   │   └── taskHistory
│   │   │   ├── taskHistory.bin
│   │   │   └── taskHistory.lock
│   │   └── buildOutputCleanup
│   │   ├── buildOutputCleanup.lock
│   │   ├── cache.properties
│   │   └── outputFiles.bin
│   ├── gradle
│   │   └── wrapper
│   │   ├── gradle-wrapper.jar
│   │   └── gradle-wrapper.properties
│   ├── gradlew
│   ├── gradlew.bat
│   ├── services
│   │   ├── implementations
│   │   └── interfaces
│   └── validation
│   ├── BaseValidator.kt
│   ├── rules
│   ├── Validator.kt
│   ├── ValidatorRegistry.kt
│   └── validators
│   ├── model
│   └── module
│   └── ModuleValidator.kt
├── fix_application.sh
├── fix_coroutines.sh
├── generate_project_listing.sh
├── .gitattributes
├── .gitignore
├── .gradle
│   ├── 7.5
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   ├── dependencies-accessors.lock
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── 7.6
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   ├── dependencies-accessors.lock
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── 8.5
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   ├── dependencies-accessors.lock
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── buildOutputCleanup
│   │   ├── buildOutputCleanup.lock
│   │   ├── cache.properties
│   │   └── outputFiles.bin
│   ├── file-system.probe
│   ├── kotlin
│   │   ├── errors
│   │   └── sessions
│   ├── nb-cache
│   │   ├── application-1902852908
│   │   │   └── project-info.ser
│   │   ├── blackerp-714317333
│   │   │   └── project-info.ser
│   │   ├── domain-1912511128
│   │   │   └── project-info.ser
│   │   ├── infrastructure-296333895
│   │   │   └── project-info.ser
│   │   ├── subprojects.ser
│   │   └── trust
│   │   └── A6985601763B2381A8D52E92F6076DBEC3B58C86C3C43BFF90B6629A71492D0A
│   └── vcs-1
│   └── gc.properties
├── gradle
│   └── wrapper
│   ├── gradle-wrapper.jar
│   └── gradle-wrapper.properties
├── gradle_files.txt
├── gradlew
├── gradlew.bat
├── infrastructure
│   ├── audit
│   │   └── AuditLoggerImpl.kt
│   ├── build.gradle.kts
│   ├── cache
│   │   ├── configs
│   │   ├── providers
│   │   └── strategies
│   ├── core
│   │   └── logging
│   │   └── DomainLogger.kt
│   ├── database
│   │   ├── h2
│   │   │   └── init.sql
│   │   └── migration
│   │   ├── V1__Create_User_Tables.sql
│   │   ├── V2__Create_Document_Tables.sql
│   │   └── V3__Create_Metadata_Tables.sql
│   ├── events
│   │   ├── handlers
│   │   │   ├── ConstraintEventHandler.kt
│   │   │   ├── RelationshipEventHandler.kt
│   │   │   ├── WindowEventHandler.kt
│   │   │   └── WorkflowEventHandler.kt
│   │   └── publishers
│   │   └── DomainEventPublisher.kt
│   ├── integration
│   │   ├── adapters
│   │   │   ├── SystemHealthAdapter.kt
│   │   │   └── TableHealthIndicator.kt
│   │   └── clients
│   ├── messaging
│   │   ├── consumers
│   │   └── publishers
│   ├── metadata
│   │   ├── cache
│   │   │   └── MetadataCacheService.kt
│   │   ├── MetadataConfig.kt
│   │   └── services
│   │   ├── MetadataEvaluator.kt
│   │   └── MetadataServiceImpl.kt
│   ├── persistence
│   │   ├── entities
│   │   │   └── UserEntity.kt
│   │   ├── mappers
│   │   │   └── UserMapper.kt
│   │   ├── mappings
│   │   ├── metadata
│   │   │   ├── MetadataConfig.kt
│   │   │   └── repositories
│   │   │   └── JdbcMetadataRepository.kt
│   │   └── repositories
│   │   ├── ConstraintRepository.kt
│   │   ├── DocumentHistoryRepository.kt
│   │   ├── DocumentRepositoryImpl.kt
│   │   ├── DocumentRepository.kt
│   │   ├── ProcessRepository.kt
│   │   ├── RelationshipRepository.kt
│   │   ├── SpringUserRepository.kt
│   │   ├── UserRepositoryImpl.kt
│   │   ├── WindowRepository.kt
│   │   └── WorkflowRepository.kt
│   ├── plugin
│   │   ├── loaders
│   │   └── registry
│   │   └── PluginRegistryImpl.kt
│   ├── process
│   │   ├── executor
│   │   │   └── ProcessExecutorImpl.kt
│   │   ├── implementation
│   │   ├── tracking
│   │   │   └── ProcessExecutionTracker.kt
│   │   └── validation
│   │   └── ParameterValidator.kt
│   ├── scheduler
│   │   ├── jobs
│   │   └── triggers
│   ├── validation
│   │   ├── expression
│   │   │   ├── DefaultExpressionEngine.kt
│   │   │   └── DefaultExpressionParser.kt
│   │   ├── RuleBasedValidator.kt
│   │   └── validators
│   │   ├── CircularReferenceValidator.kt
│   │   ├── ColumnValidator.kt
│   │   ├── CompositeValidator.kt
│   │   ├── ConstraintValidator.kt
│   │   ├── RelationshipValidator.kt
│   │   └── TableValidator.kt
│   └── workflow
│   ├── persistence
│   │   └── TransitionRepository.kt
│   └── tracking
│   └── WorkflowExecutionTrackerImpl.kt
├── integration-tests
│   ├── build.gradle.kts
│   ├── .gradle
│   │   ├── 4.4.1
│   │   │   ├── fileChanges
│   │   │   │   └── last-build.bin
│   │   │   ├── fileHashes
│   │   │   │   ├── fileHashes.bin
│   │   │   │   └── fileHashes.lock
│   │   │   └── taskHistory
│   │   │   ├── taskHistory.bin
│   │   │   └── taskHistory.lock
│   │   └── buildOutputCleanup
│   │   ├── buildOutputCleanup.lock
│   │   ├── cache.properties
│   │   └── outputFiles.bin
│   ├── gradle
│   │   └── wrapper
│   │   ├── gradle-wrapper.jar
│   │   └── gradle-wrapper.properties
│   ├── gradlew
│   ├── gradlew.bat
│   └── test
│   ├── kotlin
│   │   └── org
│   │   └── blackerp
│   │   ├── api
│   │   │   └── controllers
│   │   │   └── TableControllerTest.kt
│   │   └── test
│   │   ├── builders
│   │   │   └── ADTableBuilder.kt
│   │   ├── fixtures
│   │   │   └── ADFixtures.kt
│   │   └── IntegrationTest.kt
│   └── resources
│   └── application-test.yml
├── KotlinCoreApp2.txt
├── KotlinCoreApp.txt
├── KotlinPOC.txt
├── KotlinProjectCode.txt
├── LICENSE
├── README.md
├── refactor.sh
├── settings.gradle.kts
├── settings.gradle.kts.bak
├── test-import
│   ├── build.gradle.kts
│   ├── create.sh
│   ├── domain
│   │   ├── build.gradle.kts
│   │   └── core
│   │   ├── DomainEntity.kt
│   │   ├── metadata
│   │   │   └── EntityMetadata.kt
│   │   ├── shared
│   │   │   ├── EntityMetadata.kt
│   │   │   └── ValidationError.kt
│   │   └── values
│   │   └── TableName.kt
│   ├── .gradle
│   │   ├── 4.4.1
│   │   │   ├── fileChanges
│   │   │   │   └── last-build.bin
│   │   │   ├── fileHashes
│   │   │   │   ├── fileHashes.bin
│   │   │   │   └── fileHashes.lock
│   │   │   └── taskHistory
│   │   │   ├── taskHistory.bin
│   │   │   └── taskHistory.lock
│   │   ├── 8.4
│   │   │   ├── checksums
│   │   │   │   ├── checksums.lock
│   │   │   │   ├── md5-checksums.bin
│   │   │   │   └── sha1-checksums.bin
│   │   │   ├── dependencies-accessors
│   │   │   │   ├── dependencies-accessors.lock
│   │   │   │   └── gc.properties
│   │   │   ├── executionHistory
│   │   │   │   ├── executionHistory.bin
│   │   │   │   └── executionHistory.lock
│   │   │   ├── fileChanges
│   │   │   │   └── last-build.bin
│   │   │   ├── fileHashes
│   │   │   │   ├── fileHashes.bin
│   │   │   │   ├── fileHashes.lock
│   │   │   │   └── resourceHashesCache.bin
│   │   │   ├── gc.properties
│   │   │   └── vcsMetadata
│   │   ├── buildOutputCleanup
│   │   │   ├── buildOutputCleanup.lock
│   │   │   ├── cache.properties
│   │   │   └── outputFiles.bin
│   │   ├── file-system.probe
│   │   ├── kotlin
│   │   │   ├── errors
│   │   │   └── sessions
│   │   └── vcs-1
│   │   └── gc.properties
│   ├── gradle
│   │   └── wrapper
│   │   ├── gradle-wrapper.jar
│   │   └── gradle-wrapper.properties
│   ├── gradlew
│   ├── gradlew.bat
│   └── settings.gradle.kts
└── uncategorized_errors.txt

231 directories, 398 files


Generating file details...
-------------------------------------------

File: ./infrastructure/persistence/mappers/UserMapper.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.mappers import org.springframework.stereotype.Component import org.blackerp.domain.core.security.* import org.blackerp.infrastructure.persistence.entities.UserEntity import java.time.Instant @Component class UserMapper {fun toDomain(entity:UserEntity):User=User(id=entity.id,username=entity.username,email=entity.email,isActive=entity.isActive,roles=emptySet(),// TODO:Implement role mapping clientId=entity.clientId,organizationId=entity.organizationId,lastLogin=entity.lastLogin) fun toEntity(domain:User):UserEntity=UserEntity(id=domain.id,username=domain.username,email=domain.email,passwordHash="",// Set through security service isActive=domain.isActive,clientId=domain.clientId,organizationId=domain.organizationId,lastLogin=domain.lastLogin) fun updateEntity(entity:UserEntity,domain:User):UserEntity {entity.username=domain.username entity.email=domain.email entity.isActive=domain.isActive entity.clientId=domain.clientId entity.organizationId=domain.organizationId entity.updatedAt=Instant.now() return entity}} 
File: ./infrastructure/persistence/entities/UserEntity.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.entities import jakarta.persistence.* import java.time.Instant import java.util.UUID @Entity @Table(name="ad_user") class UserEntity(@Id @Column(name="id") val id:UUID=UUID.randomUUID(),@Column(name="username",unique=true) var username:String,@Column(name="email") var email:String,@Column(name="password_hash") var passwordHash:String,@Column(name="is_active") var isActive:Boolean=true,@Column(name="client_id") var clientId:UUID,@Column(name="organization_id") var organizationId:UUID?=null,@Column(name="last_login") var lastLogin:Instant?=null,@Column(name="created_at") val createdAt:Instant=Instant.now(),@Column(name="updated_at") var updatedAt:Instant=Instant.now(),@ElementCollection(fetch=FetchType.EAGER) @CollectionTable(name="ad_user_role",joinColumns=[JoinColumn(name="user_id")]) var roleIds:MutableSet<UUID>=mutableSetOf()) 
File: ./infrastructure/persistence/repositories/DocumentHistoryRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.shared.ChangePair import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Repository class DocumentHistoryRepository(private val jdbcTemplate:JdbcTemplate) {private val logger=LoggerFactory.getLogger(DocumentHistoryRepository::class.java) // In-memory storage for POC private val historyRecords=mutableListOf<DocumentChange>() fun trackChange(change:DocumentChange) {historyRecords.add(change) logger.debug("Tracked change for document:${change.documentId}")} fun getHistory(documentId:UUID):List<DocumentChange>=historyRecords .filter {it.documentId == documentId} .sortedByDescending {it.changedAt} fun getHistoryBetween(documentId:UUID,fromDate:Instant,toDate:Instant):List<DocumentChange>=historyRecords .filter {it.documentId == documentId && it.changedAt in fromDate..toDate} .sortedByDescending {it.changedAt}} 
File: ./infrastructure/persistence/repositories/WorkflowRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.slf4j.LoggerFactory @Repository class WorkflowRepository(private val jdbcTemplate:JdbcTemplate) :WorkflowOperations {private val logger=LoggerFactory.getLogger(WorkflowRepository::class.java) @Transactional override suspend fun save(node:WorkflowNode):Either<WorkflowError,WorkflowNode>=try {logger.debug("Saving workflow node:${node.id}") jdbcTemplate.update(""" INSERT INTO workflow_node (id,type,display_name,description,action_type,action_data) VALUES (?,?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET type=EXCLUDED.type,display_name=EXCLUDED.display_name,description=EXCLUDED.description,action_type=EXCLUDED.action_type,action_data=EXCLUDED.action_data """,node.id,node.type.name,node.displayName.value,node.description?.value,node.action?.javaClass?.simpleName,node.action?.toString()) handleTransitions(node) node.right()} catch (e:Exception) {logger.error("Failed to save node:${node.id}",e) WorkflowError.ValidationFailed("Save failed:${e.message}").left()} override suspend fun findById(id:UUID):Either<WorkflowError,WorkflowNode?>=null.right() override suspend fun delete(id:UUID):Either<WorkflowError,Unit>=Unit.right() override suspend fun validateWorkflow(nodes:List<WorkflowNode>):Either<WorkflowError,Unit>=Unit.right() private fun handleTransitions(node:WorkflowNode) {jdbcTemplate.update("DELETE FROM workflow_transition WHERE source_node_id=?",node.id) node.transitions.forEach {transition->jdbcTemplate.update(""" INSERT INTO workflow_transition (id,source_node_id,target_node_id,condition_expression) VALUES (?,?,?,?) """,transition.id,node.id,transition.targetNode,transition.condition?.expression)}}} 
File: ./infrastructure/persistence/repositories/DocumentRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.blackerp.domain.core.ad.document.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import java.util.UUID @Repository class DocumentRepository :DocumentOperations {override suspend fun create(document:Document):Either<DocumentError,Document>=document.right() override suspend fun update(id:UUID,document:Document):Either<DocumentError,Document>=document.right() override suspend fun findById(id:UUID):Either<DocumentError,Document?>=null.right() override suspend fun search(criteria:SearchCriteria):Flow<Document>=flowOf() override suspend fun delete(id:UUID):Either<DocumentError,Unit>=Unit.right() override suspend fun changeStatus(id:UUID,status:DocumentStatus):Either<DocumentError,Document>=DocumentError.NotFound(id).left() override suspend fun getHistory(id:UUID):Flow<DocumentChange>=flowOf()} 
File: ./infrastructure/persistence/repositories/ConstraintRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.slf4j.LoggerFactory import org.springframework.dao.DataIntegrityViolationException @Repository class ConstraintRepository(private val jdbcTemplate:JdbcTemplate) :ConstraintOperations {private val logger=LoggerFactory.getLogger(ConstraintRepository::class.java) @Transactional override suspend fun save(constraint:TableConstraint):Either<TableError,TableConstraint>=try {logger.debug("Saving constraint:${constraint.id}") // Save main constraint jdbcTemplate.update(""" INSERT INTO table_constraint (id,table_id,name,constraint_type,expression) VALUES (?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET name=EXCLUDED.name,constraint_type=EXCLUDED.constraint_type,expression=EXCLUDED.expression """,constraint.id,constraint.tableId,constraint.name,constraint.type.name,constraint.expression) // Save constraint columns saveConstraintColumns(constraint) constraint.right()} catch (e:DataIntegrityViolationException) {logger.error("Constraint violation while saving constraint:${constraint.id}",e) TableError.ValidationError(message="Constraint violation:${e.message}",violations=listOf(TableError.Violation("constraint","Database constraint violation",null))).left()} catch (e:Exception) {logger.error("Failed to save constraint:${constraint.id}",e) TableError.DatabaseError(message="Failed to save constraint:${e.message}",sqlState=null,errorCode=null).left()} private fun saveConstraintColumns(constraint:TableConstraint) {// First delete existing columns jdbcTemplate.update("DELETE FROM table_constraint_column WHERE constraint_id=?",constraint.id) // Then insertnew columns constraint.columns.forEach {column->jdbcTemplate.update(""" INSERT INTO table_constraint_column (constraint_id,column_name) VALUES (?,?) """,constraint.id,column)}} override suspend fun findByTable(tableId:UUID):Either<TableError,List<TableConstraint>>=try {val constraints=jdbcTemplate.query(""" SELECT c.id,c.table_id,c.name,c.constraint_type,c.expression,array_agg(cc.column_name) as columns FROM table_constraint c LEFT JOIN table_constraint_column cc ON c.id=cc.constraint_id WHERE c.table_id=? GROUP BY c.id,c.table_id,c.name,c.constraint_type,c.expression """,{rs,_->TableConstraint(id=UUID.fromString(rs.getString("id")),tableId=UUID.fromString(rs.getString("table_id")),name=rs.getString("name"),type=ConstraintType.valueOf(rs.getString("constraint_type")),columns=(rs.getArray("columns")?.array as? Array<*>)?.filterIsInstance<String>() ?:emptyList(),expression=rs.getString("expression"))},tableId) constraints.right()} catch (e:Exception) {logger.error("Failed to find constraints for table:$tableId",e) TableError.DatabaseError(message="Failed to find constraints:${e.message}",sqlState=null,errorCode=null).left()} @Transactional override suspend fun delete(id:UUID):Either<TableError,Unit>=try {// First delete constraint columns jdbcTemplate.update("DELETE FROM table_constraint_column WHERE constraint_id=?",id) // Then delete the constraint val deleted=jdbcTemplate.update("DELETE FROM table_constraint WHERE id=?",id) if (deleted> 0) Unit.right() else TableError.ValidationError(message="Constraint not found",violations=listOf(TableError.Violation("id","No constraint found with this ID",id))).left()} catch (e:Exception) {logger.error("Failed to delete constraint:$id",e) TableError.DatabaseError(message="Failed to delete constraint:${e.message}",sqlState=null,errorCode=null).left()} override suspend fun validateConstraint(constraint:TableConstraint):Either<TableError,Unit>=when (constraint.type) {ConstraintType.UNIQUE->validateUniqueConstraint(constraint) ConstraintType.CHECK->validateCheckConstraint(constraint) ConstraintType.FOREIGN_KEY->validateForeignKeyConstraint(constraint)} private suspend fun validateUniqueConstraint(constraint:TableConstraint):Either<TableError,Unit>=try {val count=jdbcTemplate.queryForObject(""" SELECT COUNT(*) FROM (SELECT ${constraint.columns.joinToString(",")} FROM ${getTableName(constraint.tableId)} GROUP BY ${constraint.columns.joinToString(",")} HAVING COUNT(*)> 1) t """,Int::class.java) if (count == 0) Unit.right() else TableError.ValidationError(message="Unique constraint violation",violations=listOf(TableError.Violation("constraint","Duplicate values found",constraint.name))).left()} catch (e:Exception) {logger.error("Failed to validate unique constraint:${constraint.id}",e) TableError.DatabaseError(message="Failed to validate constraint:${e.message}",sqlState=null,errorCode=null).left()} private suspend fun validateCheckConstraint(constraint:TableConstraint):Either<TableError,Unit>=try {// Validate the check constraint expression jdbcTemplate.queryForObject(""" SELECT COUNT(*) FROM ${getTableName(constraint.tableId)} WHERE NOT (${constraint.expression}) """,Int::class.java)?.let {violations->if (violations == 0) Unit.right() else TableError.ValidationError(message="Check constraint violation",violations=listOf(TableError.Violation("constraint","$violations rows violate the check condition",constraint.name))).left()} ?:Unit.right()} catch (e:Exception) {logger.error("Failed to validate check constraint:${constraint.id}",e) TableError.DatabaseError(message="Failed to validate constraint:${e.message}",sqlState=null,errorCode=null).left()} private suspend fun validateForeignKeyConstraint(constraint:TableConstraint):Either<TableError,Unit>=try {// Implementation depends on your specific foreign key validation requirements Unit.right()} catch (e:Exception) {logger.error("Failed to validate foreign key constraint:${constraint.id}",e) TableError.DatabaseError(message="Failed to validate constraint:${e.message}",sqlState=null,errorCode=null).left()} private fun getTableName(tableId:UUID):String=jdbcTemplate.queryForObject("SELECT name FROM ad_table WHERE id=?",String::class.java,tableId) // Return non-nullable String directly} 
File: ./infrastructure/persistence/repositories/ProcessRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.blackerp.domain.core.ad.process.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import java.util.UUID @Repository class ProcessRepository :ProcessOperations {override suspend fun save(process:ADProcess):Either<ProcessError,ADProcess>=process.right() override suspend fun findById(id:UUID):Either<ProcessError,ADProcess?>=null.right() override suspend fun delete(id:UUID):Either<ProcessError,Unit>=Unit.right() override suspend fun execute(id:UUID,parameters:Map<String,Any>,async:Boolean):Either<ProcessError,ProcessResult>=ProcessResult(success=true,message="Process executed successfully").right() override suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADProcess>=flowOf() override suspend fun validateParameters(id:UUID,parameters:Map<String,Any>):Either<ProcessError,Map<String,List<String>>>=mapOf<String,List<String>>().right() override suspend fun getExecutionHistory(id:UUID,pageSize:Int,page:Int):Flow<ProcessExecution>=flowOf() override suspend fun schedule(id:UUID,schedule:ProcessSchedule):Either<ProcessError,ADProcess>=ProcessError.NotFound(id).left()} 
File: ./infrastructure/persistence/repositories/WindowRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID import kotlinx.coroutines.flow.* import org.blackerp.domain.core.ad.tab.ADTab import org.blackerp.domain.core.ad.window.* import org.blackerp.domain.core.error.WindowError import org.blackerp.domain.core.shared.AuditInfo import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.shared.VersionInfo import org.blackerp.domain.core.values.* import org.slf4j.LoggerFactory import org.springframework.jdbc.core.JdbcTemplate import org.springframework.stereotype.Repository import org.springframework.transaction.annotation.Transactional @Repository class WindowRepositoryImpl(private val jdbcTemplate:JdbcTemplate) :WindowRepository {private val logger=LoggerFactory.getLogger(WindowRepositoryImpl::class.java) @Transactional override suspend fun save(window:ADWindow):Either<WindowError,ADWindow>=try {logger.debug("Saving window:${window.id}") jdbcTemplate.update(""" INSERT INTO ad_window (id,name,display_name,description,is_active,is_sotrx,window_type) VALUES (?,?,?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET name=EXCLUDED.name,display_name=EXCLUDED.display_name,description=EXCLUDED.description,is_active=EXCLUDED.is_active,is_sotrx=EXCLUDED.is_sotrx,window_type=EXCLUDED.window_type """,window.id,window.name.value,window.displayName.value,window.description?.value,window.isActive,window.isSOTrx,window.windowType.name) saveTabs(window) window.right()} catch (e:Exception) {logger.error("Failed to save window:${window.id}",e) WindowError.ValidationFailed("Save failed:${e.message}").left()} private fun saveTabs(window:ADWindow) {// Delete existing tabs jdbcTemplate.update("DELETE FROM ad_tab WHERE window_id=?",window.id) window.tabs.forEach {tab->// Save tab jdbcTemplate.update(""" INSERT INTO ad_tab (id,window_id,name,display_name,description,table_id,sequence) VALUES (?,?,?,?,?,?,?) """,tab.id,window.id,tab.name.value,tab.displayName.value,tab.description?.value,tab.tableId,tab.sequence) // Save tab fields saveTabFields(tab)}} private fun findFieldsByTabId(tabId:UUID):List<WindowField> {return jdbcTemplate.query("SELECT * FROM ad_field WHERE tab_id=? ORDER BY sequence",{rs,_->WindowField(id=UUID.fromString(rs.getString("id")),columnName=rs.getString("column_name"),displayName=rs.getString("display_name"),description=rs.getString("description"),isDisplayed=rs.getBoolean("is_displayed"),isReadOnly=rs.getBoolean("is_readonly"),isMandatory=rs.getBoolean("is_mandatory"),sequence=rs.getInt("sequence"),displayLogic=rs.getString("display_logic"),defaultValue=rs.getString("default_value"),validationRule=rs.getString("validation_rule"))},tabId)} private fun saveTabFields(tab:ADTab) {// Delete existing fields jdbcTemplate.update("DELETE FROM ad_field WHERE tab_id=?",tab.id) tab.fields.forEach {field->jdbcTemplate.update(""" INSERT INTO ad_field (id,tab_id,column_name,display_name,description,is_displayed,is_readonly,is_mandatory,sequence,display_logic,default_value,validation_rule) VALUES (?,?,?,?,?,?,?,?,?,?,?,?) """,field.id,tab.id,field.columnName,field.displayName,field.description,field.isDisplayed,field.isReadOnly,field.isMandatory,field.sequence,field.displayLogic,field.defaultValue,field.validationRule)}} @Transactional override suspend fun delete(id:UUID):Either<WindowError,Unit>=try {val deleted=jdbcTemplate.update("DELETE FROM ad_window WHERE id=?",id) if (deleted> 0) Unit.right() else WindowError.NotFound(id).left()} catch (e:Exception) {logger.error("Failed to delete window:$id",e) WindowError.ValidationFailed("Delete failed:${e.message}").left()} override suspend fun findById(id:UUID):Either<WindowError,ADWindow?>=try {val window=jdbcTemplate.queryForObject(""" SELECT w.*,u1.username as created_by,u2.username as updated_by,w.version FROM ad_window w LEFT JOIN ad_user u1 ON w.created_by=u1.id LEFT JOIN ad_user u2 ON w.updated_by=u2.id WHERE w.id=? """,{rs,_->ADWindow(metadata=EntityMetadata(id=rs.getString("id"),audit=AuditInfo(createdBy=rs.getString("created_by"),updatedBy=rs.getString("updated_by")),version=VersionInfo(version=rs.getInt("version"))),displayName=DisplayName.create(rs.getString("display_name")) .orNull()!!,name=WindowName.create(rs.getString("name")) .orNull()!!,description=rs.getString("description")?.let {Description.create(it).orNull()},tabs=findTabsByWindowId(UUID.fromString(rs.getString("id"))),isActive=rs.getBoolean("is_active"),isSOTrx=rs.getBoolean("is_sotrx"),windowType=WindowType.valueOf(rs.getString("window_type")))},id) window.right()} catch (e:Exception) {logger.error("Failed to find window:$id",e) WindowError.NotFound(id).left()} override suspend fun findByName(name:WindowName):Either<WindowError,ADWindow?>=try {val window=jdbcTemplate.queryForObject(""" SELECT w.*,u1.username as created_by,u2.username as updated_by,w.version FROM ad_window w LEFT JOIN ad_user u1 ON w.created_by=u1.id LEFT JOIN ad_user u2 ON w.updated_by=u2.id WHERE w.name=? """,{rs,_->ADWindow(metadata=EntityMetadata(id=rs.getString("id"),audit=AuditInfo(createdBy=rs.getString("created_by"),updatedBy=rs.getString("updated_by")),version=VersionInfo(version=rs.getInt("version"))),displayName=DisplayName.create(rs.getString("display_name")) .orNull()!!,name=WindowName.create(rs.getString("name")) .orNull()!!,description=rs.getString("description")?.let {Description.create(it).orNull()},tabs=findTabsByWindowId(UUID.fromString(rs.getString("id"))),isActive=rs.getBoolean("is_active"),isSOTrx=rs.getBoolean("is_sotrx"),windowType=WindowType.valueOf(rs.getString("window_type")))},name.value) window.right()} catch (e:Exception) {logger.error("Failed to find window by name:${name.value}",e) null.right()} private fun findTabsByWindowId(windowId:UUID):List<ADTab> {return jdbcTemplate.query(""" SELECT t.*,u1.username as created_by,u2.username as updated_by,t.version FROM ad_tab t LEFT JOIN ad_user u1 ON t.created_by=u1.id LEFT JOIN ad_user u2 ON t.updated_by=u2.id WHERE t.window_id=? ORDER BY t.sequence """,{rs,_->ADTab(metadata=EntityMetadata(id=rs.getString("id"),audit=AuditInfo(createdBy=rs.getString("created_by"),updatedBy=rs.getString("updated_by")),version=VersionInfo(version=rs.getInt("version"))),displayName=DisplayName.create(rs.getString("display_name")).orNull()!!,name=TabName.create(rs.getString("name")).orNull()!!,description=rs.getString("description")?.let {Description.create(it).orNull()},tableId=UUID.fromString(rs.getString("table_id")),sequence=rs.getInt("sequence"),fields=findFieldsByTabId(UUID.fromString(rs.getString("id"))))},windowId)} override suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADWindow>=flow {val sql=""" SELECT w.*,u1.username as created_by,u2.username as updated_by,w.version FROM ad_window w LEFT JOIN ad_user u1 ON w.created_by=u1.id LEFT JOIN ad_user u2 ON w.updated_by=u2.id WHERE LOWER(w.name) LIKE LOWER(?) OR LOWER(w.display_name) LIKE LOWER(?) ORDER BY w.name LIMIT ? OFFSET ? """ val searchPattern="%$query%" val offset=page * pageSize try {jdbcTemplate.query(sql,{rs,_->ADWindow(metadata=EntityMetadata(id=rs.getString("id"),audit=AuditInfo(createdBy=rs.getString("created_by"),updatedBy=rs.getString("updated_by")),version=VersionInfo(version=rs.getInt("version"))),displayName=DisplayName.create(rs.getString("display_name")) .orNull()!!,name=WindowName.create(rs.getString("name")).orNull()!!,description=rs.getString("description")?.let {Description.create(it).orNull()},tabs=findTabsByWindowId(UUID.fromString(rs.getString("id"))),isActive=rs.getBoolean("is_active"),isSOTrx=rs.getBoolean("is_sotrx"),windowType=WindowType.valueOf(rs.getString("window_type")))},searchPattern,searchPattern,pageSize,offset) .forEach {window->emit(window)}} catch (e:Exception) {logger.error("Search failed for query:$query",e) // Let the flow complete empty rather than error}}} 
File: ./infrastructure/persistence/repositories/UserRepositoryImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID import org.blackerp.domain.core.security.* import org.blackerp.domain.core.security.events.UserEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import org.blackerp.infrastructure.persistence.entities.UserEntity import org.blackerp.infrastructure.persistence.mappers.UserMapper import org.slf4j.LoggerFactory import org.springframework.stereotype.Repository import org.springframework.transaction.annotation.Transactional @Repository class UserRepositoryImpl(private val springUserRepository:SpringUserRepository,private val userMapper:UserMapper,private val eventPublisher:DomainEventPublisher) :UserRepository {private val logger=LoggerFactory.getLogger(UserRepositoryImpl::class.java) @Transactional(readOnly=true) override suspend fun findByUsername(username:String):Either<SecurityError,User?>=try {springUserRepository.findByUsername(username) ?.let {entity->userMapper.toDomain(entity).right()} ?:null.right()} catch (e:Exception) {logger.error("Error finding user by username:$username",e) SecurityError.UserNotFound("User not found:$username").left()} @Transactional(readOnly=true) override suspend fun findById(id:UUID):Either<SecurityError,User?>=try {springUserRepository .findById(id) .map {entity->userMapper.toDomain(entity)} .orElse(null) .right()} catch (e:Exception) {logger.error("Error finding user by id:$id",e) SecurityError.UserNotFound("User not found:$id").left()} @Transactional override suspend fun save(user:User):Either<SecurityError,User>=try {val existingUser=user.id?.let {springUserRepository.findById(it).orElse(null)} val entity=if (existingUser != null) {userMapper.updateEntity(existingUser,user)} else {userMapper.toEntity(user)} val savedEntity=springUserRepository.save(entity) val savedUser=userMapper.toDomain(savedEntity) // Publish event val event=if (existingUser == null) {UserEvent.UserCreated(metadata=EventMetadata(user="system",correlationId=UUID.randomUUID().toString()),user=savedUser)} else {UserEvent.UserUpdated(metadata=EventMetadata(user="system",correlationId=UUID.randomUUID().toString()),user=savedUser)} eventPublisher.publish(event) savedUser.right()} catch (e:Exception) {logger.error("Error saving user:${user.id}",e) SecurityError.ValidationFailed("Failed to save user:${e.message}").left()}} 
File: ./infrastructure/persistence/repositories/RelationshipRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.slf4j.LoggerFactory import org.springframework.dao.DataIntegrityViolationException @Repository class RelationshipRepository(private val jdbcTemplate:JdbcTemplate) :RelationshipOperations {private val logger=LoggerFactory.getLogger(RelationshipRepository::class.java) @Transactional override suspend fun save(relationship:TableRelationship):Either<TableError,TableRelationship>=try {logger.debug("Saving relationship:${relationship.id}") jdbcTemplate.update(""" INSERT INTO table_relationship (id,source_table_id,target_table_id,relationship_type,source_column,target_column,on_delete,on_update) VALUES (?,?,?,?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET relationship_type=EXCLUDED.relationship_type,source_column=EXCLUDED.source_column,target_column=EXCLUDED.target_column,on_delete=EXCLUDED.on_delete,on_update=EXCLUDED.on_update """,relationship.id,relationship.sourceTable,relationship.targetTable,relationship.type.name,relationship.sourceColumn,relationship.targetColumn,relationship.onDelete.name,relationship.onUpdate.name) relationship.right()} catch (e:DataIntegrityViolationException) {logger.error("Constraint violation while saving relationship:${relationship.id}",e) TableError.ValidationError(message="Constraint violation:${e.message}",violations=listOf(TableError.Violation("relationship","Database constraint violation",null))).left()} catch (e:Exception) {logger.error("Failed to save relationship:${relationship.id}",e) TableError.DatabaseError(message="Failed to save relationship:${e.message}",sqlState=null,errorCode=null).left()} override suspend fun findBySourceTable(tableId:UUID):Either<TableError,List<TableRelationship>>=try {val relationships=jdbcTemplate.query(""" SELECT id,source_table_id,target_table_id,relationship_type,source_column,target_column,on_delete,on_update FROM table_relationship WHERE source_table_id=? """,{rs,_->TableRelationship(id=UUID.fromString(rs.getString("id")),sourceTable=UUID.fromString(rs.getString("source_table_id")),targetTable=UUID.fromString(rs.getString("target_table_id")),type=RelationshipType.valueOf(rs.getString("relationship_type")),sourceColumn=rs.getString("source_column"),targetColumn=rs.getString("target_column"),onDelete=CascadeType.valueOf(rs.getString("on_delete")),onUpdate=CascadeType.valueOf(rs.getString("on_update")))},tableId) relationships.right()} catch (e:Exception) {logger.error("Failed to find relationships for table:$tableId",e) TableError.DatabaseError(message="Failed to find relationships:${e.message}",sqlState=null,errorCode=null).left()} override suspend fun findByTargetTable(tableId:UUID):Either<TableError,List<TableRelationship>>=try {val relationships=jdbcTemplate.query(""" SELECT id,source_table_id,target_table_id,relationship_type,source_column,target_column,on_delete,on_update FROM table_relationship WHERE target_table_id=? """,{rs,_->TableRelationship(id=UUID.fromString(rs.getString("id")),sourceTable=UUID.fromString(rs.getString("source_table_id")),targetTable=UUID.fromString(rs.getString("target_table_id")),type=RelationshipType.valueOf(rs.getString("relationship_type")),sourceColumn=rs.getString("source_column"),targetColumn=rs.getString("target_column"),onDelete=CascadeType.valueOf(rs.getString("on_delete")),onUpdate=CascadeType.valueOf(rs.getString("on_update")))},tableId) relationships.right()} catch (e:Exception) {logger.error("Failed to find relationships for target table:$tableId",e) TableError.DatabaseError(message="Failed to find relationships:${e.message}",sqlState=null,errorCode=null).left()} @Transactional override suspend fun delete(id:UUID):Either<TableError,Unit>=try {val deleted=jdbcTemplate.update("DELETE FROM table_relationship WHERE id=?",id) if (deleted> 0) Unit.right() else TableError.ValidationError(message="Relationship not found",violations=listOf(TableError.Violation("id","No relationship found with this ID",id))).left()} catch (e:Exception) {logger.error("Failed to delete relationship:$id",e) TableError.DatabaseError(message="Failed to delete relationship:${e.message}",sqlState=null,errorCode=null).left()}} 
File: ./infrastructure/persistence/repositories/SpringUserRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import java.util.UUID import org.blackerp.infrastructure.persistence.entities.UserEntity import org.springframework.data.jpa.repository.JpaRepository import org.springframework.stereotype.Repository @Repository interface SpringUserRepository :JpaRepository<UserEntity,UUID> {fun findByUsername(username:String):UserEntity? fun existsByUsername(username:String):Boolean} 
File: ./infrastructure/persistence/repositories/DocumentRepositoryImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import arrow.core.Either import arrow.core.left import arrow.core.right import java.sql.ResultSet import java.util.UUID import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flow import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.shared.AuditInfo import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.events.DocumentEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import org.slf4j.LoggerFactory import org.springframework.jdbc.core.JdbcTemplate import org.springframework.jdbc.core.RowMapper import org.springframework.stereotype.Repository import org.springframework.transaction.annotation.Transactional @Repository class DocumentRepositoryImpl(private val jdbcTemplate:JdbcTemplate,private val eventPublisher:DomainEventPublisher) :DocumentOperations {private val logger=LoggerFactory.getLogger(DocumentRepositoryImpl::class.java) private val documentMapper=RowMapper<Document> {rs:ResultSet,_:Int->Document.create(metadata=EntityMetadata(id=rs.getString("id"),audit=AuditInfo(createdBy=rs.getString("created_by"),updatedBy=rs.getString("updated_by"))),displayName=DisplayName.create(rs.getString("display_name")).orNull()!!,description=rs.getString("description")?.let {Description.create(it).orNull()},type=loadDocumentType(UUID.fromString(rs.getString("type_id"))),status=DocumentStatus.valueOf(rs.getString("status")))} @Transactional override suspend fun create(document:Document):Either<DocumentError,Document> {logger.debug("Creating document:${document.id}") try {jdbcTemplate.update(""" INSERT INTO ad_document (id,type_id,display_name,description,status,created_by,created_at,updated_by,updated_at) VALUES (?,?,?,?,?,?,CURRENT_TIMESTAMP,?,CURRENT_TIMESTAMP) """,document.id,document.type.id,document.displayName.value,document.description?.value,document.status.name,document.metadata.audit.createdBy,document.metadata.audit.updatedBy) saveAttributes(UUID.fromString(document.id),document.attributes) publishDocumentCreated(document) return document.right()} catch (e:Exception) {logger.error("Failed to create document:${document.id}",e) return DocumentError.ValidationFailed("Failed to create document:${e.message}") .left()}} private fun saveAttributes(documentId:UUID,attributes:Map<String,Any>) {attributes.forEach {(key,value)->jdbcTemplate.update(""" INSERT INTO ad_document_attribute (document_id,name,value,created_by,created_at) VALUES (?,?,?,'system',CURRENT_TIMESTAMP) ON CONFLICT (document_id,name) DO UPDATE SET value=EXCLUDED.value """,documentId,key,value.toString())}} override suspend fun update(id:UUID,document:Document):Either<DocumentError,Document> {logger.debug("Updating document:$id") try {val updated=jdbcTemplate.update(""" UPDATE ad_document SET display_name=?,description=?,status=?,updated_by=?,updated_at=CURRENT_TIMESTAMP WHERE id=? """,document.displayName.value,document.description?.value,document.status.name,document.metadata.audit.updatedBy,id) if (updated == 0) {return DocumentError.NotFound(id).left()} jdbcTemplate.update("DELETE FROM ad_document_attribute WHERE document_id=?",id) saveAttributes(id,document.attributes) publishDocumentUpdated(document) return document.right()} catch (e:Exception) {logger.error("Failed to update document:$id",e) return DocumentError.ValidationFailed("Failed to update document:${e.message}") .left()}} override suspend fun findById(id:UUID):Either<DocumentError,Document?> {try {return jdbcTemplate .query(""" SELECT d.*,dt.name as type_name,dt.display_name as type_display_name FROM ad_document d JOIN ad_document_type dt ON d.type_id=dt.id WHERE d.id=? """,documentMapper,id) .firstOrNull() .right()} catch (e:Exception) {logger.error("Failed to find document:$id",e) return DocumentError.ValidationFailed("Failed to find document:${e.message}") .left()}} override suspend fun search(criteria:SearchCriteria):Flow<Document>=flow {val conditions=mutableListOf<String>() val params=mutableListOf<Any>() criteria.types?.let {typesList->conditions.add("d.type_id IN ${typesList.joinToString(",","(",")") {"?"}}") params.addAll(typesList)} criteria.statuses?.let {statusList->conditions.add("d.status IN ${statusList.joinToString(",","(",")") {"?"}}") params.addAll(statusList.map {it.name})} criteria.dateRange?.let {dateRange->conditions.add("d.created_at BETWEEN ? AND ?") params.add(dateRange.from) params.add(dateRange.to)} val whereClause=if (conditions.isNotEmpty()) {"WHERE ${conditions.joinToString(" AND ")}"} else "" val sql=""" SELECT d.*,dt.name as type_name,dt.display_name as type_display_name FROM ad_document d JOIN ad_document_type dt ON d.type_id=dt.id $whereClause ORDER BY d.created_at DESC LIMIT ? OFFSET ? """ params.add(criteria.pageSize) params.add(criteria.pageSize * criteria.page) jdbcTemplate.query(sql,documentMapper,*params.toTypedArray()).forEach {emit(it)}} @Transactional override suspend fun delete(id:UUID):Either<DocumentError,Unit> {try {jdbcTemplate.update("DELETE FROM ad_document_attribute WHERE document_id=?",id) val deleted=jdbcTemplate.update("DELETE FROM ad_document WHERE id=?",id) return if (deleted> 0) Unit.right() else DocumentError.NotFound(id).left()} catch (e:Exception) {logger.error("Failed to delete document:$id",e) return DocumentError.ValidationFailed("Failed to delete document:${e.message}") .left()}} @Transactional override suspend fun changeStatus(id:UUID,status:DocumentStatus):Either<DocumentError,Document> {try {return findById(id) .fold({error->error.left()},{document->document?.let {doc->doc.validateStatusTransition(status).map {jdbcTemplate.update(""" UPDATE ad_document SET status=?,updated_by=?,updated_at=CURRENT_TIMESTAMP WHERE id=? """,status.name,doc.metadata .audit .updatedBy,id) doc.copy(status=status)}} ?:DocumentError.NotFound(id).left()})} catch (e:Exception) {logger.error("Failed to change status:$id",e) return DocumentError.ValidationFailed("Failed to change status:${e.message}") .left()}} override suspend fun getHistory(id:UUID):Flow<DocumentChange>=flow {try {val sql=""" SELECT * FROM ad_document_history WHERE document_id=? ORDER BY changed_at DESC """ jdbcTemplate.query(sql,{rs,_->DocumentChange(id=UUID.fromString(rs.getString("id")),documentId=UUID.fromString(rs.getString("document_id")),changedAt=rs.getTimestamp("changed_at") .toInstant(),changedBy=rs.getString("changed_by"),changes=mapOf() // TODO:Deserialize changes // from JSON)},id) .forEach {emit(it)}} catch (e:Exception) {logger.error("Failed to get document history:$id",e)}} private fun publishDocumentCreated(document:Document) {eventPublisher.publish(DocumentEvent.DocumentCreated(metadata=EventMetadata(user=document.metadata.audit.createdBy,correlationId=UUID.randomUUID().toString()),documentId=UUID.fromString(document.metadata.id),type=document.type.name,status=document.status))} private fun publishDocumentUpdated(document:Document) {eventPublisher.publish(DocumentEvent.DocumentModified(metadata=EventMetadata(user=document.metadata.audit.updatedBy,correlationId=UUID.randomUUID().toString()),documentId=UUID.fromString(document.metadata.id),changes=mapOf() // TODO:Track actual changes))} private fun loadDocumentType(typeId:UUID):DocumentType {return jdbcTemplate.queryForObject(""" SELECT * FROM ad_document_type WHERE id=? """.trimIndent(),arrayOf(typeId),{rs:ResultSet,_:Int->DocumentType(metadata=EntityMetadata(id=rs.getString("id"),audit=AuditInfo(createdBy=rs.getString("created_by"),updatedBy=rs.getString("updated_by"))),displayName=DisplayName.create(rs.getString("display_name")) .orNull()!!,description=rs.getString("description")?.let {Description.create(it).orNull()},name=rs.getString("name"),baseTableId=UUID.fromString(rs.getString("base_table_id")),linesTableId=rs.getString("lines_table_id")?.let {UUID.fromString(it)},workflowId=rs.getString("workflow_id")?.let {UUID.fromString(it)},statusConfig=loadStatusConfig(typeId),isSOTrx=rs.getBoolean("is_sotrx"),isActive=rs.getBoolean("is_active"))}) ?:throw IllegalStateException("Document type not found:$typeId")} private fun loadStatusConfig(typeId:UUID):DocumentStatusConfig {val statuses=jdbcTemplate.query(""" SELECT * FROM ad_doc_status WHERE type_id=? """,{rs:ResultSet,_:Int->DocumentStatusDef(code=rs.getString("code"),name=rs.getString("name"),description=rs.getString("description"),nextStatuses=loadNextStatuses(rs.getString("code")))},typeId) .associateBy {it.code} return DocumentStatusConfig(statuses=statuses,defaultStatus=jdbcTemplate.queryForObject("SELECT default_status FROM ad_document_type WHERE id=?",String::class.java,typeId)!!,closingStatuses=loadClosingStatuses(typeId))} private fun loadNextStatuses(statusCode:String):Set<String> {val sql="SELECT to_status FROM ad_doc_status_transition WHERE from_status=?" return jdbcTemplate .query(sql,arrayOf(statusCode)) {rs,_->rs.getString("to_status")} .toSet()} private fun loadClosingStatuses(typeId:UUID):Set<String> {val sql="SELECT code FROM ad_doc_status WHERE type_id=? AND is_closing=true" return jdbcTemplate .query(sql,arrayOf(typeId)) {rs,_->rs.getString("code")} .toSet()}} 
File: ./infrastructure/persistence/metadata/MetadataConfig.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.metadata import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Bean import org.springframework.jdbc.core.JdbcTemplate import javax.sql.DataSource @Configuration class MetadataConfig {@Bean fun jdbcTemplate(dataSource:DataSource)=JdbcTemplate(dataSource)} 
File: ./infrastructure/persistence/metadata/repositories/JdbcMetadataRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.metadata.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.metadata.entities.* import org.blackerp.domain.core.ad.metadata.repositories.MetadataRepository import org.blackerp.domain.core.ad.metadata.services.MetadataError import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.shared.AuditInfo import org.blackerp.domain.core.values.* import arrow.core.Either import arrow.core.left import arrow.core.right import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flow import java.util.UUID import org.slf4j.LoggerFactory @Repository class JdbcMetadataRepository(private val jdbcTemplate:JdbcTemplate) :MetadataRepository {private val logger=LoggerFactory.getLogger(JdbcMetadataRepository::class.java) @Transactional override suspend fun <T :Any> save(entity:T):Either<MetadataError,T>=try {when (entity) {is ADRule->saveRule(entity) is ADValidationRule->saveValidationRule(entity) is ADStatusLine->saveStatusLine(entity) else->throw IllegalArgumentException("Unsupported entity type")}.map {entity}} catch (e:Exception) {logger.error("Failed to save metadata entity",e) MetadataError.ValidationFailed("Save failed:${e.message}").left()} private suspend fun saveRule(rule:ADRule):Either<MetadataError,Unit> {jdbcTemplate.update(""" INSERT INTO ad_rule (id,display_name,description,rule_type,entity_type,expression,error_message,is_active,created_by,updated_by) VALUES (?,?,?,?,?,?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET display_name=EXCLUDED.display_name,description=EXCLUDED.description,rule_type=EXCLUDED.rule_type,entity_type=EXCLUDED.entity_type,expression=EXCLUDED.expression,error_message=EXCLUDED.error_message,is_active=EXCLUDED.is_active,updated_by=EXCLUDED.updated_by,updated_at=CURRENT_TIMESTAMP """,rule.id,rule.displayName.value,rule.description?.value,rule.ruleType,rule.entityType,rule.expression,rule.errorMessage,true,rule.metadata.audit.createdBy,rule.metadata.audit.updatedBy) // Save parameters rule.parameters.forEach {param->jdbcTemplate.update(""" INSERT INTO ad_rule_parameter (rule_id,name,data_type,mandatory,default_value) VALUES (?,?,?,?,?) ON CONFLICT (rule_id,name) DO UPDATE SET data_type=EXCLUDED.data_type,mandatory=EXCLUDED.mandatory,default_value=EXCLUDED.default_value """,rule.id,param.name,param.dataType.name,param.mandatory,param.defaultValue)} return Unit.right()} override suspend fun <T :Any> findById(id:UUID,type:Class<T>):Either<MetadataError,T?>=try {when (type) {ADRule::class.java->findRuleById(id) ADValidationRule::class.java->findValidationRuleById(id) ADStatusLine::class.java->findStatusLineById(id) else->throw IllegalArgumentException("Unsupported entity type")}.map {it as T}} catch (e:Exception) {logger.error("Failed to find metadata entity",e) MetadataError.NotFound("Entity not found:$id").left()} override suspend fun findRulesByType(entityType:String):Flow<ADRule>=flow {val sql=""" SELECT r.*,rp.name as param_name,rp.data_type as param_type,rp.mandatory as param_mandatory,rp.default_value as param_default FROM ad_rule r LEFT JOIN ad_rule_parameter rp ON r.id=rp.rule_id WHERE r.entity_type=? AND r.is_active=true ORDER BY r.id """ jdbcTemplate.query(sql,{rs,_->ADRule(metadata=EntityMetadata(id=rs.getString("id"),audit=AuditInfo(createdBy=rs.getString("created_by"),updatedBy=rs.getString("updated_by"))),displayName=DisplayName.create(rs.getString("display_name")).orNull()!!,description=rs.getString("description")?.let {Description.create(it).orNull()},ruleType=rs.getString("rule_type"),entityType=rs.getString("entity_type"),expression=rs.getString("expression"),errorMessage=rs.getString("error_message"),parameters=buildParameters(rs))},entityType).forEach {emit(it)}} private fun buildParameters(rs:java.sql.ResultSet):List<RuleParameter> {val paramName=rs.getString("param_name") ?:return emptyList() return listOf(RuleParameter(name=paramName,dataType=DataType.valueOf(rs.getString("param_type")),mandatory=rs.getBoolean("param_mandatory"),defaultValue=rs.getString("param_default")))} // Similar implementations for validation rules and status lines... // Keeping focused on core rule metadata first for POC} 
File: ./infrastructure/database/h2/init.sql
-------------------------------------------
-- H2 schema content from above 
File: ./infrastructure/database/migration/V2__Create_Document_Tables.sql
-------------------------------------------
-- Document Type Definition CREATE TABLE ad_document_type (id UUID PRIMARY KEY,name VARCHAR(100) NOT NULL UNIQUE,display_name VARCHAR(255) NOT NULL,description TEXT,base_table_id UUID NOT NULL,lines_table_id UUID,workflow_id UUID,default_status VARCHAR(10) NOT NULL,is_sotrx BOOLEAN DEFAULT false,is_active BOOLEAN DEFAULT true,created_by UUID NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,updated_by UUID NOT NULL,updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,version INT NOT NULL DEFAULT 1);-- Document Status Definition CREATE TABLE ad_doc_status (code VARCHAR(10) NOT NULL,type_id UUID NOT NULL REFERENCES ad_document_type(id),name VARCHAR(100) NOT NULL,description TEXT,is_default BOOLEAN DEFAULT false,is_closing BOOLEAN DEFAULT false,sequence INT NOT NULL DEFAULT 10,created_by UUID NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,updated_by UUID NOT NULL,updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,version INT NOT NULL DEFAULT 1,PRIMARY KEY (code,type_id));-- Document Status Transitions CREATE TABLE ad_doc_status_transition (id UUID PRIMARY KEY,type_id UUID NOT NULL REFERENCES ad_document_type(id),from_status VARCHAR(10) NOT NULL,to_status VARCHAR(10) NOT NULL,role_id UUID,condition_expr TEXT,created_by UUID NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,updated_by UUID NOT NULL,updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,version INT NOT NULL DEFAULT 1,FOREIGN KEY (type_id,from_status) REFERENCES ad_doc_status(type_id,code),FOREIGN KEY (type_id,to_status) REFERENCES ad_doc_status(type_id,code));-- Document Records CREATE TABLE ad_document (id UUID PRIMARY KEY,type_id UUID NOT NULL REFERENCES ad_document_type(id),display_name VARCHAR(255) NOT NULL,description TEXT,status VARCHAR(10) NOT NULL,created_by UUID NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,updated_by UUID NOT NULL,updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,version INT NOT NULL DEFAULT 1);-- Document Attributes (Key-Value Store) CREATE TABLE ad_document_attribute (document_id UUID NOT NULL REFERENCES ad_document(id),name VARCHAR(100) NOT NULL,value TEXT NOT NULL,created_by UUID NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,PRIMARY KEY (document_id,name));-- Document Change History CREATE TABLE ad_document_history (id UUID PRIMARY KEY,document_id UUID NOT NULL REFERENCES ad_document(id),changed_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,changed_by UUID NOT NULL,previous_status VARCHAR(10),new_status VARCHAR(10),changes JSONB NOT NULL,reason TEXT);-- Indexes for Performance CREATE INDEX idx_doc_type_name ON ad_document_type(name);CREATE INDEX idx_doc_status ON ad_document(status);CREATE INDEX idx_doc_type ON ad_document(type_id);CREATE INDEX idx_doc_history ON ad_document_history(document_id,changed_at);CREATE INDEX idx_doc_attribute ON ad_document_attribute(document_id);
File: ./infrastructure/database/migration/V3__Create_Metadata_Tables.sql
-------------------------------------------
-- AD Rule table CREATE TABLE ad_rule (id UUID PRIMARY KEY,display_name VARCHAR(100) NOT NULL,description TEXT,rule_type VARCHAR(20) NOT NULL,entity_type VARCHAR(40) NOT NULL,expression TEXT NOT NULL,error_message TEXT,is_active BOOLEAN DEFAULT true,created_by UUID NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,updated_by UUID NOT NULL,updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,version INT NOT NULL DEFAULT 1);-- AD Rule Parameters CREATE TABLE ad_rule_parameter (rule_id UUID NOT NULL REFERENCES ad_rule(id),name VARCHAR(40) NOT NULL,data_type VARCHAR(20) NOT NULL,mandatory BOOLEAN DEFAULT false,default_value TEXT,PRIMARY KEY (rule_id,name));-- AD Validation Rule table CREATE TABLE ad_validation_rule (id UUID PRIMARY KEY,display_name VARCHAR(100) NOT NULL,description TEXT,entity_type VARCHAR(40) NOT NULL,field_name VARCHAR(40) NOT NULL,expression TEXT NOT NULL,error_message TEXT NOT NULL,is_active BOOLEAN DEFAULT true,created_by UUID NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,updated_by UUID NOT NULL,updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,version INT NOT NULL DEFAULT 1);-- AD Status Line table CREATE TABLE ad_status_line (id UUID PRIMARY KEY,display_name VARCHAR(100) NOT NULL,description TEXT,document_type VARCHAR(40) NOT NULL,from_status VARCHAR(40) NOT NULL,to_status VARCHAR(40) NOT NULL,role_id UUID,sequence INT NOT NULL DEFAULT 0,is_active BOOLEAN DEFAULT true,created_by UUID NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,updated_by UUID NOT NULL,updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,version INT NOT NULL DEFAULT 1);-- AD Status Line Conditions CREATE TABLE ad_status_line_condition (status_line_id UUID NOT NULL REFERENCES ad_status_line(id),rule_id UUID NOT NULL REFERENCES ad_rule(id),sequence INT NOT NULL DEFAULT 0,PRIMARY KEY (status_line_id,rule_id));-- Indexes CREATE INDEX idx_rule_type ON ad_rule(rule_type);CREATE INDEX idx_rule_entity ON ad_rule(entity_type);CREATE INDEX idx_validation_entity ON ad_validation_rule(entity_type);CREATE INDEX idx_status_document ON ad_status_line(document_type);CREATE INDEX idx_status_from ON ad_status_line(from_status);CREATE INDEX idx_status_to ON ad_status_line(to_status);
File: ./infrastructure/database/migration/V1__Create_User_Tables.sql
-------------------------------------------
CREATE TABLE ad_user (id UUID PRIMARY KEY,username VARCHAR(100) UNIQUE NOT NULL,email VARCHAR(255) NOT NULL,password_hash VARCHAR(255) NOT NULL,is_active BOOLEAN DEFAULT TRUE,client_id UUID NOT NULL,organization_id UUID,last_login TIMESTAMP,created_at TIMESTAMP NOT NULL,updated_at TIMESTAMP NOT NULL);CREATE TABLE ad_user_role (user_id UUID NOT NULL REFERENCES ad_user(id),role_id UUID NOT NULL,PRIMARY KEY (user_id,role_id));CREATE INDEX idx_user_username ON ad_user(username);CREATE INDEX idx_user_client ON ad_user(client_id);CREATE INDEX idx_user_org ON ad_user(organization_id);
File: ./infrastructure/plugin/registry/PluginRegistryImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.plugin.registry import org.springframework.stereotype.Component import org.blackerp.domain.core.plugin.* import org.blackerp.domain.core.error.PluginError import arrow.core.Either import arrow.core.right import arrow.core.left import org.slf4j.LoggerFactory @Component class PluginRegistryImpl :PluginRegistry {private val logger=LoggerFactory.getLogger(PluginRegistryImpl::class.java) private val plugins=mutableMapOf<String,PluginDefinition>() private val pluginContext=object :PluginContext {override fun getPlugin(id:String)=plugins[id] override fun getConfiguration(key:String):String?=null // TODO:Implement configuration} override suspend fun register(plugin:PluginDefinition):Either<PluginError,Unit>=try {plugins[plugin.id]=plugin Unit.right()} catch (e:Exception) {logger.error("Failed to register plugin:${plugin.id}",e) PluginError.RegistrationFailed(plugin.id,e).left()} override suspend fun getPlugin(id:String):Either<PluginError,PluginDefinition?>=Either.catch {plugins[id]} .mapLeft {PluginError.LoadFailed("Failed to get plugin $id:${it.message}")} override suspend fun loadPlugins():Either<PluginError,Unit>=Either.catch {// TODO:Implement plugin discovery and loading Unit}.mapLeft {PluginError.LoadFailed(it.message ?:"Unknown error during plugin loading")} override suspend fun startPlugin(id:String):Either<PluginError,Unit>=getPlugin(id).flatMap {plugin->Either.catch {plugin?.start() Unit}.mapLeft {PluginError.StartupFailed(id,it)}} override suspend fun stopPlugin(id:String):Either<PluginError,Unit>=getPlugin(id).flatMap {plugin->Either.catch {plugin?.stop() Unit}.mapLeft {PluginError.ShutdownFailed(id,it)}}} 
File: ./infrastructure/process/executor/ProcessExecutorImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.process.executor import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.error.ProcessError import org.blackerp.infrastructure.process.tracking.ProcessExecutionTracker import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import java.util.UUID import java.time.Instant import kotlinx.coroutines.withContext import kotlinx.coroutines.Dispatchers import org.springframework.transaction.annotation.Transactional @Component class ProcessExecutorImpl(private val processOperations:ProcessOperations,private val executionTracker:ProcessExecutionTracker) {private val logger=LoggerFactory.getLogger(ProcessExecutorImpl::class.java) @Transactional suspend fun execute(processId:UUID,parameters:Map<String,Any>,async:Boolean=false):Either<ProcessError,ProcessResult>=withContext(Dispatchers.IO) {try {logger.info("Executing process:$processId with parameters:$parameters") val executionId=UUID.randomUUID() val startTime=Instant.now() val result=executeProcess(processId,parameters) // Track execution trackExecution(processId=processId,executionId=executionId,parameters=parameters,result=result,startTime=startTime,endTime=Instant.now()) result.right()} catch (e:Exception) {logger.error("Process execution failed",e) ProcessError.ExecutionFailed(e.message ?:"Unknown error").left()}} private suspend fun executeProcess(processId:UUID,parameters:Map<String,Any>):ProcessResult {// For POC,simulate process execution return ProcessResult(success=true,message="Process executed successfully",data=mapOf("processId" to processId.toString(),"executionTime" to Instant.now().toString()))} private fun trackExecution(processId:UUID,executionId:UUID,parameters:Map<String,Any>,result:ProcessResult,startTime:Instant,endTime:Instant) {val execution=ProcessExecution(id=executionId,processId=processId,startTime=startTime,endTime=endTime,status=if (result.success) ExecutionStatus.COMPLETED else ExecutionStatus.FAILED,parameters=parameters,result=result,user="system" // TODO:Replace with actual user from security context) executionTracker.trackExecution(processId,execution) logger.debug("Tracked execution $executionId for process $processId")}} 
File: ./infrastructure/process/validation/ParameterValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.process.validation import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.error.ProcessError import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory @Component class ParameterValidator {private val logger=LoggerFactory.getLogger(ParameterValidator::class.java) fun validate(parameters:Map<String,Any>,expectedParameters:List<ProcessParameter>):Either<ProcessError,Map<String,Any>> {val errors=mutableListOf<String>() // Check required parameters expectedParameters.filter {it.isMandatory} .forEach {param->if (!parameters.containsKey(param.name)) {errors.add("Missing required parameter:${param.name}")}} // Validate parameter types parameters.forEach {(name,value)->expectedParameters.find {it.name == name}?.let {param->if (!isValidType(value,param.parameterType)) {errors.add("Invalid type for parameter $name:expected ${param.parameterType}")}} ?:errors.add("Unexpected parameter:$name")} return if (errors.isEmpty()) {parameters.right()} else {ProcessError.ValidationFailed(errors.joinToString(",")).left()}} private fun isValidType(value:Any,type:ParameterType):Boolean=when(type) {ParameterType.STRING->value is String ParameterType.NUMBER->value is Number ParameterType.DATE->value is java.time.temporal.Temporal ParameterType.BOOLEAN->value is Boolean ParameterType.REFERENCE->true // TODO:Implement reference validation ParameterType.FILE->true // TODO:Implement file validation}} 
File: ./infrastructure/process/tracking/ProcessExecutionTracker.kt
-------------------------------------------
package org.blackerp.infrastructure.process.tracking import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.process.* import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Component class ProcessExecutionTracker {private val logger=LoggerFactory.getLogger(ProcessExecutionTracker::class.java) // In-memory tracking for POC private val executionHistory=mutableMapOf<UUID,ProcessExecution>() fun trackExecution(processId:UUID,execution:ProcessExecution) {executionHistory[execution.id]=execution logger.info("Tracked execution:${execution.id} for process:$processId")} fun getExecutionHistory(processId:UUID):List<ProcessExecution>=executionHistory.values .filter {it.processId == processId} .sortedByDescending {it.startTime}} 
File: ./infrastructure/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") version "1.9.20" kotlin("plugin.spring") id("org.springframework.boot")} tasks.bootJar {enabled=false} tasks.jar {enabled=true} sourceSets {main {kotlin.srcDirs("persistence/repositories","cache/providers","integration/adapters","messaging/consumers","persistence/entities","persistence/mappers","events/publishers","plugin/loaders")}} dependencies {implementation("org.springframework.boot:spring-boot-starter-actuator:3.2.0") implementation(project(":domain")) // Only depends on domain implementation("org.springframework.boot:spring-boot-starter-data-jpa") implementation("com.h2database:h2") implementation("org.flywaydb:flyway-core")} 
File: ./infrastructure/core/logging/DomainLogger.kt
-------------------------------------------
package org.blackerp.infrastructure.core.logging import org.slf4j.LoggerFactory object DomainLogger {fun getLogger(name:String)=LoggerFactory.getLogger(name)} 
File: ./infrastructure/audit/AuditLoggerImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.audit import org.springframework.stereotype.Component import org.blackerp.domain.core.audit.AuditLog import org.blackerp.domain.core.audit.AuditLogger import java.time.Instant import java.util.UUID import org.slf4j.LoggerFactory @Component class AuditLoggerImpl :AuditLogger {private val logger=LoggerFactory.getLogger(AuditLoggerImpl::class.java) // In-memory storage for POC private val auditLogs=mutableListOf<AuditLog>() override suspend fun log(entry:AuditLog) {auditLogs.add(entry) logger.info("Audit log created:${entry.action} on ${entry.entityType}:${entry.entityId}")} override suspend fun getAuditTrail(entityType:String,entityId:UUID,fromDate:Instant?,toDate:Instant?):List<AuditLog>=auditLogs .filter {log->log.entityType == entityType && log.entityId == entityId && (fromDate == null || log.timestamp>= fromDate) && (toDate == null || log.timestamp <= toDate)} .sortedByDescending {it.timestamp}} 
File: ./infrastructure/validation/validators/CircularReferenceValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.table.TableRelationship import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID @Component class CircularReferenceValidator {fun validate(relationship:TableRelationship,existingRelationships:List<TableRelationship>):Either<TableError,TableRelationship> {val visited=mutableSetOf<UUID>() val path=mutableListOf<UUID>() fun hasCircularReference(currentTable:UUID):Boolean {if (path.contains(currentTable)) {return true} if (!visited.add(currentTable)) {return false} path.add(currentTable) val relatedTables=existingRelationships .filter {it.sourceTable == currentTable} .map {it.targetTable} relatedTables.forEach {targetTable->if (hasCircularReference(targetTable)) {return true}} path.removeAt(path.size - 1) return false} return if (hasCircularReference(relationship.sourceTable)) {TableError.ValidationError(message="Circular reference detected",violations=listOf(TableError.Violation(field="relationship",message="Creating this relationship would create a circular reference",value="${relationship.sourceTable}->${relationship.targetTable}"))).left()} else {relationship.right()}}} 
File: ./infrastructure/validation/validators/ConstraintValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.table.TableConstraint import org.blackerp.domain.core.ad.table.ConstraintType import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.left import arrow.core.right @Component class ConstraintValidator {fun validate(constraint:TableConstraint):Either<TableError,TableConstraint> {val violations=mutableListOf<TableError.Violation>() when (constraint.type) {ConstraintType.UNIQUE->validateUniqueConstraint(constraint,violations) ConstraintType.CHECK->validateCheckConstraint(constraint,violations) ConstraintType.FOREIGN_KEY->validateForeignKeyConstraint(constraint,violations)} // Common validations if (!isValidConstraintName(constraint.name)) {violations.add(TableError.Violation(field="name",message="Constraint name must start with lowercase letter and contain only letters,numbers,and underscores",value=constraint.name))} return if (violations.isEmpty()) {constraint.right()} else {TableError.ValidationError(message="Constraint validation failed",violations=violations).left()}} private fun validateUniqueConstraint(constraint:TableConstraint,violations:MutableList<TableError.Violation>) {if (constraint.columns.isEmpty()) {violations.add(TableError.Violation(field="columns",message="Unique constraint must specify at least one column",value=constraint.name))} if (constraint.expression != null) {violations.add(TableError.Violation(field="expression",message="Unique constraint cannot have an expression",value=constraint.name))}} private fun validateCheckConstraint(constraint:TableConstraint,violations:MutableList<TableError.Violation>) {if (constraint.expression == null) {violations.add(TableError.Violation(field="expression",message="Check constraint must have an expression",value=constraint.name))} if (constraint.columns.isNotEmpty()) {violations.add(TableError.Violation(field="columns",message="Check constraint cannot specify columns directly",value=constraint.name))}} private fun validateForeignKeyConstraint(constraint:TableConstraint,violations:MutableList<TableError.Violation>) {if (constraint.columns.isEmpty()) {violations.add(TableError.Violation(field="columns",message="Foreign key constraint must specify at least one column",value=constraint.name))} if (constraint.expression != null) {violations.add(TableError.Violation(field="expression",message="Foreign key constraint cannot have an expression",value=constraint.name))}} private fun isValidConstraintName(name:String):Boolean=name.matches(Regex("^[a-z][a-z0-9_]*$"))} 
File: ./infrastructure/validation/validators/TableValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.error.TableError import org.blackerp.domain.core.error.TableError.Violation import org.blackerp.domain.core.values.DataType import arrow.core.Either import arrow.core.left import arrow.core.right @Component class TableValidator {fun validateCreate(table:ADTable):Either<TableError,ADTable> {val violations=mutableListOf<Violation>() // Name validation if (!table.name.value.matches(Regex("^[a-z][a-z0-9_]*$"))) {violations.add(Violation(field="name",message="Table name must start with lowercase letter and contain only lowercase letters,numbers,and underscores",value=table.name.value))} // Column validation table.columns.forEachIndexed {index,column->validateColumn(column,index,violations)} // Duplicate column check val duplicateColumns=table.columns .groupBy {it.name} .filter {it.value.size> 1} .keys duplicateColumns.forEach {name->violations.add(Violation(field="columns",message="Duplicate column name found",value=name))} // Primary key validation if (!table.columns.any {it.isPrimaryKey}) {violations.add(Violation(field="columns",message="Table must have at least one primary key column"))} return if (violations.isEmpty()) {table.right()} else {TableError.ValidationError(message="Table validation failed",violations=violations).left()}} private fun validateColumn(column:ColumnDefinition,index:Int,violations:MutableList<Violation>) {val prefix="columns[$index]" when (column.dataType) {DataType.STRING->{if (column.length == null) {violations.add(Violation(field="$prefix.length",message="String column must specify length",value=column.name))} if (column.precision != null || column.scale != null) {violations.add(Violation(field="$prefix",message="String column cannot have precision or scale",value=column.name))}} DataType.DECIMAL->{if (column.precision == null) {violations.add(Violation(field="$prefix.precision",message="Decimal column must specify precision",value=column.name))} if (column.scale == null) {violations.add(Violation(field="$prefix.scale",message="Decimal column must specify scale",value=column.name))} if (column.length != null) {violations.add(Violation(field="$prefix",message="Decimal column cannot have length",value=column.name))}} else->{if (column.length != null || column.precision != null || column.scale != null) {violations.add(Violation(field="$prefix",message="Column of type ${column.dataType} cannot have length,precision,or scale",value=column.name))}}} // Reference validation for foreign keys column.reference?.let {ref->if (column.dataType != DataType.UUID) {violations.add(Violation(field="$prefix.reference",message="Reference columns must be of type UUID",value=column.name))}}}} 
File: ./infrastructure/validation/validators/CompositeValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.left import arrow.core.right @Component class CompositeValidator<T>(private val validators:List<Validator<T>>) {fun validate(target:T):Either<TableError,T> {val violations=mutableListOf<TableError.Violation>() validators.forEach {validator->validator.validate(target).fold({error->when (error) {is TableError.ValidationError->violations.addAll(error.violations) else->return error.left()}},{/* continue validation */})} return if (violations.isEmpty()) {target.right()} else {TableError.ValidationError(message="Validation failed",violations=violations).left()}}} 
File: ./infrastructure/validation/validators/ColumnValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.ad.table.ColumnDefinition import org.blackerp.domain.core.values.DataType import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.validation.Validator class ColumnValidator :Validator<ColumnDefinition> {override suspend fun validate(entity:ColumnDefinition):Either<ValidationError,ColumnDefinition> {val errors=mutableListOf<ValidationError>() // Validate name format if (!entity.name.value.matches(Regex("^[a-z][a-z0-9_]*$"))) {errors.add(ValidationError.InvalidFormat("Column name must start with lowercase letter and contain only lowercase letters,numbers,and underscores"))} // Validate type-specific constraints when (entity.dataType) {DataType.STRING->{if (entity.length == null) {errors.add(ValidationError.Required("length for string type"))} if (entity.precision != null || entity.scale != null) {errors.add(ValidationError.InvalidValue("string type cannot have precision or scale"))}} DataType.DECIMAL->{if (entity.precision == null) {errors.add(ValidationError.Required("precision for decimal type"))} if (entity.length != null) {errors.add(ValidationError.InvalidValue("decimal type cannot have length"))}} else->{if (entity.length != null || entity.precision != null || entity.scale != null) {errors.add(ValidationError.InvalidValue("type ${entity.dataType} cannot have length,precision,or scale"))}}} return if (errors.isEmpty()) {entity.right()} else {errors.first().left()}}} 
File: ./infrastructure/validation/validators/RelationshipValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.table.TableRelationship import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.left import arrow.core.right @Component class RelationshipValidator {fun validate(relationship:TableRelationship):Either<TableError,TableRelationship> {val violations=mutableListOf<TableError.Violation>() // Validate source and target are different if (relationship.sourceTable == relationship.targetTable) {violations.add(TableError.Violation(field="targetTable",message="Self-referential relationships not supported",value=relationship.targetTable))} // Validate column names if (!isValidColumnName(relationship.sourceColumn)) {violations.add(TableError.Violation(field="sourceColumn",message="Invalid column name format",value=relationship.sourceColumn))} if (!isValidColumnName(relationship.targetColumn)) {violations.add(TableError.Violation(field="targetColumn",message="Invalid column name format",value=relationship.targetColumn))} return if (violations.isEmpty()) {relationship.right()} else {TableError.ValidationError(message="Relationship validation failed",violations=violations).left()}} private fun isValidColumnName(name:String):Boolean=name.matches(Regex("^[a-z][a-z0-9_]*$"))} 
File: ./infrastructure/validation/expression/DefaultExpressionParser.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.expression import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.metadata.expression.* import org.blackerp.domain.core.shared.ValidationError import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import java.util.* @Component class DefaultExpressionParser :ExpressionParser {private val logger=LoggerFactory.getLogger(DefaultExpressionParser::class.java) private val operators=setOf("==","!=",">","<",">=","<=","+","-","*","/","&&","||") private val functions=setOf("sum","avg","max","min") override fun parse(expression:String):Either<ValidationError,List<Token>>=try {tokenize(expression) .flatMap {tokens->convertToRPN(tokens)}} catch (e:Exception) {logger.error("Expression parsing failed:$expression",e) ValidationError.InvalidValue("Expression parsing failed:${e.message}").left()} override fun validateSyntax(tokens:List<Token>):Either<ValidationError,Unit> {var stack=0 for (token in tokens) {when (token) {is Token.Operator->{stack -= 1 if (stack <0) return ValidationError .InvalidValue("Invalid expression:insufficient operands") .left()} is Token.Function->{// Functions consume all stack items if (stack <= 0) return ValidationError .InvalidValue("Invalid expression:function requires arguments") .left()} else->stack += 1}} return if (stack == 1) Unit.right() else ValidationError.InvalidValue("Invalid expression:incorrect number of operands").left()} private fun tokenize(expression:String):Either<ValidationError,List<Token>> {val tokens=mutableListOf<Token>() var current="" var i=0 while (i <expression.length) {when {expression[i].isWhitespace()->{if (current.isNotEmpty()) {addToken(current,tokens) current=""}} expression[i] == '('->{if (current.isNotEmpty()) {addToken(current,tokens) current=""} tokens.add(Token.LeftParen)} expression[i] == ')'->{if (current.isNotEmpty()) {addToken(current,tokens) current=""} tokens.add(Token.RightParen)} isOperatorChar(expression[i])->{if (current.isNotEmpty()) {addToken(current,tokens) current=""} val op=parseOperator(expression,i) tokens.add(Token.Operator(op)) i += op.length - 1} else->current += expression[i]} i++} if (current.isNotEmpty()) {addToken(current,tokens)} return tokens.right()} private fun addToken(token:String,tokens:MutableList<Token>) {when {token.matches(Regex("^[0-9]+$"))->tokens.add(Token.Literal(token.toInt())) token.matches(Regex("^[0-9]*\\.[0-9]+$"))->tokens.add(Token.Literal(token.toDouble())) token.equals("true",ignoreCase=true)->tokens.add(Token.Literal(true)) token.equals("false",ignoreCase=true)->tokens.add(Token.Literal(false)) token in functions->tokens.add(Token.Function(token)) else->tokens.add(Token.Variable(token))}} private fun convertToRPN(tokens:List<Token>):Either<ValidationError,List<Token>> {val output=mutableListOf<Token>() val operators=Stack<Token>() for (token in tokens) {when (token) {is Token.Literal,is Token.Variable->output.add(token) is Token.Function->operators.push(token) is Token.LeftParen->operators.push(token) is Token.RightParen->{while (operators.isNotEmpty() && operators.peek() !is Token.LeftParen) {output.add(operators.pop())} if (operators.isEmpty()) return ValidationError .InvalidValue("Mismatched parentheses") .left() operators.pop() // Remove LeftParen if (operators.isNotEmpty() && operators.peek() is Token.Function) {output.add(operators.pop())}} is Token.Operator->{while (operators.isNotEmpty() && operators.peek() is Token.Operator && precedence(token) <= precedence(operators.peek() as Token.Operator)) {output.add(operators.pop())} operators.push(token)}}} while (operators.isNotEmpty()) {val op=operators.pop() if (op is Token.LeftParen) return ValidationError .InvalidValue("Mismatched parentheses") .left() output.add(op)} return output.right()} private fun precedence(op:Token.Operator):Int=when (op.symbol) {"*","/"->5 "+","-"->4 ">","<",">=","<="->3 "==","!="->2 "&&"->1 "||"->0 else->-1} private fun isOperatorChar(c:Char):Boolean=c in setOf('+','-','*','/','>','<','=','!','&','|') private fun parseOperator(expr:String,start:Int):String {val possible=expr.substring(start,minOf(start + 2,expr.length)) return when {possible.length == 2 && operators.contains(possible)->possible operators.contains(possible[0].toString())->possible[0].toString() else->throw IllegalArgumentException("Invalid operator at position $start")}}} 
File: ./infrastructure/validation/expression/DefaultExpressionEngine.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.expression import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.metadata.expression.* import org.blackerp.domain.core.shared.ValidationError import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import java.util.* @Component class DefaultExpressionEngine(private val parser:ExpressionParser) :ExpressionEngine {private val logger=LoggerFactory.getLogger(DefaultExpressionEngine::class.java) override suspend fun evaluate(expression:String,context:Map<String,Any>):Either<ValidationError,ExpressionResult>=try {parser.parse(expression) .flatMap {tokens->evaluateTokens(tokens,context)}} catch (e:Exception) {logger.error("Expression evaluation failed:$expression",e) ValidationError.InvalidValue("Expression evaluation failed:${e.message}").left()} override suspend fun validateExpression(expression:String):Either<ValidationError,Unit>=parser.parse(expression) .flatMap {tokens->parser.validateSyntax(tokens)} private fun evaluateTokens(tokens:List<Token>,context:Map<String,Any>):Either<ValidationError,ExpressionResult> {val stack=Stack<Any>() for (token in tokens) {when (token) {is Token.Variable->{val value=context[token.name] ?:return ValidationError .InvalidValue("Variable not found:${token.name}") .left() stack.push(value)} is Token.Literal->stack.push(token.value) is Token.Operator->{if (stack.size <2) return ValidationError .InvalidValue("Invalid expression:insufficient operands") .left() val right=stack.pop() val left=stack.pop() val result=evaluateOperation(token.symbol,left,right) ?:return ValidationError .InvalidValue("Invalid operation:${token.symbol}") .left() stack.push(result)} is Token.Function->{val result=evaluateFunction(token.name,stack) ?:return ValidationError .InvalidValue("Invalid function:${token.name}") .left() stack.push(result)} else->{} // Handle parentheses in parser}} if (stack.size != 1) return ValidationError .InvalidValue("Invalid expression:incorrect number of operands") .left() return convertToResult(stack.pop()).right()} private fun evaluateOperation(op:String,left:Any,right:Any):Any?=when (op) {"=="->left == right "!="->left != right ">"->compareValues(left,right)> 0 "<"->compareValues(left,right) <0 ">="->compareValues(left,right)>= 0 "<="->compareValues(left,right) <= 0 "+"->add(left,right) "-"->subtract(left,right) "*"->multiply(left,right) "/"->divide(left,right) "&&"->(left as? Boolean ?:false) && (right as? Boolean ?:false) "||"->(left as? Boolean ?:false) || (right as? Boolean ?:false) else->null} private fun evaluateFunction(name:String,stack:Stack<Any>):Any?=when (name.lowercase()) {"sum"->stack.toList().filterIsInstance<Number>().sumOf {it.toDouble()} "avg"->stack.toList().filterIsInstance<Number>().let {numbers->numbers.sumOf {it.toDouble()} / numbers.size} "max"->stack.toList().filterIsInstance<Number>().maxOf {it.toDouble()} "min"->stack.toList().filterIsInstance<Number>().minOf {it.toDouble()} else->null} private fun convertToResult(value:Any):ExpressionResult=when (value) {is Boolean->ExpressionResult.BooleanResult(value) is Number->ExpressionResult.NumericResult(value) is String->ExpressionResult.StringResult(value) is java.time.temporal.Temporal->ExpressionResult.DateResult(value) else->throw IllegalArgumentException("Unsupported result type:${value::class.java}")} private fun add(left:Any,right:Any):Any?=when {left is Number && right is Number->left.toDouble() + right.toDouble() left is String || right is String->"$left$right" else->null} private fun subtract(left:Any,right:Any):Any?=when {left is Number && right is Number->left.toDouble() - right.toDouble() else->null} private fun multiply(left:Any,right:Any):Any?=when {left is Number && right is Number->left.toDouble() * right.toDouble() else->null} private fun divide(left:Any,right:Any):Any?=when {left is Number && right is Number->{if (right.toDouble() == 0.0) null else left.toDouble() / right.toDouble()} else->null} @Suppress("UNCHECKED_CAST") private fun compareValues(left:Any,right:Any):Int=when {left is Number && right is Number->left.toDouble().compareTo(right.toDouble()) left is String && right is String->left.compareTo(right) left is Comparable<*> && right::class.java == left::class.java->(left as Comparable<Any>).compareTo(right) else->throw IllegalArgumentException("Cannot compare $left with $right")}} 
File: ./infrastructure/validation/RuleBasedValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.metadata.services.RuleEvaluator import org.blackerp.domain.core.ad.metadata.services.MetadataService import org.blackerp.domain.core.shared.ValidationError import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.firstOrNull import org.slf4j.LoggerFactory @Component class RuleBasedValidator(private val metadataService:MetadataService,private val ruleEvaluator:RuleEvaluator) {private val logger=LoggerFactory.getLogger(RuleBasedValidator::class.java) suspend fun validate(entityType:String,context:Map<String,Any>):Either<ValidationError,Unit> {var hasErrors=false val errors=mutableListOf<String>() metadataService.getRules(entityType).collect {rule->ruleEvaluator.evaluate(rule,context).fold({error->hasErrors=true errors.add(error.message)},{valid->if (!valid) {hasErrors=true errors.add(rule.errorMessage ?:"Validation failed")}})} return if (hasErrors) {ValidationError.InvalidValue(errors.joinToString(";")).left()} else {Unit.right()}}} 
File: ./infrastructure/metadata/cache/MetadataCacheService.kt
-------------------------------------------
package org.blackerp.infrastructure.metadata.cache import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.metadata.entities.* import java.util.UUID @Component class MetadataCacheService {companion object {const val RULES_CACHE="rules" const val VALIDATIONS_CACHE="validations" const val STATUS_CACHE="status_lines"} suspend fun getCachedRules(entityType:String):List<ADRule>=emptyList() suspend fun evictRulesCache() {} suspend fun getCachedValidations(entityType:String):List<ADValidationRule>=emptyList() suspend fun evictValidationsCache() {}} 
File: ./infrastructure/metadata/services/MetadataEvaluator.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.metadata.entities.* import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory @Service class MetadataEvaluator {private val logger=LoggerFactory.getLogger(MetadataEvaluator::class.java) fun evaluateRule(rule:ADRule,context:Map<String,Any>):Either<MetadataError,Boolean>=try {// Simple evaluation for POC // TODO:Implement proper expression evaluation engine when (rule.ruleType) {"VALIDATION"->evaluateValidation(rule.expression,context) "CALCULATION"->evaluateCalculation(rule.expression,context) else->throw IllegalArgumentException("Unsupported rule type:${rule.ruleType}")}} catch (e:Exception) {logger.error("Rule evaluation failed:${rule.id}",e) MetadataError.ValidationFailed("Rule evaluation failed:${e.message}").left()} private fun evaluateValidation(expression:String,context:Map<String,Any>):Either<MetadataError,Boolean> {// Mock validation for POC return true.right()} private fun evaluateCalculation(expression:String,context:Map<String,Any>):Either<MetadataError,Boolean> {// Mock calculation for POC return true.right()}} 
File: ./infrastructure/metadata/services/MetadataServiceImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.metadata.services import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.metadata.services.MetadataService import org.blackerp.domain.core.ad.metadata.services.MetadataError import org.blackerp.domain.core.ad.metadata.entities.* import arrow.core.Either import kotlinx.coroutines.flow.* import java.util.UUID @Service class MetadataServiceImpl(private val metadataRepository:MetadataRepository) :MetadataService {@Transactional(readOnly=true) override suspend fun getRules(entityType:String):Flow<ADRule>=metadataRepository.findRulesByType(entityType) @Transactional(readOnly=true) override suspend fun getRule(id:UUID):Either<MetadataError,ADRule?>=metadataRepository.findById(id,ADRule::class.java) @Transactional(readOnly=true) override suspend fun getValidations(entityType:String):Flow<ADValidationRule>=metadataRepository.findValidationsByEntity(entityType) @Transactional(readOnly=true) override suspend fun getStatusFlow(documentType:String):Flow<ADStatusLine>=metadataRepository.findStatusLines(documentType)} 
File: ./infrastructure/metadata/MetadataConfig.kt
-------------------------------------------
package org.blackerp.infrastructure.metadata import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Bean import org.springframework.jdbc.core.JdbcTemplate import javax.sql.DataSource @Configuration class MetadataConfig {@Bean fun jdbcTemplate(dataSource:DataSource)=JdbcTemplate(dataSource)} 
File: ./infrastructure/events/publishers/DomainEventPublisher.kt
-------------------------------------------
package org.blackerp.infrastructure.events.publishers import org.springframework.stereotype.Component import org.springframework.context.ApplicationEventPublisher import org.blackerp.domain.events.DomainEvent import org.slf4j.LoggerFactory import org.slf4j.MDC import java.util.UUID @Component class DomainEventPublisher(private val applicationEventPublisher:ApplicationEventPublisher) {private val logger=LoggerFactory.getLogger(DomainEventPublisher::class.java) fun publish(event:DomainEvent) {val correlationId=MDC.get("correlationId") ?:UUID.randomUUID().toString() MDC.put("correlationId",correlationId) try {logger.debug("Publishing event:{} with correlationId:{}",event.javaClass.simpleName,correlationId) applicationEventPublisher.publishEvent(event) logger.debug("Successfully published event:{} with correlationId:{}",event.javaClass.simpleName,correlationId)} catch (e:Exception) {logger.error("Failed to publish event:{} with correlationId:{}",event.javaClass.simpleName,correlationId,e) throw e} finally {MDC.remove("correlationId")}}} 
File: ./infrastructure/events/handlers/WindowEventHandler.kt
-------------------------------------------
package org.blackerp.infrastructure.events.handlers import org.springframework.stereotype.Component import org.springframework.context.event.EventListener import org.blackerp.domain.events.WindowEvent import org.blackerp.application.services.cache.WindowCacheStrategy import org.slf4j.LoggerFactory @Component class WindowEventHandler(private val windowCache:WindowCacheStrategy) {private val logger=LoggerFactory.getLogger(WindowEventHandler::class.java) @EventListener suspend fun onWindowCreated(event:WindowEvent.WindowCreated) {logger.info("Window created:${event.name} (${event.windowId})") windowCache.evictAll()} @EventListener suspend fun onWindowUpdated(event:WindowEvent.WindowUpdated) {logger.info("Window updated:${event.windowId}") windowCache.evictAll()} @EventListener suspend fun onWindowDeleted(event:WindowEvent.WindowDeleted) {logger.info("Window deleted:${event.windowId}") windowCache.evictAll()} @EventListener suspend fun onTabAdded(event:WindowEvent.TabAdded) {logger.info("Tab added to window ${event.windowId}:${event.name}") windowCache.evictAll()} @EventListener suspend fun onTabRemoved(event:WindowEvent.TabRemoved) {logger.info("Tab removed from window ${event.windowId}") windowCache.evictAll()}} 
File: ./infrastructure/events/handlers/RelationshipEventHandler.kt
-------------------------------------------
package org.blackerp.infrastructure.events.handlers import org.springframework.stereotype.Component import org.springframework.context.event.EventListener import org.blackerp.domain.events.RelationshipEvent import org.slf4j.LoggerFactory @Component class RelationshipEventHandler {private val logger=LoggerFactory.getLogger(RelationshipEventHandler::class.java) @EventListener fun handleRelationshipCreated(event:RelationshipEvent.RelationshipCreated) {logger.info("Relationship created:{}->{} (type:{})",event.sourceTableId,event.targetTableId,event.type)} @EventListener fun handleRelationshipModified(event:RelationshipEvent.RelationshipModified) {logger.info("Relationship modified:{} (type changed:{}->{})",event.relationshipId,event.previousType,event.newType)} @EventListener fun handleRelationshipDeleted(event:RelationshipEvent.RelationshipDeleted) {logger.info("Relationship deleted:{} (source:{},target:{})",event.relationshipId,event.sourceTableId,event.targetTableId)}} 
File: ./infrastructure/events/handlers/ConstraintEventHandler.kt
-------------------------------------------
package org.blackerp.infrastructure.events.handlers import org.springframework.stereotype.Component import org.springframework.context.event.EventListener import org.blackerp.domain.events.ConstraintEvent import org.slf4j.LoggerFactory @Component class ConstraintEventHandler {private val logger=LoggerFactory.getLogger(ConstraintEventHandler::class.java) @EventListener fun handleConstraintCreated(event:ConstraintEvent.ConstraintCreated) {logger.info("Constraint created:{} on table {} (type:{})",event.name,event.tableId,event.type)} @EventListener fun handleConstraintModified(event:ConstraintEvent.ConstraintModified) {logger.info("Constraint modified:{} (name changed:{}->{})",event.constraintId,event.previousName,event.newName)} @EventListener fun handleConstraintDeleted(event:ConstraintEvent.ConstraintDeleted) {logger.info("Constraint deleted:{} from table {}",event.name,event.tableId)} @EventListener fun handleConstraintViolated(event:ConstraintEvent.ConstraintViolated) {logger.warn("Constraint violation:{} on table {} (type:{}):{}",event.constraintId,event.tableId,event.violationType,event.violationDetails)}} 
File: ./infrastructure/events/handlers/WorkflowEventHandler.kt
-------------------------------------------
package org.blackerp.infrastructure.events.handlers import org.springframework.stereotype.Component import org.springframework.context.event.EventListener import org.blackerp.domain.events.WorkflowEvent import org.slf4j.LoggerFactory @Component class WorkflowEventHandler {private val logger=LoggerFactory.getLogger(WorkflowEventHandler::class.java) @EventListener fun handleNodeCreated(event:WorkflowEvent.NodeCreated) {logger.info("Node created:{} (type:{})",event.node.displayName,event.node.type)} @EventListener fun handleNodeUpdated(event:WorkflowEvent.NodeUpdated) {logger.info("Node updated:{} with changes:{}",event.nodeId,event.changes)} @EventListener fun handleNodeDeleted(event:WorkflowEvent.NodeDeleted) {logger.info("Node deleted:{} ({})",event.nodeId,event.nodeName)}} 
File: ./infrastructure/integration/adapters/SystemHealthAdapter.kt
-------------------------------------------
package org.blackerp.infrastructure.integration.adapters import org.springframework.boot.actuate.health.Health import org.springframework.boot.actuate.health.HealthIndicator import org.springframework.stereotype.Component import org.springframework.jdbc.core.JdbcTemplate @Component class SystemHealthAdapter(private val jdbcTemplate:JdbcTemplate) :HealthIndicator {override fun health():Health {return try {val dbStatus=checkDatabase() if (dbStatus) {Health.up() .withDetail("database","UP") .build()} else {Health.down() .withDetail("database","DOWN") .build()}} catch (ex:Exception) {Health.down() .withException(ex) .build()}} private fun checkDatabase():Boolean=try {jdbcTemplate.queryForObject("SELECT 1",Int::class.java) true} catch (e:Exception) {false}} 
File: ./infrastructure/integration/adapters/TableHealthIndicator.kt
-------------------------------------------
package org.blackerp.infrastructure.integration.adapters import org.springframework.boot.actuate.health.Health import org.springframework.boot.actuate.health.HealthIndicator import org.springframework.stereotype.Component import org.springframework.jdbc.core.JdbcTemplate import org.slf4j.LoggerFactory @Component class TableHealthIndicator(private val jdbcTemplate:JdbcTemplate) :HealthIndicator {private val logger=LoggerFactory.getLogger(TableHealthIndicator::class.java) override fun health():Health {return try {val tableCount=jdbcTemplate.queryForObject("SELECT COUNT(*) FROM ad_table",Int::class.java) ?:0 val recentTablesCount=jdbcTemplate.queryForObject(""" SELECT COUNT(*) FROM ad_table WHERE created> now() - interval '24 hours' """,Int::class.java) ?:0 Health.up() .withDetail("totalTables",tableCount) .withDetail("tablesCreatedLast24h",recentTablesCount) .build()} catch (e:Exception) {logger.error("Health check failed",e) Health.down() .withException(e) .build()}}} 
File: ./infrastructure/workflow/persistence/TransitionRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.workflow.persistence import org.blackerp.domain.core.workflow.transition.StateTransition import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.slf4j.LoggerFactory @Repository class TransitionRepository(private val jdbcTemplate:JdbcTemplate) {private val logger=LoggerFactory.getLogger(TransitionRepository::class.java) // In-memory storage for POC private val transitions=mutableMapOf<String,List<StateTransition>>() fun findTransitions(fromState:String):List<StateTransition>=transitions[fromState] ?:emptyList() fun saveTransition(transition:StateTransition):Either<RepositoryError,StateTransition> {try {val currentTransitions=transitions[transition.fromState] ?:emptyList() transitions[transition.fromState]=currentTransitions + transition return transition.right()} catch (e:Exception) {logger.error("Failed to save transition",e) return RepositoryError.SaveFailed(e.message ?:"Unknown error").left()}}} sealed class RepositoryError {data class SaveFailed(val message:String) :RepositoryError() data class NotFound(val id:UUID) :RepositoryError()} 
File: ./infrastructure/workflow/tracking/WorkflowExecutionTrackerImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.workflow.tracking import org.springframework.stereotype.Component import org.blackerp.domain.core.workflow.tracking.* import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.metadata.AuditInfo import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Component class WorkflowExecutionTrackerImpl :WorkflowExecutionTracker {private val logger=LoggerFactory.getLogger(WorkflowExecutionTrackerImpl::class.java) // In-memory storage for POC private val executions=mutableMapOf<UUID,WorkflowExecution>() override suspend fun startExecution(workflowId:UUID,documentId:UUID):WorkflowExecution {val execution=WorkflowExecution(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),workflowId=workflowId,documentId=documentId,startTime=Instant.now()) executions[documentId]=execution logger.info("Started workflow execution for document:$documentId") return execution} override suspend fun updateExecution(execution:WorkflowExecution):WorkflowExecution {executions[execution.documentId]=execution logger.info("Updated workflow execution for document:${execution.documentId},status:${execution.status}") return execution} override suspend fun getExecution(documentId:UUID):WorkflowExecution? {return executions[documentId]} override suspend fun getExecutions(workflowId:UUID):List<WorkflowExecution> {return executions.values.filter {it.workflowId == workflowId}}} 
File: ./settings.gradle.kts
-------------------------------------------
rootProject.name="blackerp" include(":domain",":application",":infrastructure",":integration-tests") 
File: ./domain/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") version "1.9.20"} tasks.bootJar {enabled=false} tasks.jar {enabled=true} sourceSets {main {kotlin {srcDirs(// Existing directories "core","events","validation",// New metadata directories "core/ad/metadata","core/ad/metadata/entities","core/ad/metadata/operations","core/ad/metadata/services")}}} dependencies {implementation("org.slf4j:slf4j-api:2.0.9") api("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3") api("io.arrow-kt:arrow-core:1.1.3") // No other dependencies needed - domain is pure}
File: ./domain/core/ad/docstatus/DocStatusError.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docstatus sealed class DocStatusError(message:String) :Exception(message) {data class InvalidStatus(val status:String) :DocStatusError("Invalid status:$status") data class StatusTransitionInvalid(val from:String,val to:String) :DocStatusError("Invalid transition from $from to $to")} 
File: ./domain/core/ad/docstatus/DocStatus.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docstatus import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import java.util.UUID enum class DocumentStatus {DRAFT,IN_PROGRESS,COMPLETED,VOIDED,CLOSED} data class DocStatus(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val code:String,val allowedTransitions:List<String>) :ADObject {override val id:String get()=uuid.toString() companion object {fun create(metadata:EntityMetadata,displayName:DisplayName,description:Description?,code:String,transitions:List<String>):Either<DocStatusError,DocStatus>=DocStatus(metadata=metadata,displayName=displayName,description=description,code=code,allowedTransitions=transitions).right()}} 
File: ./domain/core/ad/docstatus/AD_DocStatus.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docstatus import arrow.core.Either import arrow.core.right import arrow.core.left /** In-memory document status registry for POC */ object AD_DocStatus {// Standard document statuses const val DRAFT="DR" const val IN_PROGRESS="IP" const val COMPLETED="CO" const val VOIDED="VO" const val CLOSED="CL" // Status display names private val displayNames=mapOf(DRAFT to "Draft",IN_PROGRESS to "In Progress",COMPLETED to "Completed",VOIDED to "Voided",CLOSED to "Closed") // Allowed transitions per status private val transitions=mapOf(DRAFT to listOf(IN_PROGRESS,VOIDED),IN_PROGRESS to listOf(COMPLETED,VOIDED),COMPLETED to listOf(CLOSED,VOIDED),VOIDED to emptyList<String>(),CLOSED to emptyList<String>()) fun getDisplayName(status:String):String=displayNames[status] ?:status fun validateTransition(fromStatus:String,toStatus:String):Either<DocStatusError,Unit> {if (!transitions.containsKey(fromStatus)) {return DocStatusError.InvalidStatus(fromStatus).left()} if (!transitions.containsKey(toStatus)) {return DocStatusError.InvalidStatus(toStatus).left()} return if (canTransition(fromStatus,toStatus)) {Unit.right()} else {DocStatusError.StatusTransitionInvalid(fromStatus,toStatus).left()}} private fun canTransition(fromStatus:String,toStatus:String):Boolean=transitions[fromStatus]?.contains(toStatus) ?:false} 
File: ./domain/core/ad/docaction/DocActionError.kt
-------------------------------------------
// domain/core/ad/docaction/DocActionError.kt package org.blackerp.domain.core.ad.docaction import org.blackerp.domain.core.error.DomainError sealed class DocActionError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class ExecutionFailed(val details:String) :DocActionError("Action execution failed:$details","DOC_EXEC_FAILED") data class ValidationFailed(val details:String) :DocActionError("Action validation failed:$details","DOC_VAL_FAILED") data class NotFound(override val code:String) :DocActionError("Action not found:$code","DOC_ACTION_NOT_FOUND")} 
File: ./domain/core/ad/docaction/DocAction.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docaction import arrow.core.Either import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import java.util.UUID interface DocAction {val metadata:EntityMetadata val id:String val code:String val displayName:DisplayName val description:Description? suspend fun execute(context:DocActionContext):Either<DocActionError,DocActionResult>} data class DocActionContext(val documentId:UUID,val userId:String,val fromStatus:String,val toStatus:String,val parameters:Map<String,Any>=emptyMap()) data class DocActionResult(val success:Boolean,val message:String,val data:Map<String,Any>=emptyMap()) 
File: ./domain/core/ad/docaction/DocActionRegistry.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docaction import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import java.util.UUID interface DocActionRegistry {fun register(action:DocAction):Either<DocActionError,DocAction> fun unregister(code:String) suspend fun execute(code:String,context:DocActionContext):Either<DocActionError,DocActionResult> fun getAction(code:String):Either<DocActionError,DocAction>} data class StandardDocAction(override val metadata:EntityMetadata,override val id:String,override val code:String,override val displayName:DisplayName,override val description:Description?,val operation:suspend (DocActionContext)->Either<DocActionError,DocActionResult>) :DocAction {override suspend fun execute(context:DocActionContext):Either<DocActionError,DocActionResult>=operation(context)} 
File: ./domain/core/ad/docaction/DocActionOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docaction import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface DocActionOperations {suspend fun register(action:DocAction):Either<DocActionError,DocAction> suspend fun findByCode(code:String):Either<DocActionError,DocAction?> suspend fun execute(code:String,context:DocActionContext):Either<DocActionError,DocActionResult> suspend fun listActions():Flow<DocAction>} 
File: ./domain/core/ad/window/WindowService.kt
-------------------------------------------
// File:domain/core/ad/window/WindowService.kt package org.blackerp.domain.core.ad.window import arrow.core.Either import java.util.UUID import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.ad.tab.ADTab import org.blackerp.domain.core.error.WindowError interface WindowService {suspend fun createWindow(command:CreateWindowCommand):Either<WindowError,ADWindow> suspend fun updateWindow(id:UUID,command:UpdateWindowCommand):Either<WindowError,ADWindow> suspend fun findByName(name:WindowName):Either<WindowError,ADWindow?> suspend fun findById(id:UUID):Either<WindowError,ADWindow?> suspend fun listTabs(criteria:TabSearchCriteria):Flow<ADTab> suspend fun deleteWindow(id:UUID):Either<WindowError,Unit>} 
File: ./domain/core/ad/window/ADWindow.kt
-------------------------------------------
package org.blackerp.domain.core.ad.window import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.ad.tab.ADTab import java.util.UUID data class ADWindow(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val name:WindowName,val tabs:List<ADTab>,val isActive:Boolean=true,val isSOTrx:Boolean=true,// Sales/Purchase indicator val windowType:WindowType=WindowType.MAINTAIN) :ADObject {override val id:String get()=uuid.toString()} enum class WindowType {MAINTAIN, // Regular maintenance window QUERY, // Query/lookup window TRANSACTION // Transaction entry window} data class WindowField(val id:UUID=UUID.randomUUID(),val columnName:String,val displayName:String,val description:String?,val isDisplayed:Boolean=true,val isReadOnly:Boolean=false,val isMandatory:Boolean=false,val sequence:Int=0,val displayLogic:String?=null, // Display condition val defaultValue:String?=null,val validationRule:String?=null) 
File: ./domain/core/ad/window/WindowOperations.kt
-------------------------------------------
// File:domain/core/ad/window/WindowOperations.kt package org.blackerp.domain.core.ad.window import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID import org.blackerp.domain.core.error.WindowError interface WindowOperations {suspend fun save(window:ADWindow):Either<WindowError,ADWindow> suspend fun findById(id:UUID):Either<WindowError,ADWindow?> suspend fun findByName(name:WindowName):Either<WindowError,ADWindow?> suspend fun search(query:String,pageSize:Int=20,page:Int=0):Flow<ADWindow> suspend fun delete(id:UUID):Either<WindowError,Unit> suspend fun validateWindow(window:ADWindow):Either<WindowError,Unit>} interface WindowRepository {suspend fun save(window:ADWindow):Either<WindowError,ADWindow> suspend fun findById(id:UUID):Either<WindowError,ADWindow?> suspend fun findByName(name:WindowName):Either<WindowError,ADWindow?> suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADWindow> suspend fun delete(id:UUID):Either<WindowError,Unit>} 
File: ./domain/core/ad/window/WindowName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.window import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class WindowName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,WindowName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Window name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("window name",3,50).left() else->WindowName(value).right()}}} 
File: ./domain/core/ad/window/commands.kt
-------------------------------------------
// File:domain/core/ad/window/commands.kt package org.blackerp.domain.core.ad.window import org.blackerp.domain.core.values.* import java.util.UUID // Create commands data class CreateWindowCommand(val name:WindowName,val displayName:DisplayName,val description:Description?=null,val tabs:List<CreateTabCommand>=emptyList(),val isActive:Boolean?=null,val isSOTrx:Boolean?=null,val windowType:WindowType?=null) data class UpdateWindowCommand(val displayName:DisplayName?=null,val description:Description?=null,val isActive:Boolean?=null,val isSOTrx:Boolean?=null) data class CreateTabCommand(val displayName:String,val name:String,val description:String?,val tableId:UUID,val sequence:Int=10,val fields:List<CreateFieldCommand>=emptyList()) data class UpdateTabCommand(val displayName:String?,val description:String?,val sequence:Int?,val fields:List<UpdateFieldCommand>?) data class CreateFieldCommand(val columnName:String,val displayName:String,val description:String?,val sequence:Int=10,val isDisplayed:Boolean=true,val isReadOnly:Boolean=false,val isMandatory:Boolean=false) data class UpdateFieldCommand(val id:UUID,val displayName:String?,val description:String?,val sequence:Int?,val isDisplayed:Boolean?,val isReadOnly:Boolean?,val isMandatory:Boolean?) // Search criteria data class TabSearchCriteria(val windowId:UUID?=null,val tableId:UUID?=null,val namePattern:String?=null,val pageSize:Int=20,val page:Int=0)
File: ./domain/core/ad/process/ADProcess.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import arrow.core.Either import arrow.core.right import java.util.UUID data class ADProcess(override val metadata:EntityMetadata,override val id:String=UUID.randomUUID().toString(),override val displayName:DisplayName,override val description:Description?,val type:ProcessType,val parameters:List<ProcessParameter>,val implementation:ProcessImplementation,val schedule:ProcessSchedule?) :ADObject {companion object {fun create(params:CreateProcessParams):Either<ProcessError,ADProcess>=ADProcess(metadata=params.metadata,displayName=params.displayName,description=params.description,type=params.type,parameters=params.parameters,implementation=params.implementation,schedule=params.schedule).right()}} sealed interface ProcessImplementation {data class JavaClass(val className:String) :ProcessImplementation data class DatabaseFunction(val functionName:String) :ProcessImplementation data class Script(val language:String,val code:String) :ProcessImplementation} data class ProcessSchedule(val cronExpression:String,val enabled:Boolean=true) 
File: ./domain/core/ad/process/ADParameter.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import org.blackerp.domain.core.values.DataType import java.util.UUID data class ADParameter(val id:UUID,val name:String,val displayName:String,val description:String?,val dataType:DataType,val mandatory:Boolean=false,val defaultValue:String?=null,val validation:ParameterValidation?=null) data class ParameterValidation(val expression:String,val errorMessage:String) 
File: ./domain/core/ad/process/ProcessOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface ProcessOperations {suspend fun save(process:ADProcess):Either<ProcessError,ADProcess> suspend fun findById(id:UUID):Either<ProcessError,ADProcess?> suspend fun search(query:String,pageSize:Int=20,page:Int=0):Flow<ADProcess> suspend fun delete(id:UUID):Either<ProcessError,Unit> suspend fun execute(id:UUID,parameters:Map<String,Any>,async:Boolean=false):Either<ProcessError,ProcessResult> suspend fun schedule(id:UUID,schedule:ProcessSchedule):Either<ProcessError,ADProcess> suspend fun getExecutionHistory(id:UUID,pageSize:Int=20,page:Int=0):Flow<ProcessExecution> suspend fun validateParameters(id:UUID,parameters:Map<String,Any>):Either<ProcessError,Map<String,List<String>>>} data class ProcessExecution(val id:UUID=UUID.randomUUID(),val processId:UUID,val startTime:java.time.Instant,val endTime:java.time.Instant?,val status:ExecutionStatus,val parameters:Map<String,Any>,val result:ProcessResult?,val user:String) enum class ExecutionStatus {QUEUED,RUNNING,COMPLETED,FAILED,CANCELLED} 
File: ./domain/core/ad/process/ProcessTypes.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description enum class ProcessType {REPORT,CALCULATION,SYNCHRONIZATION,WORKFLOW,DATA_IMPORT,DATA_EXPORT,CUSTOM} data class CreateProcessParams(val metadata:EntityMetadata,val displayName:DisplayName,val description:Description?,val type:ProcessType,val parameters:List<ProcessParameter>,val implementation:ProcessImplementation,val schedule:ProcessSchedule?) data class ProcessParameter(val id:java.util.UUID=java.util.UUID.randomUUID(),val name:String,val displayName:String,val description:String?,val parameterType:ParameterType,val isMandatory:Boolean=false,val validationRule:String?) enum class ParameterType {STRING,NUMBER,DATE,BOOLEAN,REFERENCE,FILE} data class ProcessResult(val success:Boolean,val message:String,val data:Map<String,Any>?=null,val logs:List<String>=emptyList()) 
File: ./domain/core/ad/process/ProcessRepository.kt
-------------------------------------------
// domain/core/process/ProcessRepository.kt package org.blackerp.domain.core.ad.process import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.ProcessError import java.util.UUID interface ProcessRepository {suspend fun save(process:ADProcess):Either<ProcessError,ADProcess> suspend fun findById(id:UUID):Either<ProcessError,ADProcess?> suspend fun delete(id:UUID):Either<ProcessError,Unit> suspend fun search(query:String,pageSize:Int=20,page:Int=0):Flow<ADProcess> suspend fun getExecutionHistory(id:UUID,pageSize:Int=20,page:Int=0):Flow<ProcessExecution>} interface ProcessExecutor {suspend fun execute(processId:UUID,parameters:Map<String,Any>,async:Boolean=false):Either<ProcessError,ProcessResult>} 
File: ./domain/core/ad/process/ProcessError.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class ProcessError(message:String) :DomainError(message) {data class ValidationFailed(val details:String) :ProcessError("Process validation failed:$details") data class ExecutionFailed(val details:String) :ProcessError("Process execution failed:$details") data class NotFound(val id:UUID) :ProcessError("Process not found:$id") data class UnexpectedError(override val message:String) :ProcessError(message)} 
File: ./domain/core/ad/document/DocumentModel.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import java.time.Instant import java.util.UUID import org.blackerp.domain.core.shared.ChangePair // Unified document models data class DocumentChange(val id:UUID,val documentId:UUID,val changedAt:Instant,val changedBy:String,val changes:Map<String,ChangePair<*>>) data class DateRange(val from:Instant,val to:Instant) data class SearchCriteria(val types:List<UUID>?=null,val statuses:List<DocumentStatus>?=null,val dateRange:DateRange?=null,val pageSize:Int=20,val page:Int=0) 
File: ./domain/core/ad/document/DocumentError.kt
-------------------------------------------
// domain/core/ad/document/DocumentError.kt package org.blackerp.domain.core.ad.document import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class DocumentError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class NotFound(val id:UUID) :DocumentError("Document not found:$id","DOC_NOT_FOUND") data class ValidationFailed(val details:String) :DocumentError("Validation failed:$details","DOC_VALIDATION_FAILED") data class StatusTransitionInvalid(val currentStatus:DocumentStatus,val targetStatus:DocumentStatus) :DocumentError("Invalid status transition from $currentStatus to $targetStatus","DOC_STATUS_INVALID")} 
File: ./domain/core/ad/document/Document.kt
-------------------------------------------
// File:domain/core/ad/document/Document.kt package org.blackerp.domain.core.ad.document import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.values.DisplayName data class Document(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val type:DocumentType,val status:DocumentStatus=DocumentStatus.DRAFT,val attributes:Map<String,Any>=emptyMap()) :ADObject {override val id:String get()=uuid.toString() fun validateStatusTransition(targetStatus:DocumentStatus):Either<DocumentError,Unit>=if (type.validateStatusTransition(status.name,targetStatus.name)) {Unit.right()} else {DocumentError.StatusTransitionInvalid(currentStatus=status,targetStatus=targetStatus) .left()} companion object {fun create(metadata:EntityMetadata,displayName:DisplayName,description:Description?,type:DocumentType,status:DocumentStatus=DocumentStatus.DRAFT,attributes:Map<String,Any>=emptyMap()):Document=Document(metadata=metadata,displayName=displayName,description=description,type=type,status=status,attributes=attributes)}} 
File: ./domain/core/ad/document/DocumentOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface DocumentOperations {suspend fun create(document:Document):Either<DocumentError,Document> suspend fun update(id:UUID,document:Document):Either<DocumentError,Document> suspend fun findById(id:UUID):Either<DocumentError,Document?> suspend fun search(criteria:SearchCriteria):Flow<Document> suspend fun delete(id:UUID):Either<DocumentError,Unit> suspend fun changeStatus(id:UUID,status:DocumentStatus):Either<DocumentError,Document> suspend fun getHistory(id:UUID):Flow<DocumentChange>} 
File: ./domain/core/ad/document/DocumentStatus.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document enum class DocumentStatus {DRAFT,IN_PROGRESS,COMPLETED,VOIDED} 
File: ./domain/core/ad/document/DocumentProcessHandler.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import org.blackerp.domain.core.ad.process.* import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID interface DocumentProcessHandler {suspend fun executeDocumentProcess(document:Document,processId:UUID,parameters:Map<String,Any>):Either<DocumentError,ProcessResult>} class DocumentProcessHandlerImpl(private val processOperations:ProcessOperations) :DocumentProcessHandler {override suspend fun executeDocumentProcess(document:Document,processId:UUID,parameters:Map<String,Any>):Either<DocumentError,ProcessResult> {val documentParameters=createDocumentParameters(document) val mergedParameters=parameters + documentParameters return processOperations.execute(processId,mergedParameters) .mapLeft {error->DocumentError.ValidationFailed("Process execution failed:${error.message}")}} private fun createDocumentParameters(document:Document):Map<String,Any>=mapOf("DocumentId" to document.id,"DocumentType" to document.type.id,"DocumentStatus" to document.status.name)} 
File: ./domain/core/ad/document/DocumentType.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.base.ADObject import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID /** * Represents a Document Type that defines the structure and behavior of business documents * such as Sales Orders,Purchase Orders,Invoices etc. */ data class DocumentType(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val name:String,val baseTableId:UUID,val linesTableId:UUID?, // For header-line type documents val workflowId:UUID?, // Optional workflow definition val statusConfig:DocumentStatusConfig,val isSOTrx:Boolean=false,val isActive:Boolean=true) :ADObject {override val id:String get()=uuid.toString() fun validateStatusTransition(from:String,to:String):Boolean=statusConfig.validateTransition(from,to) companion object {fun create(metadata:EntityMetadata,displayName:DisplayName,description:Description?,name:String,baseTableId:UUID,linesTableId:UUID?=null,workflowId:UUID?=null,statusConfig:DocumentStatusConfig,isSOTrx:Boolean=false):Either<DocumentError,DocumentType> {// Validate status configuration if (!statusConfig.isValid()) {return DocumentError.ValidationFailed("Invalid status configuration").left()} return DocumentType(metadata=metadata,displayName=displayName,description=description,name=name,baseTableId=baseTableId,linesTableId=linesTableId,workflowId=workflowId,statusConfig=statusConfig,isSOTrx=isSOTrx).right()}}} /** * Defines the valid statuses and transitions for a document type */ data class DocumentStatusConfig(val statuses:Map<String,DocumentStatusDef>,val defaultStatus:String,val closingStatuses:Set<String>) {fun validateTransition(from:String,to:String):Boolean {val fromStatus=statuses[from] ?:return false return fromStatus.nextStatuses.contains(to)} fun isValid():Boolean {if (statuses.isEmpty()) return false if (!statuses.containsKey(defaultStatus)) return false if (closingStatuses.any {!statuses.containsKey(it)}) return false // Validate that all next statuses exist return statuses.values.all {status->status.nextStatuses.all {statuses.containsKey(it)}}}} /** * Defines a single document status with its properties */ data class DocumentStatusDef(val code:String,val name:String,val description:String?,val nextStatuses:Set<String>) 
File: ./domain/core/ad/document/DocumentEvents.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import org.blackerp.domain.events.DomainEvent import org.blackerp.domain.events.EventMetadata import java.util.UUID sealed class DocumentEvent :DomainEvent {data class ProcessExecuted(override val metadata:EventMetadata,val documentId:UUID,val processId:UUID,val success:Boolean,val message:String) :DocumentEvent() // ... existing event classes ...} 
File: ./domain/core/ad/document/DocumentCommands.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import java.time.Instant data class CreateDocumentCommand(val type:DocumentType,val displayName:DisplayName,val description:Description?=null,val attributes:Map<String,Any>=emptyMap()) data class UpdateDocumentCommand(val displayName:DisplayName?=null,val description:Description?=null,val attributes:Map<String,Any>?=null) data class ChangeStatusCommand(val targetStatus:DocumentStatus,val reason:String?=null,val attributes:Map<String,Any>=emptyMap()) data class DocumentSearchCriteria(val types:Set<DocumentType>?=null,val statuses:Set<DocumentStatus>?=null,val fromDate:Instant?=null,val toDate:Instant?=null,val pageSize:Int=20,val page:Int=0) 
File: ./domain/core/ad/shared/values/ProcessName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.shared.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class ProcessName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ProcessName>=when {value.isBlank()->ValidationError.InvalidFormat("Process name cannot be blank").left() value.length> 50->ValidationError.InvalidLength("Process name",1,50).left() else->ProcessName(value).right()}}} 
File: ./domain/core/ad/metadata/entities/ADStatusLine.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.entities import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.base.ADObject import java.util.UUID /** * Defines document status transitions and rules * Part of the AD metadata-driven document lifecycle framework */ data class ADStatusLine(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val documentType:String, // Target document type val fromStatus:String, // Source status val toStatus:String, // Target status val roleId:UUID?, // Required role for transition val conditions:List<String>, // Rule IDs to evaluate val sequence:Int=0, // Processing sequence val isActive:Boolean=true) :ADObject {override val id:String get()=uuid.toString()} 
File: ./domain/core/ad/metadata/entities/ADValidationRule.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.entities import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.base.ADObject import java.util.UUID /** * Defines field-level validation rules * Part of the AD metadata-driven validation framework */ data class ADValidationRule(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val entityType:String, // Target entity type val fieldName:String, // Target field name val expression:String, // Validation expression val errorMessage:String, // Error message on validation failure val isActive:Boolean=true) :ADObject {override val id:String get()=uuid.toString()} 
File: ./domain/core/ad/metadata/entities/ADRule.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.entities import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.base.ADObject import java.util.UUID /** * Defines a business rule that can be evaluated at runtime * Part of the AD metadata-driven validation framework */ data class ADRule(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val ruleType:String, // e.g. VALIDATION,CALCULATION,WORKFLOW val entityType:String, // Target entity type val expression:String, // Rule expression/script val errorMessage:String?, // Custom error message val parameters:List<RuleParameter>=emptyList()) :ADObject {override val id:String get()=uuid.toString()} data class RuleParameter(val name:String,val dataType:DataType,val mandatory:Boolean=false,val defaultValue:String?=null) 
File: ./domain/core/ad/metadata/operations/MetadataOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.operations import org.blackerp.domain.core.ad.metadata.entities.* import org.blackerp.domain.core.ad.metadata.services.MetadataError import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface MetadataOperations {// Rule operations suspend fun saveRule(rule:ADRule):Either<MetadataError,ADRule> suspend fun findRuleById(id:UUID):Either<MetadataError,ADRule?> suspend fun findRulesByType(entityType:String):Flow<ADRule> suspend fun deleteRule(id:UUID):Either<MetadataError,Unit> // Validation operations suspend fun saveValidation(rule:ADValidationRule):Either<MetadataError,ADValidationRule> suspend fun findValidationsByEntity(entityType:String):Flow<ADValidationRule> // Status operations suspend fun saveStatusLine(status:ADStatusLine):Either<MetadataError,ADStatusLine> suspend fun findStatusFlow(documentType:String):Flow<ADStatusLine>} 
File: ./domain/core/ad/metadata/services/RuleEvaluator.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.services import arrow.core.Either import org.blackerp.domain.core.ad.metadata.entities.ADRule import org.blackerp.domain.core.shared.ValidationError interface RuleEvaluator {suspend fun evaluate(rule:ADRule,context:Map<String,Any>):Either<ValidationError,Boolean> suspend fun validateParameters(rule:ADRule,parameters:Map<String,Any>):Either<ValidationError,Map<String,Any>>} 
File: ./domain/core/ad/metadata/services/MetadataService.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.services import org.blackerp.domain.core.ad.metadata.entities.* import kotlinx.coroutines.flow.Flow import arrow.core.Either import java.util.UUID interface MetadataService {suspend fun getRules(entityType:String):Flow<ADRule> suspend fun getRule(id:UUID):Either<MetadataError,ADRule?> suspend fun getValidations(entityType:String):Flow<ADValidationRule> suspend fun getStatusFlow(documentType:String):Flow<ADStatusLine>} sealed class MetadataError(message:String) {data class NotFound(val id:String) :MetadataError("Metadata not found:$id") data class ValidationFailed(val details:String) :MetadataError(details) data class AccessDenied(val details:String) :MetadataError(details)} 
File: ./domain/core/ad/metadata/repositories/MetadataRepository.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.repositories import org.blackerp.domain.core.ad.metadata.entities.* import org.blackerp.domain.core.ad.metadata.services.MetadataError import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface MetadataRepository {// Base metadata operations suspend fun <T :Any> save(entity:T):Either<MetadataError,T> suspend fun <T :Any> findById(id:UUID,type:Class<T>):Either<MetadataError,T?> // Rule specific operations suspend fun findRulesByType(entityType:String):Flow<ADRule> suspend fun findRulesByIds(ids:List<UUID>):Flow<ADRule> // Validation specific operations suspend fun findValidationsByEntity(entityType:String):Flow<ADValidationRule> // Status specific operations suspend fun findStatusLines(documentType:String):Flow<ADStatusLine> suspend fun findStatusTransitions(documentType:String,fromStatus:String):Flow<ADStatusLine>} 
File: ./domain/core/ad/metadata/expression/ExpressionParser.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.expression import arrow.core.Either import org.blackerp.domain.core.shared.ValidationError sealed interface Token {data class Variable(val name:String) :Token data class Literal(val value:Any) :Token data class Operator(val symbol:String) :Token data class Function(val name:String) :Token object LeftParen :Token object RightParen :Token} interface ExpressionParser {fun parse(expression:String):Either<ValidationError,List<Token>> fun validateSyntax(tokens:List<Token>):Either<ValidationError,Unit>} 
File: ./domain/core/ad/metadata/expression/ExpressionEngine.kt
-------------------------------------------
package org.blackerp.domain.core.ad.metadata.expression import arrow.core.Either import org.blackerp.domain.core.shared.ValidationError interface ExpressionEngine {suspend fun evaluate(expression:String,context:Map<String,Any>):Either<ValidationError,ExpressionResult> suspend fun validateExpression(expression:String):Either<ValidationError,Unit>} sealed interface ExpressionResult {val value:Any data class BooleanResult(override val value:Boolean) :ExpressionResult data class NumericResult(override val value:Number) :ExpressionResult data class StringResult(override val value:String) :ExpressionResult data class DateResult(override val value:java.time.temporal.Temporal) :ExpressionResult} 
File: ./domain/core/ad/base/ADModule.kt
-------------------------------------------
package org.blackerp.domain.core.ad.base import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.Version import java.util.UUID data class ADModule(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),val name:ModuleName,override val displayName:DisplayName,override val description:Description?,val version:Version) :ADObject {override val id:String get()=uuid.toString()} 
File: ./domain/core/ad/base/ModuleName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.base import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class ModuleName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ModuleName>=when {!value.matches(Regex("^[a-z][a-z0-9-]*$"))->ValidationError.InvalidFormat("Module name must start with lowercase letter and contain only lowercase letters,numbers,and hyphens").left() value.length !in 3..50->ValidationError.InvalidLength("module name",3,50).left() else->ModuleName(value).right()}}} 
File: ./domain/core/ad/base/ADObject.kt
-------------------------------------------
package org.blackerp.domain.core.ad.base import org.blackerp.domain.core.DomainEntity import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description interface ADObject :DomainEntity {override val id:String val metadata:EntityMetadata val displayName:DisplayName val description:Description?} 
File: ./domain/core/ad/base/ModuleService.kt
-------------------------------------------
package org.blackerp.domain.core.ad.base import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.Version import java.util.UUID interface ModuleService {suspend fun createModule(command:CreateModuleCommand):Either<DomainError,ADModule> suspend fun updateModule(id:UUID,command:UpdateModuleCommand):Either<DomainError,ADModule> suspend fun getModules(active:Boolean?=null):Flow<ADModule>} data class CreateModuleCommand(val name:ModuleName,val displayName:DisplayName,val description:Description?=null,val version:Version,val dependencies:Set<ModuleDependency>=emptySet()) data class UpdateModuleCommand(val displayName:DisplayName?=null,val description:Description?=null,val version:Version?=null) data class ModuleDependency(val moduleName:ModuleName,val version:Version) 
File: ./domain/core/ad/tab/TabOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import arrow.core.Either import org.blackerp.domain.core.values.TableName import java.util.UUID interface TabOperations {suspend fun save(tab:ADTab):Either<TabError,ADTab> suspend fun findById(id:UUID):Either<TabError,ADTab?> suspend fun findByTable(tableName:TableName):Either<TabError,List<ADTab>> suspend fun delete(id:UUID):Either<TabError,Unit>} 
File: ./domain/core/ad/tab/TabService.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.values.TabName import java.util.UUID interface TabService {suspend fun createTab(command:CreateTabCommand):Either<TabError,ADTab> suspend fun updateTab(id:UUID,command:UpdateTabCommand):Either<TabError,ADTab> suspend fun findByName(name:TabName):Either<TabError,ADTab?> suspend fun findById(id:UUID):Either<TabError,ADTab?> suspend fun listTabs(criteria:TabSearchCriteria):Flow<ADTab> suspend fun deleteTab(id:UUID):Either<TabError,Unit>} data class CreateTabCommand(val displayName:String,val name:String,val description:String?,val tableId:UUID,val sequence:Int=10,val fields:List<CreateFieldCommand>=emptyList()) data class UpdateTabCommand(val displayName:String?,val description:String?,val sequence:Int?,val fields:List<UpdateFieldCommand>?) data class TabSearchCriteria(val windowId:UUID?=null,val tableId:UUID?=null,val namePattern:String?=null,val pageSize:Int=20,val page:Int=0) data class CreateFieldCommand(val columnName:String,val displayName:String,val description:String?,val sequence:Int=10,val isDisplayed:Boolean=true,val isReadOnly:Boolean=false,val isMandatory:Boolean=false) data class UpdateFieldCommand(val id:UUID,val displayName:String?,val description:String?,val sequence:Int?,val isDisplayed:Boolean?,val isReadOnly:Boolean?,val isMandatory:Boolean?) 
File: ./domain/core/ad/tab/OrderBySpec.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import org.blackerp.domain.core.values.ColumnName data class OrderBySpec(val column:ColumnName,val direction:SortDirection) enum class SortDirection {ASC,DESC;companion object {fun fromString(value:String):SortDirection=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid sort direction:$value")}} 
File: ./domain/core/ad/tab/value/TabName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class TabName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TabName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Tab name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("tab name",3,50).left() else->TabName(value).right()}}} 
File: ./domain/core/ad/tab/TabError.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import org.blackerp.domain.core.DomainException import org.blackerp.domain.core.shared.ValidationError sealed class TabError(message:String) :DomainException(message) {data class ValidationFailed(val errors:List<ValidationError>) :TabError(errors.joinToString {it.message}) data class NotFound(val id:String) :TabError("Tab not found:$id") data class DuplicateTab(val name:String) :TabError("Tab already exists:$name")} 
File: ./domain/core/ad/tab/ADTab.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.window.WindowField import java.util.UUID /** * Represents a Tab within a Window. Tabs are containers for fields and * provide data view/entry capabilities. */ data class ADTab(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val name:TabName,val tableId:UUID,val sequence:Int=10,val fields:List<WindowField>=emptyList(),val readOnly:Boolean=false,val singleRow:Boolean=false,val orderByClause:String?=null) :ADObject {override val id:String get()=uuid.toString() companion object {fun create(metadata:EntityMetadata,displayName:DisplayName,name:TabName,description:Description?,tableId:UUID,sequence:Int=10):Either<TabError,ADTab> {return ADTab(metadata=metadata,displayName=displayName,description=description,name=name,tableId=tableId,sequence=sequence).right()}}} 
File: ./domain/core/ad/table/TableOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.TableError import java.util.UUID interface TableOperations {suspend fun findAll():Either<TableError,List<ADTable>> suspend fun findById(id:UUID):Either<TableError,ADTable?> suspend fun save(table:ADTable):Either<TableError,ADTable> suspend fun delete(id:UUID):Either<TableError,Unit>} interface TableValidator {suspend fun validateCreate(command:org.blackerp.domain.core.ad.table.CreateTableCommand):Either<TableError,org.blackerp.domain.core.ad.table.CreateTableCommand> suspend fun validateUpdate(id:UUID,command:org.blackerp.domain.core.ad.table.UpdateTableCommand):Either<TableError,org.blackerp.domain.core.ad.table.UpdateTableCommand>}
File: ./domain/core/ad/table/ADTable.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.error.TableError import java.util.UUID data class ADTable(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val name:TableName,val accessLevel:AccessLevel,val columns:List<ColumnDefinition>=emptyList(),val constraints:List<TableConstraint>=emptyList()) :ADObject {override val id:String get()=uuid.toString()} 
File: ./domain/core/ad/table/TableConstraint.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.blackerp.domain.core.error.TableError data class TableConstraint(val id:UUID,val tableId:UUID,val name:String,val type:ConstraintType,val columns:List<String>,val expression:String?) {companion object {fun create(params:CreateConstraintParams):Either<TableError,TableConstraint> {if (params.columns.isEmpty() && params.expression == null) {return TableError.ValidationError(message="Constraint must specify either columns or expression",violations=listOf(TableError.Violation("constraint","No columns or expression specified",params.name))).left()} return TableConstraint(id=UUID.randomUUID(),tableId=params.tableId,name=params.name,type=params.type,columns=params.columns,expression=params.expression).right()}}} enum class ConstraintType {UNIQUE,CHECK,FOREIGN_KEY} data class CreateConstraintParams(val tableId:UUID,val name:String,val type:ConstraintType,val columns:List<String>=emptyList(),val expression:String?=null) 
File: ./domain/core/ad/table/TableRelationship.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.blackerp.domain.core.error.TableError data class TableRelationship(val id:UUID,val sourceTable:UUID,val targetTable:UUID,val type:RelationshipType,val sourceColumn:String,val targetColumn:String,val onDelete:CascadeType,val onUpdate:CascadeType) {companion object {fun create(params:CreateRelationshipParams):Either<TableError,TableRelationship> {if (params.sourceTable == params.targetTable) {return TableError.ValidationError(message="Self-referential relationships not supported",violations=listOf(TableError.Violation("targetTable","Cannot reference same table",params.targetTable))).left()} return TableRelationship(id=UUID.randomUUID(),sourceTable=params.sourceTable,targetTable=params.targetTable,type=params.type,sourceColumn=params.sourceColumn,targetColumn=params.targetColumn,onDelete=params.onDelete,onUpdate=params.onUpdate).right()}}} enum class RelationshipType {ONE_TO_ONE,ONE_TO_MANY,MANY_TO_ONE} enum class CascadeType {NO_ACTION,CASCADE,SET_NULL,RESTRICT} data class CreateRelationshipParams(val sourceTable:UUID,val targetTable:UUID,val type:RelationshipType,val sourceColumn:String,val targetColumn:String,val onDelete:CascadeType=CascadeType.NO_ACTION,val onUpdate:CascadeType=CascadeType.NO_ACTION) 
File: ./domain/core/ad/table/commands.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import org.blackerp.domain.core.values.* data class CreateTableCommand(val name:TableName,val displayName:DisplayName,val description:Description?=null,val accessLevel:AccessLevel,val columns:List<CreateColumnCommand>) data class UpdateTableCommand(val displayName:DisplayName?=null,val description:Description?=null,val columns:List<UpdateColumnCommand>?=null) data class CreateColumnCommand(val name:String,val displayName:String,val description:String?,val dataType:String,val mandatory:Boolean=false,val length:Int?=null,val precision:Int?=null,val scale:Int?=null) data class UpdateColumnCommand(val name:String?,val displayName:String?,val description:String?,val mandatory:Boolean?)
File: ./domain/core/ad/table/ColumnDefinition.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table data class ColumnDefinition(val name:String,val dataType:String,val length:Int?=null) 
File: ./domain/core/ad/table/ConstraintOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import org.blackerp.domain.core.error.TableError import java.util.UUID interface ConstraintOperations {suspend fun save(constraint:TableConstraint):Either<TableError,TableConstraint> suspend fun findByTable(tableId:UUID):Either<TableError,List<TableConstraint>> suspend fun delete(id:UUID):Either<TableError,Unit> suspend fun validateConstraint(constraint:TableConstraint):Either<TableError,Unit>} 
File: ./domain/core/ad/table/RelationshipOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import org.blackerp.domain.core.error.TableError import java.util.UUID interface RelationshipOperations {suspend fun save(relationship:TableRelationship):Either<TableError,TableRelationship> suspend fun findBySourceTable(tableId:UUID):Either<TableError,List<TableRelationship>> suspend fun findByTargetTable(tableId:UUID):Either<TableError,List<TableRelationship>> suspend fun delete(id:UUID):Either<TableError,Unit>} 
File: ./domain/core/ad/workflow/WorkflowNode.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.shared.EntityMetadata import arrow.core.Either import arrow.core.right import java.util.UUID data class WorkflowNode(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val type:NodeType,val action:NodeAction?,val transitions:List<WorkflowTransition>) :ADObject {override val id:String get()=uuid.toString()} data class CreateNodeParams(val metadata:EntityMetadata,val displayName:DisplayName,val description:Description?,val type:NodeType,val action:NodeAction?,val transitions:List<WorkflowTransition>) 
File: ./domain/core/ad/workflow/NodeType.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow enum class NodeType {START,ACTIVITY,DECISION,END} 
File: ./domain/core/ad/workflow/WorkflowError.kt
-------------------------------------------
// domain/core/ad/workflow/WorkflowError.kt package org.blackerp.domain.core.ad.workflow import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class WorkflowError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class NotFound(val id:UUID) :WorkflowError("Workflow node not found:$id","WF_NOT_FOUND") data class ValidationFailed(val details:String) :WorkflowError("Workflow validation failed:$details","WF_VALIDATION_FAILED") data class CyclicDependency(val nodeIds:List<UUID>) :WorkflowError("Cyclic dependency detected in workflow:${nodeIds.joinToString()}","WF_CYCLIC_DEPENDENCY")} 
File: ./domain/core/ad/workflow/WorkflowOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import arrow.core.Either import java.util.UUID interface WorkflowOperations {suspend fun save(node:WorkflowNode):Either<WorkflowError,WorkflowNode> suspend fun findById(id:UUID):Either<WorkflowError,WorkflowNode?> suspend fun delete(id:UUID):Either<WorkflowError,Unit> suspend fun validateWorkflow(nodes:List<WorkflowNode>):Either<WorkflowError,Unit>} 
File: ./domain/core/ad/workflow/WorkflowService.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.ad.document.Document import java.util.UUID interface WorkflowService {suspend fun createWorkflow(command:CreateWorkflowCommand):Either<WorkflowError,WorkflowNode> suspend fun updateWorkflow(id:UUID,command:UpdateWorkflowCommand):Either<WorkflowError,WorkflowNode> suspend fun validateWorkflow(id:UUID):Either<WorkflowError,ValidationResult> suspend fun executeWorkflow(id:UUID,context:WorkflowContext):Either<WorkflowError,WorkflowResult>} data class CreateWorkflowCommand(val displayName:DisplayName,val description:Description?=null,val nodes:List<CreateNodeCommand>,val transitions:List<CreateTransitionCommand>) data class UpdateWorkflowCommand(val displayName:DisplayName?=null,val description:Description?=null,val nodes:List<UpdateNodeCommand>?=null,val transitions:List<UpdateTransitionCommand>?=null) data class ValidationResult(val valid:Boolean,val errors:List<ValidationError>=emptyList()) data class WorkflowContext(val document:Document,val attributes:Map<String,Any>=emptyMap(),val user:String) data class WorkflowResult(val completed:Boolean,val currentNode:UUID,val nextNodes:List<UUID>,val attributes:Map<String,Any>) 
File: ./domain/core/ad/workflow/metadata/WorkflowMetadata.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow.metadata import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.AccessLevel import java.util.UUID /** * AD-driven workflow metadata. * Following iDempiere's AD design principle where all workflow definitions * are stored as metadata,isolating business process definitions from code. */ interface WorkflowMetadata :ADObject {val name:String val accessLevel:AccessLevel val nodes:List<NodeMetadata> val transitions:List<TransitionMetadata>} data class NodeMetadata(val id:UUID,val name:String,val actionType:String,val actionMetadata:Map<String,Any>,val conditions:List<ConditionMetadata>) data class TransitionMetadata(val fromNodeId:UUID,val toNodeId:UUID,val conditions:List<ConditionMetadata>) data class ConditionMetadata(val type:String,val expression:String,val parameters:Map<String,Any>) 
File: ./domain/core/ad/workflow/metadata/WorkflowMetadataProvider.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow.metadata import arrow.core.Either import org.blackerp.domain.core.error.WorkflowError import java.util.UUID /** * Provides access to AD workflow metadata. * Follows iDempiere pattern where workflow behavior is driven by metadata,* not code changes. */ interface WorkflowMetadataProvider {suspend fun getWorkflowMetadata(documentId:UUID):Either<WorkflowError,WorkflowMetadata> suspend fun getNodeMetadata(nodeId:UUID):Either<WorkflowError,NodeMetadata> suspend fun getTransitionMetadata(fromNode:UUID,toNode:UUID):Either<WorkflowError,TransitionMetadata>} 
File: ./domain/core/ad/workflow/commands.kt
-------------------------------------------
// domain/core/ad/workflow/commands.kt package org.blackerp.domain.core.ad.workflow import java.util.UUID data class CreateNodeCommand(val type:NodeType,val displayName:String,val description:String?,val action:NodeAction?) data class UpdateNodeCommand(val displayName:String?,val description:String?,val action:NodeAction?) data class CreateTransitionCommand(val fromNode:UUID,val toNode:UUID,val condition:String?) data class UpdateTransitionCommand(val condition:String?) 
File: ./domain/core/ad/workflow/WorkflowTransition.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import java.util.UUID data class WorkflowTransition(val id:UUID,val sourceNode:UUID,val targetNode:UUID,val condition:TransitionCondition?) data class TransitionCondition(val expression:String,val description:String) 
File: ./domain/core/ad/workflow/NodeAction.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import java.util.UUID sealed interface NodeAction {data class Process(val processId:UUID) :NodeAction data class UserTask(val roleId:UUID) :NodeAction data class Notification(val template:String) :NodeAction} 
File: ./domain/core/ad/reference/ReferenceTypes.kt
-------------------------------------------
package org.blackerp.domain.core.ad.reference sealed interface ReferenceType {object List :ReferenceType data class Table(val tableName:String,val keyColumn:String,val displayColumn:String,val whereClause:String?=null,val orderBy:String?=null) :ReferenceType object Search :ReferenceType data class Custom(val validatorClass:String,val config:Map<String,String>=emptyMap()) :ReferenceType} sealed class ReferenceError {abstract val message:String data class ValidationFailed(override val message:String) :ReferenceError() data class NotFound(val id:String) :ReferenceError() {override val message="Reference not found:$id"} data class DuplicateReference(val name:String) :ReferenceError() {override val message="Reference already exists:$name"}} data class ReferenceValue<T>(val key:T,val display:String,val additionalData:Map<String,Any>=emptyMap()) 
File: ./domain/core/ad/reference/ReferenceOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.reference import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface ReferenceOperations {suspend fun save(reference:ADReference):Either<ReferenceError,ADReference> suspend fun findById(id:UUID):Either<ReferenceError,ADReference?> suspend fun findByName(name:String):Either<ReferenceError,ADReference?> suspend fun search(query:String,pageSize:Int=20,page:Int=0):Flow<ADReference> suspend fun getValues(referenceId:UUID,searchText:String?=null,pageSize:Int=20,page:Int=0):Either<ReferenceError,List<ReferenceValue<*>>> suspend fun validateValue(referenceId:UUID,value:Any):Either<ReferenceError,Boolean> suspend fun getHierarchy(rootId:UUID?=null):Either<ReferenceError,List<ADReference>> suspend fun delete(id:UUID):Either<ReferenceError,Unit>} interface ReferenceRepository {suspend fun save(reference:ADReference):Either<ReferenceError,ADReference> suspend fun findById(id:UUID):Either<ReferenceError,ADReference?> suspend fun findByName(name:String):Either<ReferenceError,ADReference?> suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADReference> suspend fun delete(id:UUID):Either<ReferenceError,Unit>} interface ReferenceCache {suspend fun get(key:String):Any? suspend fun put(key:String,value:Any,ttlSeconds:Long?=null) suspend fun remove(key:String) suspend fun clear()} 
File: ./domain/core/ad/reference/value/ReferenceName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.reference.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class ReferenceName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ReferenceName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Reference name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("reference name",3,50).left() else->ReferenceName(value).right()}}} 
File: ./domain/core/ad/reference/ADReference.kt
-------------------------------------------
package org.blackerp.domain.core.ad.reference import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.shared.ValidationError import arrow.core.Either import arrow.core.right import java.util.UUID data class ADReference(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val type:ReferenceType,val validationRule:ValidationRule?,val isActive:Boolean=true,val parentId:UUID?=null,val sortOrder:Int=0) :ADObject {override val id:String get()=uuid.toString()} data class ValidationRule(val expression:String,val errorMessage:String,val parameters:Map<String,String>=emptyMap()) 
File: ./domain/core/DomainException.kt
-------------------------------------------
// domain/core/DomainException.kt package org.blackerp.domain.core import arrow.core.Either import arrow.core.left abstract class DomainException(message:String) :Exception(message) {fun <T> toEither():Either<DomainException,T>=this.left()} 
File: ./domain/core/error/PluginError.kt
-------------------------------------------
package org.blackerp.domain.core.error sealed class PluginError {data class NotFound(val id:String) :PluginError() data class RegistrationFailed(val id:String,val cause:Throwable) :PluginError() data class LoadFailed(val message:String) :PluginError() data class StartupFailed(val id:String,val cause:Throwable) :PluginError() data class ShutdownFailed(val id:String,val cause:Throwable) :PluginError() data class DependencyError(val id:String,val missingDependency:String) :PluginError()} 
File: ./domain/core/error/TableErrors.kt
-------------------------------------------
package org.blackerp.domain.core.error sealed class TableError :DomainError("Table operation failed") {data class ValidationError(override val message:String,val violations:List<Violation>) :TableError() data class ConstraintViolation(override val message:String,val constraintName:String,val details:String) :TableError() data class DatabaseError(override val message:String,val sqlState:String?,val errorCode:Int?) :TableError() data class InvalidMetadata(override val message:String,val field:String) :TableError() data class Violation(val field:String,val message:String,val value:Any?=null)} 
File: ./domain/core/error/DomainError.kt
-------------------------------------------
// File:domain/core/error/DomainError.kt package org.blackerp.domain.core.error abstract class DomainError(open val message:String,open val code:String?=null,open val cause:Throwable?=null) 
File: ./domain/core/error/WorkflowErrors.kt
-------------------------------------------
package org.blackerp.domain.core.error import org.blackerp.domain.core.DomainException sealed class WorkflowError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class ValidationError(override val message:String,val field:String?=null) :WorkflowError(message) data class NotFoundError(override val message:String,val id:String) :WorkflowError(message) data class ProcessingError(override val message:String,override val cause:Throwable?=null) :WorkflowError(message) data class ConcurrencyError(override val message:String,val entityId:String,val expectedVersion:Int,val actualVersion:Int) :WorkflowError(message)} 
File: ./domain/core/error/UnexpectedError.kt
-------------------------------------------
package org.blackerp.domain.core.error class UnexpectedError(message:String) :DomainError(message) 
File: ./domain/core/error/WindowError.kt
-------------------------------------------
// File:domain/core/error/WindowError.kt package org.blackerp.domain.core.error import java.util.UUID sealed class WindowError(message:String) :DomainError(message) {data class ValidationFailed(val details:String) :WindowError(details) data class NotFound(val id:UUID) :WindowError("Window not found:$id") data class DuplicateWindow(val name:String) :WindowError("Window already exists:$name")} 
File: ./domain/core/error/ProcessError.kt
-------------------------------------------
package org.blackerp.domain.core.error sealed class ProcessError(message:String) :DomainError(message) {data class ValidationFailed(val details:String) :ProcessError("Process validation failed:$details") data class ExecutionFailed(val details:String) :ProcessError("Process execution failed:$details") data class NotFound(val id:String) :ProcessError("Process not found:$id")} 
File: ./domain/core/tenant/TenantAware.kt
-------------------------------------------
// domain-entities/src/main/kotlin/org/blackerp/domain/tenant/TenantAware.kt package org.blackerp.domain.core.tenant import java.util.UUID interface TenantAware {val tenantId:UUID}
File: ./domain/core/values/DataType.kt
-------------------------------------------
package org.blackerp.domain.core.values enum class DataType {STRING,INTEGER,DECIMAL,BOOLEAN,DATE,TIMESTAMP,BINARY;companion object {fun fromString(value:String):DataType=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid data type:$value")}} 
File: ./domain/core/values/Precision.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class Precision private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Precision>=when {value <0->ValidationError.InvalidValue("Precision cannot be negative").left() value> 20->ValidationError.InvalidValue("Precision cannot exceed 20").left() else->Precision(value).right()}}} 
File: ./domain/core/values/AccessLevel.kt
-------------------------------------------
package org.blackerp.domain.core.values enum class AccessLevel {SYSTEM,CLIENT,ORGANIZATION,CLIENT_ORGANIZATION;companion object {fun fromString(value:String):AccessLevel=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid access level:$value")}} 
File: ./domain/core/values/Description.kt
-------------------------------------------
// domain/core/values/Description.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class Description private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,Description>=when {value.length> 255->ValidationError.InvalidLength("description",0,255).left() else->Description(value).right()}}} 
File: ./domain/core/values/Amount.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError import java.math.BigDecimal @JvmInline value class Amount private constructor(val value:BigDecimal) {companion object {fun create(value:BigDecimal):Either<ValidationError,Amount>=when {value <BigDecimal.ZERO->ValidationError.InvalidValue("Amount cannot be negative").left() else->Amount(value).right()}}} 
File: ./domain/core/values/ColumnName.kt
-------------------------------------------
// domain/core/values/ColumnName.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class ColumnName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ColumnName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Column name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length> 30->ValidationError.InvalidLength("column name",1,30).left() else->ColumnName(value).right()}}} 
File: ./domain/core/values/Scale.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.shared.ValidationError.InvalidValue @JvmInline value class Scale private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Scale>=when {value <0->ValidationError.InvalidValue("Scale cannot be negative").left() value> 10->ValidationError.InvalidValue("Scale cannot exceed 10").left() else->Scale(value).right()}}} 
File: ./domain/core/values/Length.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class Length private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Length>=when {value <= 0->ValidationError.InvalidValue("Length must be positive").left() else->Length(value).right()}}} 
File: ./domain/core/values/TableName.kt
-------------------------------------------
// domain/core/values/TableName.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class TableName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TableName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Table name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..60->ValidationError.InvalidLength("table name",3,60).left() else->TableName(value).right()}}} 
File: ./domain/core/values/Currency.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class Currency private constructor(val code:String) {companion object {fun create(code:String):Either<ValidationError,Currency>=when {!code.matches(Regex("^[A-Z]{3}$"))->ValidationError.InvalidFormat("Currency code must be 3 uppercase letters").left() else->Currency(code).right()}}} 
File: ./domain/core/values/TabName.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class TabName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TabName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Tab name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("tab name",3,50).left() else->TabName(value).right()}}} 
File: ./domain/core/values/DisplayName.kt
-------------------------------------------
// domain/core/values/DisplayName.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class DisplayName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,DisplayName>=when {value.isBlank()->ValidationError.Required("display name").left() value.length !in 1..60->ValidationError.InvalidLength("display name",1,60).left() else->DisplayName(value).right()}}} 
File: ./domain/core/plugin/PluginRegistry.kt
-------------------------------------------
package org.blackerp.domain.core.plugin import arrow.core.Either import org.blackerp.domain.core.error.PluginError interface PluginRegistry {suspend fun register(plugin:PluginDefinition):Either<PluginError,Unit> suspend fun getPlugin(id:String):Either<PluginError,PluginDefinition?> suspend fun loadPlugins():Either<PluginError,Unit> suspend fun startPlugin(id:String):Either<PluginError,Unit> suspend fun stopPlugin(id:String):Either<PluginError,Unit>} 
File: ./domain/core/plugin/PluginDefinition.kt
-------------------------------------------
package org.blackerp.domain.core.plugin import org.blackerp.domain.core.Version interface PluginDefinition {val id:String val version:Version val dependencies:Set<PluginDependency> fun initialize(context:PluginContext) fun start() fun stop()} data class PluginDependency(val pluginId:String,val version:Version) interface PluginContext {fun getPlugin(id:String):PluginDefinition? fun getConfiguration(key:String):String?} 
File: ./domain/core/audit/AuditLog.kt
-------------------------------------------
package org.blackerp.domain.core.audit import java.time.Instant import java.util.UUID data class AuditLog(val id:UUID=UUID.randomUUID(),val timestamp:Instant=Instant.now(),val entityType:String,val entityId:UUID,val action:String,val userId:UUID,val username:String,val clientId:UUID,val organizationId:UUID?,val oldValue:String?,val newValue:String?,val metadata:Map<String,String>=emptyMap()) interface AuditLogger {suspend fun log(entry:AuditLog) suspend fun getAuditTrail(entityType:String,entityId:UUID,fromDate:Instant?=null,toDate:Instant?=null):List<AuditLog>} 
File: ./domain/core/DomainEntity.kt
-------------------------------------------
// domain/core/DomainEntity.kt package org.blackerp.domain.core interface DomainEntity {val id:String} 
File: ./domain/core/shared/ValidationError.kt
-------------------------------------------
package org.blackerp.domain.core.shared sealed class ValidationError(val message:String) {data class InvalidFormat(val details:String) :ValidationError(details) data class InvalidLength(val field:String,val min:Int,val max:Int) :ValidationError("Field '$field' must be between $min and $max characters") data class Required(val field:String) :ValidationError("Field '$field' is required") data class InvalidValue(val details:String) :ValidationError(details)} 
File: ./domain/core/shared/ChangePair.kt
-------------------------------------------
package org.blackerp.domain.core.shared data class ChangePair<T>(val oldValue:T,val newValue:T) {val hasChanged:Boolean=oldValue != newValue} 
File: ./domain/core/shared/EntityMetadata.kt
-------------------------------------------
package org.blackerp.domain.core.shared import java.time.Instant import java.util.UUID import org.blackerp.domain.core.DomainEntity data class AuditInfo(val createdAt:Instant=Instant.now(),val createdBy:String,val updatedAt:Instant=Instant.now(),val updatedBy:String) data class VersionInfo(val version:Int=1,val active:Boolean=true) data class EntityMetadata(override val id:String=UUID.randomUUID().toString(),val audit:AuditInfo,val version:VersionInfo=VersionInfo()) :DomainEntity 
File: ./domain/core/metadata/ChangeTracking.kt
-------------------------------------------
package org.blackerp.domain.core.metadata import java.time.Instant import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.shared.AuditInfo interface ChangeTrackable {val metadata:EntityMetadata fun withUpdatedBy(user:String):ChangeTrackable} fun EntityMetadata.update(user:String):EntityMetadata {return copy(audit=audit.copy(updatedAt=Instant.now(),updatedBy=user),version=version.copy(version=version.version + 1))} 
File: ./domain/core/service/TableManagementService.kt
-------------------------------------------
package org.blackerp.domain.core.service import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.TableError import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.values.* import java.util.UUID interface TableManagementService {suspend fun createTable(command:org.blackerp.domain.core.ad.table.CreateTableCommand):Either<TableError,ADTable> suspend fun updateTable(id:UUID,command:org.blackerp.domain.core.ad.table.UpdateTableCommand):Either<TableError,ADTable> suspend fun deleteTable(id:UUID):Either<TableError,Unit> suspend fun getTable(id:UUID):Either<TableError,ADTable?> suspend fun findTables(criteria:TableSearchCriteria):Flow<ADTable>} data class TableSearchCriteria(val namePattern:String?=null,val accessLevel:AccessLevel?=null,val modifiedSince:java.time.Instant?=null,val pageSize:Int=20,val page:Int=0)
File: ./domain/core/repository/ColumnOperations.kt
-------------------------------------------
package org.blackerp.domain.core.repository import arrow.core.Either import org.blackerp.domain.core.ad.table.ColumnDefinition import org.blackerp.domain.core.error.TableError import java.util.UUID interface ColumnOperations {suspend fun save(tableId:UUID,column:ColumnDefinition):Either<TableError,ColumnDefinition> suspend fun findByTable(tableId:UUID):Either<TableError,List<ColumnDefinition>> suspend fun delete(tableId:UUID,columnName:String):Either<TableError,Unit>} 
File: ./domain/core/security/SecurityModel.kt
-------------------------------------------
package org.blackerp.domain.core.security import java.util.UUID import java.time.Instant data class User(val id:UUID=UUID.randomUUID(),val username:String,val email:String,val isActive:Boolean=true,val roles:Set<Role>,val clientId:UUID,val organizationId:UUID?,val lastLogin:Instant?=null) data class Role(val id:UUID=UUID.randomUUID(),val name:String,val permissions:Set<Permission>,val scope:SecurityScope) data class Permission(val id:UUID=UUID.randomUUID(),val code:String,val description:String,val type:PermissionType) enum class PermissionType {READ,WRITE,DELETE,EXECUTE,ADMIN} enum class SecurityScope {SYSTEM,CLIENT,ORGANIZATION} data class SecurityContext(val user:User,val clientId:UUID,val organizationId:UUID?,val roles:Set<Role>) {fun hasPermission(permission:String):Boolean=roles.any {role->role.permissions.any {it.code == permission}}} 
File: ./domain/core/security/UserRepository.kt
-------------------------------------------
package org.blackerp.domain.core.security import arrow.core.Either import java.util.UUID interface UserRepository {suspend fun findByUsername(username:String):Either<SecurityError,User?> suspend fun findById(id:UUID):Either<SecurityError,User?> suspend fun save(user:User):Either<SecurityError,User>} 
File: ./domain/core/security/SecurityOperations.kt
-------------------------------------------
package org.blackerp.domain.core.security import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface SecurityOperations {suspend fun authenticate(credentials:Credentials):Either<SecurityError,AuthToken> suspend fun validateToken(token:String):Either<SecurityError,SecurityContext> suspend fun hasPermission(context:SecurityContext,permission:String):Boolean suspend fun getUserRoles(userId:UUID):Flow<Role> suspend fun getRolePermissions(roleId:UUID):Flow<Permission>} data class Credentials(val username:String,val password:String,val clientId:UUID) data class AuthToken(val token:String,val expiresAt:java.time.Instant,val refreshToken:String) sealed class SecurityError {data class InvalidCredentials(val message:String) :SecurityError() data class InvalidToken(val message:String) :SecurityError() data class InsufficientPermissions(val message:String) :SecurityError() data class UserNotFound(val message:String) :SecurityError() data class ValidationFailed(val message:String) :SecurityError() // Added this} 
File: ./domain/core/security/events/UserEvent.kt
-------------------------------------------
package org.blackerp.domain.core.security.events import org.blackerp.domain.events.DomainEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.domain.core.security.User sealed class UserEvent :DomainEvent {data class UserCreated(override val metadata:EventMetadata,val user:User) :UserEvent() data class UserUpdated(override val metadata:EventMetadata,val user:User) :UserEvent() data class UserLoginAttempted(override val metadata:EventMetadata,val username:String,val success:Boolean,val failureReason:String?) :UserEvent()} 
File: ./domain/core/security/DocumentAccessControl.kt
-------------------------------------------
// File:domain/core/security/DocumentAccessControl.kt package org.blackerp.domain.core.security import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import java.util.UUID sealed class AccessControlError {data class PermissionDenied(val message:String) :AccessControlError() data class ValidationFailed(val message:String) :AccessControlError()} class DocumentAccessControl {private val logger=LoggerFactory.getLogger(DocumentAccessControl::class.java) suspend fun checkAccess(context:SecurityContext,documentId:UUID,requiredPermission:String):Either<AccessControlError,Unit> {// Check basic permission if (!context.hasPermission(requiredPermission)) {return AccessControlError.PermissionDenied("Missing required permission:$requiredPermission").left()} // Basic document access validation using documentId if (!validateDocumentAccess(context,documentId)) {return AccessControlError.PermissionDenied("No access to document:$documentId").left()} return Unit.right()} private fun validateDocumentAccess(context:SecurityContext,documentId:UUID):Boolean {// Basic validation using context and documentId val clientId=context.clientId val organizationId=context.organizationId // Check if document belongs to client/org scope return try {// Mock validation for POC logger.debug("Validating access for document $documentId in client $clientId org $organizationId") true} catch (e:Exception) {logger.error("Access validation failed for document $documentId",e) false}} suspend fun checkBulkAccess(context:SecurityContext,documentIds:List<UUID>,requiredPermission:String):Map<UUID,Either<AccessControlError,Unit>>=documentIds.associateWith {documentId->checkAccess(context,documentId,requiredPermission)}}
File: ./domain/core/workflow/execution/WorkflowExecutionTracker.kt
-------------------------------------------
package org.blackerp.domain.core.workflow.execution import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory data class WorkflowExecution(val id:UUID=UUID.randomUUID(),val documentId:UUID,val workflowId:UUID,val startTime:Instant,val endTime:Instant?=null,val currentState:String,val history:List<StateTransitionRecord>=emptyList()) data class StateTransitionRecord(val fromState:String,val toState:String,val timestamp:Instant,val actor:String,val parameters:Map<String,Any>=emptyMap()) interface WorkflowExecutionRepository {suspend fun save(execution:WorkflowExecution):WorkflowExecution suspend fun findByDocumentId(documentId:UUID):WorkflowExecution? suspend fun addTransition(executionId:UUID,transition:StateTransitionRecord):WorkflowExecution} 
File: ./domain/core/workflow/state/WorkflowStateMachine.kt
-------------------------------------------
package org.blackerp.domain.core.workflow.state import org.blackerp.domain.core.security.SecurityContext import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID sealed class StateTransitionError {data class InvalidTransition(val message:String) :StateTransitionError() data class PermissionDenied(val message:String) :StateTransitionError() data class ValidationFailed(val message:String) :StateTransitionError()} data class WorkflowState(val id:UUID,val name:String,val allowedTransitions:Set<String>,val requiredPermissions:Set<String>,val validators:List<StateValidator>) interface StateValidator {suspend fun validate(context:SecurityContext,currentState:WorkflowState,targetState:WorkflowState,documentId:UUID):Either<StateTransitionError,Unit>} class WorkflowStateMachine(private val states:Map<String,WorkflowState>,private val initialState:String) {suspend fun transition(context:SecurityContext,currentStateName:String,targetStateName:String,documentId:UUID):Either<StateTransitionError,WorkflowState> {val currentState=states[currentStateName] ?:return StateTransitionError.InvalidTransition("Invalid current state:$currentStateName").left() val targetState=states[targetStateName] ?:return StateTransitionError.InvalidTransition("Invalid target state:$targetStateName").left() // Check if transition is allowed if (!currentState.allowedTransitions.contains(targetStateName)) {return StateTransitionError.InvalidTransition("Transition from $currentStateName to $targetStateName not allowed").left()} // Check permissions if (!hasRequiredPermissions(context,targetState.requiredPermissions)) {return StateTransitionError.PermissionDenied("Missing required permissions for state $targetStateName").left()} // Run validators currentState.validators.forEach {validator->validator.validate(context,currentState,targetState,documentId).fold({error->return error.left()},{/* continue validation */})} return targetState.right()} private fun hasRequiredPermissions(context:SecurityContext,requiredPermissions:Set<String>):Boolean=requiredPermissions.all {permission->context.hasPermission(permission)}} 
File: ./domain/core/workflow/transition/TransitionValidator.kt
-------------------------------------------
package org.blackerp.domain.core.workflow.transition import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.security.SecurityContext import java.util.UUID sealed class TransitionError(open val message:String) {data class InvalidTransition(override val message:String) :TransitionError(message) data class PermissionDenied(override val message:String) :TransitionError(message) data class ValidationFailed(override val message:String) :TransitionError(message)} interface TransitionValidator {suspend fun validate(fromState:String,toState:String,context:Map<String,Any>=emptyMap()):Either<TransitionError,StateTransition>} interface TransitionRepository {suspend fun findTransitions(fromState:String):List<StateTransition>} class DefaultTransitionValidator(private val transitionRepository:TransitionRepository,private val securityContext:SecurityContext) :TransitionValidator {override suspend fun validate(fromState:String,toState:String,context:Map<String,Any>):Either<TransitionError,StateTransition> {val transitions=transitionRepository.findTransitions(fromState) val transition=transitions.find {it.toState == toState} ?:return TransitionError.InvalidTransition("No transition defined from $fromState to $toState").left() transition.requiredRole?.let {role->if (!securityContext.hasPermission(role)) {return TransitionError.PermissionDenied("Missing required role:$role").left()}} transition.condition?.let {cond->if (!evaluateCondition(cond,context)) {return TransitionError.ValidationFailed("Transition condition not met:${cond.expression}").left()}} return transition.right()} private fun evaluateCondition(condition:TransitionCondition,context:Map<String,Any>):Boolean {// Implement condition evaluation return true}} 
File: ./domain/core/workflow/transition/StateTransition.kt
-------------------------------------------
package org.blackerp.domain.core.workflow.transition import org.blackerp.domain.core.shared.EntityMetadata import java.util.UUID data class StateTransition(val id:UUID=UUID.randomUUID(),val fromState:String,val toState:String,val requiredRole:String?=null,val condition:TransitionCondition?=null,val priority:Int=0) data class TransitionCondition(val expression:String,val parameters:Map<String,String>=emptyMap()) sealed class TransitionResult {data class Success(val newState:String) :TransitionResult() data class Failure(val reason:String) :TransitionResult()} 
File: ./domain/core/workflow/tracking/ExecutionStatus.kt
-------------------------------------------
package org.blackerp.domain.core.workflow.tracking enum class ExecutionStatus {PENDING,IN_PROGRESS,COMPLETED,FAILED,CANCELLED;fun isTerminal()=this in listOf(COMPLETED,FAILED,CANCELLED)} 
File: ./domain/core/workflow/tracking/WorkflowExecution.kt
-------------------------------------------
package org.blackerp.domain.core.workflow.tracking import java.time.Instant import java.util.UUID import org.blackerp.domain.core.DomainEntity import org.blackerp.domain.core.shared.EntityMetadata // Record of state transitions data class TransitionRecord(val fromNodeId:UUID,val toNodeId:UUID,val timestamp:Instant=Instant.now(),val actor:String,val attributes:Map<String,Any>=emptyMap()) // Domain interface for workflow execution tracking interface WorkflowExecution :DomainEntity {val workflowId:UUID val documentId:UUID val startTime:Instant val endTime:Instant? val currentNodeId:UUID? val status:ExecutionStatus val transitions:List<TransitionRecord>} // Concrete implementation for workflow execution tracking data class WorkflowExecutionImpl(val uuid:UUID=UUID.randomUUID(),val metadata:EntityMetadata,override val workflowId:UUID,override val documentId:UUID,override val startTime:Instant,override val endTime:Instant?=null,override val currentNodeId:UUID?=null,override val status:ExecutionStatus=ExecutionStatus.PENDING,override val transitions:List<TransitionRecord>=emptyList()) :WorkflowExecution {override val id:String get()=uuid.toString()} 
File: ./domain/core/Version.kt
-------------------------------------------
package org.blackerp.domain.core data class Version(val major:Int,val minor:Int,val patch:Int) {override fun toString()="$major.$minor.$patch"} 
File: ./domain/core/reference/ReferenceError.kt
-------------------------------------------
// domain/core/reference/ReferenceError.kt package org.blackerp.domain.core.reference import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class ReferenceError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class NotFound(val id:UUID) :ReferenceError(message="Reference not found:$id",code="REF_NOT_FOUND") data class ValidationFailed(val details:String) :ReferenceError(message="Reference validation failed:$details",code="REF_VALIDATION_FAILED") data class CacheError(val operation:String,val details:String) :ReferenceError(message="Cache operation '$operation' failed:$details",code="REF_CACHE_ERROR")} enum class CacheStrategy {NONE,READ_WRITE,READ_ONLY} 
File: ./domain/validation/validators/module/ModuleValidator.kt
-------------------------------------------
package org.blackerp.domain.validation.validators.module import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.ad.base.ADModule import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.validation.Validator class ModuleValidator :Validator<ADModule> {override suspend fun validate(entity:ADModule):Either<ValidationError,ADModule> {val errors=mutableListOf<ValidationError>() // Validate module name format if (!entity.name.value.matches(Regex("^[a-z][a-z0-9-]*$"))) {errors.add(ValidationError.InvalidFormat("Module name must start with lowercase letter and contain only lowercase letters,numbers,and hyphens"))} // Validate display name if (entity.displayName.value.isBlank()) {errors.add(ValidationError.Required("display name"))} // Validate description length if present entity.description?.value?.let {desc->if (desc.length> 255) {errors.add(ValidationError.InvalidLength("description",0,255))}} return if (errors.isEmpty()) {entity.right()} else {errors.first().left()}}} 
File: ./domain/validation/ValidatorRegistry.kt
-------------------------------------------
// domain/validation/ValidatorRegistry.kt package org.blackerp.domain.validation interface ValidatorRegistry {fun <T> getValidator(type:Class<T>):Validator<T>?} 
File: ./domain/validation/Validator.kt
-------------------------------------------
// domain/validation/Validator.kt package org.blackerp.domain.validation import arrow.core.Either import org.blackerp.domain.core.shared.ValidationError interface Validator<T> {suspend fun validate(entity:T):Either<ValidationError,T>} 
File: ./domain/validation/BaseValidator.kt
-------------------------------------------
// domain/validation/BaseValidator.kt package org.blackerp.domain.validation import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.shared.ValidationError abstract class BaseValidator<T> :Validator<T> {override suspend fun validate(entity:T):Either<ValidationError,T>=entity.right()} 
File: ./domain/events/WorkflowEvents.kt
-------------------------------------------
package org.blackerp.domain.events import java.util.UUID import org.blackerp.domain.core.ad.workflow.NodeType import org.blackerp.domain.core.ad.workflow.WorkflowNode sealed class WorkflowEvent :DomainEvent {data class NodeCreated(override val metadata:EventMetadata,val node:WorkflowNode) :WorkflowEvent() data class NodeUpdated(override val metadata:EventMetadata,val nodeId:UUID,val changes:Map<String,ChangePair>) :WorkflowEvent() data class NodeDeleted(override val metadata:EventMetadata,val nodeId:UUID,val nodeName:String) :WorkflowEvent()} 
File: ./domain/events/WindowEvents.kt
-------------------------------------------
// File:domain/events/WindowEvents.kt package org.blackerp.domain.events import org.blackerp.domain.core.ad.window.WindowType import java.util.UUID sealed class WindowEvent :DomainEvent {data class WindowCreated(override val metadata:EventMetadata,val windowId:UUID,val name:String,val type:WindowType) :WindowEvent() data class WindowUpdated(override val metadata:EventMetadata,val windowId:UUID,val changes:Map<String,ChangePair>) :WindowEvent() data class WindowDeleted(override val metadata:EventMetadata,val windowId:UUID) :WindowEvent() data class TabAdded(override val metadata:EventMetadata,val windowId:UUID,val tabId:UUID,val name:String) :WindowEvent() data class TabRemoved(override val metadata:EventMetadata,val windowId:UUID,val tabId:UUID) :WindowEvent()}
File: ./domain/events/RelationshipEvents.kt
-------------------------------------------
package org.blackerp.domain.events import java.util.UUID import org.blackerp.domain.core.ad.table.RelationshipType import org.blackerp.domain.core.ad.table.CascadeType sealed class RelationshipEvent :DomainEvent {data class RelationshipCreated(override val metadata:EventMetadata,val relationshipId:UUID,val sourceTableId:UUID,val targetTableId:UUID,val type:RelationshipType,val sourceColumn:String,val targetColumn:String,val onDelete:CascadeType,val onUpdate:CascadeType) :RelationshipEvent() data class RelationshipModified(override val metadata:EventMetadata,val relationshipId:UUID,val previousType:RelationshipType,val newType:RelationshipType,val previousOnDelete:CascadeType,val newOnDelete:CascadeType,val previousOnUpdate:CascadeType,val newOnUpdate:CascadeType) :RelationshipEvent() data class RelationshipDeleted(override val metadata:EventMetadata,val relationshipId:UUID,val sourceTableId:UUID,val targetTableId:UUID) :RelationshipEvent()} 
File: ./domain/events/EventMetadata.kt
-------------------------------------------
package org.blackerp.domain.events import java.time.Instant import java.util.UUID data class EventMetadata(val id:UUID=UUID.randomUUID(),val timestamp:Instant=Instant.now(),val user:String,val version:Int=1,val correlationId:String?=null) 
File: ./domain/events/DomainEvent.kt
-------------------------------------------
package org.blackerp.domain.events interface DomainEvent {val metadata:EventMetadata} data class ChangePair(val oldValue:Any?,val newValue:Any?) {val hasChanged:Boolean get()=oldValue != newValue} 
File: ./domain/events/ConstraintEvents.kt
-------------------------------------------
package org.blackerp.domain.events import java.util.UUID import org.blackerp.domain.core.ad.table.ConstraintType sealed class ConstraintEvent :DomainEvent {data class ConstraintCreated(override val metadata:EventMetadata,val constraintId:UUID,val tableId:UUID,val name:String,val type:ConstraintType,val columns:List<String>,val expression:String?) :ConstraintEvent() data class ConstraintModified(override val metadata:EventMetadata,val constraintId:UUID,val previousName:String,val newName:String,val previousColumns:List<String>,val newColumns:List<String>,val previousExpression:String?,val newExpression:String?) :ConstraintEvent() data class ConstraintDeleted(override val metadata:EventMetadata,val constraintId:UUID,val tableId:UUID,val name:String) :ConstraintEvent() data class ConstraintViolated(override val metadata:EventMetadata,val constraintId:UUID,val tableId:UUID,val violationType:ViolationType,val violationDetails:String) :ConstraintEvent()} enum class ViolationType {UNIQUE_VIOLATION,CHECK_VIOLATION,FOREIGN_KEY_VIOLATION} 
File: ./domain/events/DocumentEvents.kt
-------------------------------------------
// domain/events/DocumentEvents.kt package org.blackerp.domain.events import java.util.UUID import org.blackerp.domain.core.ad.document.DocumentStatus sealed class DocumentEvent :DomainEvent {data class StatusChanged(override val metadata:EventMetadata,val documentId:UUID,val previousStatus:DocumentStatus,val newStatus:DocumentStatus,val reason:String?) :DocumentEvent() data class DocumentCreated(override val metadata:EventMetadata,val documentId:UUID,val type:String,val status:DocumentStatus) :DocumentEvent() data class DocumentModified(override val metadata:EventMetadata,val documentId:UUID,val changes:Map<String,ChangePair>) :DocumentEvent()} 
File: ./build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") version "1.9.20" apply false kotlin("plugin.spring") version "1.9.20" apply false id("org.springframework.boot") version "3.2.0" apply false id("io.spring.dependency-management") version "1.1.4" apply false} allprojects {group="org.blackerp" version="0.0.1-SNAPSHOT" repositories {mavenCentral()}} subprojects {apply(plugin="org.jetbrains.kotlin.jvm") apply(plugin="org.springframework.boot") apply(plugin="io.spring.dependency-management") tasks.withType<JavaCompile> {sourceCompatibility=JavaVersion.VERSION_17.toString() targetCompatibility=JavaVersion.VERSION_17.toString()} tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {kotlinOptions {jvmTarget="17" freeCompilerArgs=listOf("-Xjsr305=strict")}}} 
File: ./application/services/auth/JwtService.kt
-------------------------------------------
package org.blackerp.application.services.auth import io.jsonwebtoken.Claims import io.jsonwebtoken.Jwts import io.jsonwebtoken.security.Keys import org.springframework.stereotype.Service import org.blackerp.domain.core.security.SecurityContext import org.blackerp.domain.core.security.User import java.time.Instant import java.time.temporal.ChronoUnit import java.util.Date import java.util.UUID @Service class JwtService(private val jwtProperties:JwtProperties) {private val key=Keys.hmacShaKeyFor(jwtProperties.secret.toByteArray()) fun generateToken(user:User,context:SecurityContext):String {val now=Instant.now() val expiry=now.plus(jwtProperties.expirationHours.toLong(),ChronoUnit.HOURS) return Jwts.builder() .setSubject(user.id.toString()) .claim("username",user.username) .claim("clientId",user.clientId.toString()) .claim("orgId",user.organizationId?.toString()) .claim("roles",user.roles.map {it.name}) .setIssuedAt(Date.from(now)) .setExpiration(Date.from(expiry)) .signWith(key) .compact()} fun validateToken(token:String):Claims? {return try {Jwts.parserBuilder() .setSigningKey(key) .build() .parseClaimsJws(token) .body} catch (e:Exception) {null}} fun extractUserId(token:String):UUID?=validateToken(token)?.subject?.let {UUID.fromString(it)}} 
File: ./application/services/auth/AuthService.kt
-------------------------------------------
package org.blackerp.application.services.auth import org.springframework.stereotype.Service import org.springframework.security.crypto.password.PasswordEncoder import org.blackerp.domain.core.security.* import org.blackerp.application.api.auth.dto.* import arrow.core.Either import arrow.core.left import arrow.core.right import java.time.Instant import org.slf4j.LoggerFactory @Service class AuthService(private val jwtService:JwtService,private val passwordEncoder:PasswordEncoder,private val userRepository:UserRepository,// To be implemented private val securityService:SecurityService) {private val logger=LoggerFactory.getLogger(AuthService::class.java) suspend fun authenticate(credentials:Credentials):Either<SecurityError,LoginResponse> {return try {// For POC,using mock validation // TODO:Implement actual user validation val user=User(username=credentials.username,email="${credentials.username}@example.com",clientId=credentials.clientId,organizationId=null,roles=emptySet()) val context=SecurityContext(user=user,clientId=credentials.clientId,organizationId=null,roles=emptySet()) val token=jwtService.generateToken(user,context) val refreshToken="refresh-${token}" // TODO:Implement proper refresh token LoginResponse(token=token,refreshToken=refreshToken,expiresAt=Instant.now().plusSeconds(3600).epochSecond,user=UserDto(id=user.id,username=user.username,email=user.email,clientId=user.clientId,organizationId=user.organizationId,roles=user.roles.map {it.name})).right()} catch (e:Exception) {logger.error("Authentication failed",e) SecurityError.InvalidCredentials("Invalid credentials").left()}} suspend fun refreshToken(refreshToken:String):Either<SecurityError,LoginResponse> {// TODO:Implement refresh token logic return SecurityError.InvalidToken("Refresh token not implemented").left()}} 
File: ./application/services/ADMetadataService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import domain.core.shared.EntityMetadata import org.blackerp.domain.core.metadata.AuditInfo import org.blackerp.domain.core.metadata.VersionInfo import org.blackerp.domain.core.error.TableError import org.blackerp.domain.core.security.SecurityContext import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import java.time.Instant @Service class ADMetadataService(private val securityContext:SecurityContext) {@Transactional fun generateMetadata(tableName:String):Either<TableError,EntityMetadata> {val currentUser=securityContext.user.username return EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy=currentUser,updatedBy=currentUser),version=VersionInfo()).right()} @Transactional fun incrementVersion(metadata:EntityMetadata):Either<TableError,EntityMetadata> {val currentUser=securityContext.user.username return metadata.copy(audit=metadata.audit.copy(updatedBy=currentUser,updatedAt=Instant.now()),version=metadata.version.copy(version=metadata.version.version + 1)).right()}} 
File: ./application/services/CoroutineConfig.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.asCoroutineDispatcher import java.util.concurrent.Executors @Configuration class CoroutineConfig {@Bean fun ioDispatcher():CoroutineDispatcher=Executors.newFixedThreadPool(10).asCoroutineDispatcher()} 
File: ./application/services/cache/WindowCacheStrategy.kt
-------------------------------------------
package org.blackerp.application.services.cache import org.springframework.stereotype.Component import org.springframework.cache.annotation.Cacheable import org.springframework.cache.annotation.CacheEvict import org.blackerp.domain.core.ad.window.ADWindow import java.util.UUID @Component class WindowCacheStrategy {companion object {const val WINDOW_CACHE="windows" const val WINDOW_BY_NAME_CACHE="windows_by_name"} @Cacheable(value=[WINDOW_CACHE],key="#id") suspend fun getWindow(id:UUID):ADWindow?=null // Implementation provided by repository @CacheEvict(value=[WINDOW_CACHE,WINDOW_BY_NAME_CACHE],allEntries=true) suspend fun evictAll() {// Clear all window caches}} 
File: ./application/services/cache/CacheStrategy.kt
-------------------------------------------
package org.blackerp.application.services.cache enum class CacheStrategy {NONE,READ_WRITE,READ_ONLY} 
File: ./application/services/error/DomainProcessError.kt
-------------------------------------------
package org.blackerp.application.services.error import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.ad.process.ProcessError sealed class DomainProcessError(override val message:String) :DomainError(message) {data class ValidationFailed(val details:String) :DomainProcessError("Validation failed:$details") data class ExecutionFailed(val details:String) :DomainProcessError("Execution failed:$details") data class NotFound(val id:String) :DomainProcessError("Process not found:$id") data class UnexpectedError(override val message:String) :DomainProcessError(message) companion object {fun fromProcessError(error:ProcessError):DomainProcessError=when (error) {is ProcessError.ValidationFailed->ValidationFailed(error.details) is ProcessError.ExecutionFailed->ExecutionFailed(error.details) is ProcessError.NotFound->NotFound(error.id.toString()) is ProcessError.UnexpectedError->UnexpectedError(error.message)}}} 
File: ./application/services/docstatus/DocStatusService.kt
-------------------------------------------
package org.blackerp.application.services.docstatus import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.docstatus.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import java.util.UUID @Service class DocStatusService {// In-memory storage for POC private val statuses=mutableMapOf<String,DocStatus>() suspend fun getStatus(code:String):Either<DocStatusError,DocStatus?> {val status=statuses[code] return status?.right() ?:DocStatusError.NotFound(UUID.randomUUID()).left()} suspend fun validateTransition(from:String,to:String):Either<DocStatusError,Unit> {return when (val status=statuses[from]) {null->DocStatusError.NotFound(UUID.randomUUID()).left() else->{if (status.allowedTransitions.contains(to)) Unit.right() else DocStatusError.StatusTransitionInvalid(from,to).left()}}}} 
File: ./application/services/docaction/DocActionService.kt
-------------------------------------------
package org.blackerp.application.services.docaction import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.docaction.* import org.blackerp.application.services.docstatus.DocStatusService import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import org.slf4j.LoggerFactory import java.util.UUID @Service class DocActionService(private val docStatusService:DocStatusService) :DocActionOperations {private val logger=LoggerFactory.getLogger(DocActionService::class.java) // In-memory storage for POC private val actions=mutableMapOf<String,DocAction>() override suspend fun register(action:DocAction):Either<DocActionError,DocAction> {logger.debug("Registering action:${action.code}") actions[action.code]=action return action.right()} override suspend fun findByCode(code:String):Either<DocActionError,DocAction?> {val action=actions[code] return action?.right() ?:DocActionError.NotFound(code).left()} override suspend fun execute(code:String,context:DocActionContext):Either<DocActionError,DocActionResult> {val action=actions[code] ?:return DocActionError.NotFound(code).left() return action.execute(context)} override suspend fun listActions():Flow<DocAction>=flowOf(*actions.values.toTypedArray())} 
File: ./application/services/window/WindowServiceImpl.kt
-------------------------------------------
// File:application/services/window/WindowServiceImpl.kt package org.blackerp.application.services.window import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.window.* import org.blackerp.domain.events.WindowEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import org.blackerp.domain.core.values.* import org.blackerp.domain.core.metadata.* import arrow.core.* import kotlinx.coroutines.flow.* import java.util.UUID import org.slf4j.LoggerFactory @Service class WindowServiceImpl(private val windowRepository:WindowRepository,private val eventPublisher:DomainEventPublisher) :WindowService {private val logger=LoggerFactory.getLogger(WindowServiceImpl::class.java) @Transactional override suspend fun createWindow(command:CreateWindowCommand):Either<WindowError,ADWindow> {logger.debug("Creating window:${command.name}") // Validate window name format return WindowName.create(command.name) .mapLeft {WindowError.ValidationFailed("Invalid window name:${it.message}")} .flatMap {windowName->// Validate display name DisplayName.create(command.displayName) .mapLeft {WindowError.ValidationFailed("Invalid display name:${it.message}")} .flatMap {displayName->// Handle optional description val description=command.description?.let {desc->Description.create(desc) .mapLeft {WindowError.ValidationFailed("Invalid description:${it.message}")} .getOrNull()} // Create window entity val window=ADWindow(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",// TODO:Get from security context updatedBy="system")),name=windowName,displayName=displayName,description=description,tabs=command.tabs.mapNotNull {createTab(it).getOrNull()},isActive=command.isActive ?:true,isSOTrx=command.isSOTrx ?:true,windowType=command.windowType ?:WindowType.MAINTAIN) // Save and publish event windowRepository.save(window) .onRight {saved->publishWindowCreated(saved)}}}} private fun createTab(command:CreateTabCommand):Either<WindowError,ADTab> {return TabName.create(command.name) .mapLeft {WindowError.ValidationFailed("Invalid tab name:${it.message}")} .flatMap {tabName->DisplayName.create(command.displayName) .mapLeft {WindowError.ValidationFailed("Invalid tab display name:${it.message}")} .map {displayName->ADTab(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),name=tabName,displayName=displayName,description=command.description?.let {Description.create(it).getOrNull()},tableId=command.tableId,sequence=command.sequence ?:10,fields=command.fields.map {createField(it)})}}} private fun createField(command:CreateFieldCommand):WindowField {return WindowField(id=UUID.randomUUID(),columnName=command.columnName,displayName=command.displayName,description=command.description,isDisplayed=command.isDisplayed ?:true,isReadOnly=command.isReadOnly ?:false,isMandatory=command.isMandatory ?:false,sequence=command.sequence ?:10,displayLogic=command.displayLogic,defaultValue=command.defaultValue,validationRule=command.validationRule)} @Transactional override suspend fun updateWindow(id:UUID,command:UpdateWindowCommand):Either<WindowError,ADWindow> {logger.debug("Updating window:$id") return windowRepository.findById(id).flatMap {existing->existing?.let {window->// Update basic properties val updated=window.copy(displayName=command.displayName?.let {DisplayName.create(it).getOrNull()} ?:window.displayName,description=command.description?.let {Description.create(it).getOrNull()} ?:window.description,isActive=command.isActive ?:window.isActive,isSOTrx=command.isSOTrx ?:window.isSOTrx) // Save and publish event windowRepository.save(updated) .onRight {saved->publishWindowUpdated(saved)}} ?:WindowError.NotFound(id).left()}} override suspend fun findWindowByName(name:WindowName):Either<WindowError,ADWindow?> {return windowRepository.findByName(name)} override suspend fun searchWindows(query:String,pageSize:Int,page:Int):Flow<ADWindow>=flow {// Implement search logic here windowRepository.search(query,pageSize,page).collect {emit(it)}} @Transactional override suspend fun deleteWindow(id:UUID):Either<WindowError,Unit> {return windowRepository.delete(id) .onRight {publishWindowDeleted(id)}} private fun publishWindowCreated(window:ADWindow) {eventPublisher.publish(WindowEvent.WindowCreated(metadata=EventMetadata(user="system",correlationId=UUID.randomUUID().toString()),windowId=UUID.fromString(window.id),name=window.name.value,type=window.windowType))} private fun publishWindowUpdated(window:ADWindow) {eventPublisher.publish(WindowEvent.WindowUpdated(metadata=EventMetadata(user="system",correlationId=UUID.randomUUID().toString()),windowId=UUID.fromString(window.id),changes=mapOf() // TODO:Track actual changes))} private fun publishWindowDeleted(windowId:UUID) {eventPublisher.publish(WindowEvent.WindowDeleted(metadata=EventMetadata(user="system",correlationId=UUID.randomUUID().toString()),windowId=windowId))}} // Command classes for window operations data class CreateWindowCommand(val name:String,val displayName:String,val description:String?=null,val tabs:List<CreateTabCommand>=emptyList(),val isActive:Boolean?=null,val isSOTrx:Boolean?=null,val windowType:WindowType?=null) data class CreateTabCommand(val name:String,val displayName:String,val description:String?=null,val tableId:UUID,val sequence:Int?=null,val fields:List<CreateFieldCommand>=emptyList()) data class CreateFieldCommand(val columnName:String,val displayName:String,val description:String?=null,val isDisplayed:Boolean?=null,val isReadOnly:Boolean?=null,val isMandatory:Boolean?=null,val sequence:Int?=null,val displayLogic:String?=null,val defaultValue:String?=null,val validationRule:String?=null) data class UpdateWindowCommand(val displayName:String?=null,val description:String?=null,val isActive:Boolean?=null,val isSOTrx:Boolean?=null)
File: ./application/services/SecurityService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.springframework.security.crypto.password.PasswordEncoder import org.blackerp.domain.core.security.* import arrow.core.Either import kotlinx.coroutines.flow.* import java.util.UUID @Service class SecurityService(private val passwordEncoder:PasswordEncoder) :SecurityOperations {override suspend fun authenticate(credentials:Credentials):Either<SecurityError,AuthToken>=TODO() override suspend fun validateToken(token:String):Either<SecurityError,SecurityContext>=TODO() override suspend fun getUserRoles(userId:UUID):Flow<Role>=flow {} override suspend fun getRolePermissions(roleId:UUID):Flow<Permission>=flow {} override suspend fun hasPermission(context:SecurityContext,permission:String):Boolean=TODO()} 
File: ./application/services/plugin/PluginService.kt
-------------------------------------------
package org.blackerp.application.services.plugin import org.springframework.stereotype.Service import org.blackerp.domain.core.plugin.PluginRegistry import org.blackerp.domain.core.error.PluginError import arrow.core.Either import org.slf4j.LoggerFactory @Service class PluginService(private val pluginRegistry:PluginRegistry) {private val logger=LoggerFactory.getLogger(PluginService::class.java) suspend fun loadPlugins():Either<PluginError,Unit> {logger.info("Loading plugins...") return pluginRegistry.loadPlugins()} suspend fun getPlugin(id:String)=pluginRegistry.getPlugin(id) suspend fun startPlugin(id:String)=pluginRegistry.startPlugin(id) suspend fun stopPlugin(id:String)=pluginRegistry.stopPlugin(id)} 
File: ./application/services/config/SecurityConfig.kt
-------------------------------------------
package org.blackerp.application.services.config import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder import org.springframework.security.crypto.password.PasswordEncoder @Configuration class SecurityConfig {@Bean fun passwordEncoder():PasswordEncoder=BCryptPasswordEncoder()} 
File: ./application/services/SecurityFilter.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.web.server.ServerWebExchange import org.springframework.web.server.WebFilter import org.springframework.web.server.WebFilterChain import org.springframework.stereotype.Component import org.springframework.http.HttpStatus import reactor.core.publisher.Mono import kotlinx.coroutines.runBlocking import org.slf4j.LoggerFactory @Component class SecurityFilter(private val securityService:SecurityService) :WebFilter {private val logger=LoggerFactory.getLogger(SecurityFilter::class.java) private val publicPaths=setOf("/api/auth/login","/api/auth/refresh") override fun filter(exchange:ServerWebExchange,chain:WebFilterChain):Mono<Void> {val path=exchange.request.path.value() if (publicPaths.any {path.startsWith(it)}) {return chain.filter(exchange)} val authHeader=exchange.request.headers.getFirst("Authorization") val authToken=authHeader?.removePrefix("Bearer ") if (authToken == null) {exchange.response.statusCode=HttpStatus.UNAUTHORIZED return exchange.response.setComplete()} return Mono.defer {runBlocking {securityService.validateToken(authToken)}.fold({error->logger.error("Authentication failed:$error") exchange.response.statusCode=HttpStatus.UNAUTHORIZED exchange.response.setComplete()},{context->exchange.attributes["securityContext"]=context chain.filter(exchange)}) Mono.empty()}}} 
File: ./application/services/process/ProcessExecutionService.kt
-------------------------------------------
package org.blackerp.application.services.process import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.process.* import org.blackerp.infrastructure.process.tracking.ProcessExecutionTracker import org.blackerp.infrastructure.process.executor.ProcessExecutorImpl import arrow.core.Either import kotlinx.coroutines.flow.* import java.util.UUID import org.slf4j.LoggerFactory @Service class ProcessExecutionService(private val processExecutor:ProcessExecutorImpl,private val executionTracker:ProcessExecutionTracker) {private val logger=LoggerFactory.getLogger(ProcessExecutionService::class.java) suspend fun executeProcess(processId:UUID,parameters:Map<String,Any>,async:Boolean=false):Either<ProcessError,ProcessResult> {logger.debug("Initiating process execution:$processId") return processExecutor.execute(processId,parameters,async)} fun getExecutionHistory(processId:UUID):List<ProcessExecution> {logger.debug("Fetching execution history for process:$processId") return executionTracker.getExecutionHistory(processId)}} 
File: ./application/services/process/ProcessServiceImpl.kt
-------------------------------------------
package org.blackerp.application.services.process import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.process.* import org.blackerp.infrastructure.process.executor.ProcessExecutorImpl import org.blackerp.infrastructure.process.tracking.ProcessExecutionTracker import org.blackerp.infrastructure.process.validation.ParameterValidator import arrow.core.Either import arrow.core.flatMap import kotlinx.coroutines.flow.* import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Service class ProcessServiceImpl(private val processOperations:ProcessOperations,private val processExecutor:ProcessExecutorImpl,private val executionTracker:ProcessExecutionTracker,private val parameterValidator:ParameterValidator) :ProcessService {private val logger=LoggerFactory.getLogger(ProcessServiceImpl::class.java) override suspend fun execute(id:UUID,parameters:Map<String,Any>,async:Boolean):Either<ProcessError,ProcessResult> {logger.debug("Executing process $id with parameters:$parameters") return processOperations.findById(id).flatMap {process->process?.let {p->// Validate parameters validateParameters(id,parameters).flatMap {validatedParams->// Execute process processExecutor.execute(id,validatedParams,async).map {result->// Track execution trackExecution(id,parameters,result) result}}} ?:ProcessError.NotFound(id).left()}} override suspend fun validateParameters(id:UUID,parameters:Map<String,Any>):Either<ProcessError,Map<String,Any>> {return processOperations.findById(id).flatMap {process->process?.let {p->parameterValidator.validate(parameters,p.parameters)} ?:ProcessError.NotFound(id).left()}} private fun trackExecution(processId:UUID,parameters:Map<String,Any>,result:ProcessResult) {val execution=ProcessExecution(processId=processId,startTime=Instant.now(),endTime=Instant.now(),status=if (result.success) ExecutionStatus.COMPLETED else ExecutionStatus.FAILED,parameters=parameters,result=result,user="system" // TODO:Get from security context) executionTracker.trackExecution(processId,execution)}} 
File: ./application/services/DocumentService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.document.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import java.util.UUID @Service class DocumentService :DocumentOperations {override suspend fun create(document:Document):Either<DocumentError,Document>=document.right() override suspend fun findById(id:UUID):Either<DocumentError,Document?>=null.right() override suspend fun search(criteria:SearchCriteria):Flow<Document>=flowOf() override suspend fun delete(id:UUID):Either<DocumentError,Unit>=Unit.right() override suspend fun update(id:UUID,document:Document):Either<DocumentError,Document>=document.right() override suspend fun changeStatus(id:UUID,status:DocumentStatus):Either<DocumentError,Document>=DocumentError.NotFound(id).left()} 
File: ./application/services/interfaces/ProcessInterfaces.kt
-------------------------------------------
package org.blackerp.application.services.interfaces import java.util.UUID import arrow.core.Either import org.blackerp.domain.core.error.ProcessError data class ProcessResult(val success:Boolean,val message:String) interface ProcessExecutor {suspend fun execute(processId:UUID,params:Map<String,Any>,async:Boolean=false):Either<ProcessError,ProcessResult>} interface ProcessRepository {suspend fun save(process:Process):Either<ProcessError,Process> suspend fun findById(id:UUID):Either<ProcessError,Process?>} 
File: ./application/services/core/ServiceImports.kt
-------------------------------------------
package org.blackerp.application.services.core import org.springframework.transaction.annotation.Transactional import org.springframework.transaction.annotation.Propagation import org.springframework.stereotype.Service import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import kotlinx.coroutines.* import arrow.core.* import java.util.UUID 
File: ./application/services/core/ServiceBase.kt
-------------------------------------------
package org.blackerp.application.services.core import org.springframework.transaction.annotation.Transactional import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import arrow.core.Either import arrow.core.left import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.error.UnexpectedError abstract class ServiceBase {@Transactional(readOnly=true) protected suspend fun <T> withTransaction(block:suspend ()->Either<DomainError,T>):Either<DomainError,T>=withContext(Dispatchers.IO) {try {block()} catch (e:Exception) {UnexpectedError(e.message ?:"Unknown error").left()}}} 
File: ./application/services/audit/AuditService.kt
-------------------------------------------
package org.blackerp.application.services.audit import org.springframework.stereotype.Service import org.blackerp.domain.core.audit.AuditLog import org.blackerp.domain.core.audit.AuditLogger import org.blackerp.domain.core.security.SecurityContext import java.time.Instant import java.util.UUID import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext @Service class AuditService(private val auditLogger:AuditLogger) {suspend fun logAction(context:SecurityContext,entityType:String,entityId:UUID,action:String,oldValue:String?=null,newValue:String?=null,metadata:Map<String,String>=emptyMap())=withContext(Dispatchers.IO) {val auditLog=AuditLog(entityType=entityType,entityId=entityId,action=action,userId=context.user.id,username=context.user.username,clientId=context.clientId,organizationId=context.organizationId,oldValue=oldValue,newValue=newValue,metadata=metadata) auditLogger.log(auditLog)} suspend fun getAuditTrail(entityType:String,entityId:UUID,fromDate:Instant?=null,toDate:Instant?=null):List<AuditLog>=withContext(Dispatchers.IO) {auditLogger.getAuditTrail(entityType,entityId,fromDate,toDate)}} 
File: ./application/services/TableService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.table.TableOperations import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.error.TableError import arrow.core.Either import java.util.UUID import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext @Service class TableService(private val tableOperations:TableOperations) {@Transactional(readOnly=true) suspend fun findAll():Either<TableError,List<ADTable>>=withContext(Dispatchers.IO) {tableOperations.findAll()} @Transactional suspend fun save(table:ADTable):Either<TableError,ADTable>=withContext(Dispatchers.IO) {tableOperations.save(table)} suspend fun findById(id:UUID):Either<TableError,ADTable?>=withContext(Dispatchers.IO) {tableOperations.findById(id)} @Transactional suspend fun delete(id:UUID):Either<TableError,Unit>=withContext(Dispatchers.IO) {tableOperations.delete(id)}} 
File: ./application/services/ImportTransactional.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.transaction.annotation.Transactional import org.springframework.transaction.annotation.Propagation 
File: ./application/services/ProcessService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.process.* import arrow.core.* import kotlinx.coroutines.flow.* import java.util.UUID @Service class ProcessService :ProcessOperations {override suspend fun getExecutionHistory(id:UUID,pageSize:Int,page:Int):Flow<ProcessExecution>=flowOf() override suspend fun save(process:ADProcess):Either<ProcessError,ADProcess>=process.right() override suspend fun findById(id:UUID):Either<ProcessError,ADProcess?>=null.right() override suspend fun delete(id:UUID):Either<ProcessError,Unit>=Unit.right() override suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADProcess>=flowOf() override suspend fun execute(id:UUID,parameters:Map<String,Any>,async:Boolean):Either<ProcessError,ProcessResult>=ProcessResult(success=true,message="Success",data=null).right() override suspend fun validateParameters(id:UUID,parameters:Map<String,Any>):Either<ProcessError,Map<String,List<String>>>=mapOf<String,List<String>>().right() override suspend fun schedule(id:UUID,schedule:ProcessSchedule):Either<ProcessError,ADProcess>=ProcessError.NotFound(id).left()} 
File: ./application/services/common/ServiceImports.kt
-------------------------------------------
package org.blackerp.application.services.common import org.springframework.transaction.annotation.Transactional import org.springframework.transaction.annotation.Propagation import org.springframework.stereotype.Service import kotlinx.coroutines.* import arrow.core.* import java.util.UUID 
File: ./application/services/common/ServiceBase.kt
-------------------------------------------
package org.blackerp.application.services.common import org.springframework.transaction.annotation.Transactional import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import arrow.core.Either import arrow.core.left import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.error.UnexpectedError abstract class ServiceBase {@Transactional(readOnly=true) protected suspend fun <T> withTransaction(block:suspend ()->Either<DomainError,T>):Either<DomainError,T>=withContext(Dispatchers.IO) {try {block()} catch (e:Exception) {UnexpectedError(e.message ?:"Unknown error").left()}}} 
File: ./application/services/WorkflowService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.workflow.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import org.slf4j.LoggerFactory import java.util.UUID @Service class WorkflowService(private val workflowOperations:WorkflowOperations) :WorkflowOperations {private val logger=LoggerFactory.getLogger(WorkflowService::class.java) override suspend fun save(node:WorkflowNode):Either<WorkflowError,WorkflowNode>=workflowOperations.save(node) override suspend fun findById(id:UUID):Either<WorkflowError,WorkflowNode?>=workflowOperations.findById(id) override suspend fun delete(id:UUID):Either<WorkflowError,Unit>=workflowOperations.delete(id) override suspend fun validateWorkflow(nodes:List<WorkflowNode>):Either<WorkflowError,Unit>=validateWorkflowStructure(nodes) private fun validateWorkflowStructure(nodes:List<WorkflowNode>):Either<WorkflowError,Unit> {// Basic validation rules if (nodes.isEmpty()) {return WorkflowError.ValidationFailed("Workflow must contain at least one node").left()} // Check for start and end nodes val startNodes=nodes.filter {it.type == NodeType.START} val endNodes=nodes.filter {it.type == NodeType.END} if (startNodes.isEmpty()) {return WorkflowError.ValidationFailed("Workflow must have a start node").left()} if (endNodes.isEmpty()) {return WorkflowError.ValidationFailed("Workflow must have an end node").left()} return Unit.right()}} 
File: ./application/services/ReferenceService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.reference.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import java.util.UUID @Service class ReferenceService(private val referenceRepository:ReferenceRepository,private val referenceCache:ReferenceCache,private val metadataService:ADMetadataService) :ReferenceOperations {override suspend fun save(reference:ADReference):Either<ReferenceError,ADReference>=referenceRepository.save(reference) override suspend fun findById(id:UUID):Either<ReferenceError,ADReference?>=referenceRepository.findById(id) override suspend fun findByName(refName:String):Either<ReferenceError,ADReference?>=referenceRepository.findByName(refName) // Other implementations... override suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADReference>=referenceRepository.search(query,pageSize,page) override suspend fun getValues(referenceId:UUID,searchText:String?,pageSize:Int,page:Int):Either<ReferenceError,List<ReferenceValue<*>>>=TODO() override suspend fun validateValue(referenceId:UUID,value:Any):Either<ReferenceError,Boolean>=TODO() override suspend fun getHierarchy(rootId:UUID?):Either<ReferenceError,List<ADReference>>=TODO() override suspend fun delete(id:UUID):Either<ReferenceError,Unit>=TODO()} 
File: ./application/services/base/CoroutineBaseService.kt
-------------------------------------------
package org.blackerp.application.services.base import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import arrow.core.Either import arrow.core.left import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.error.UnexpectedError abstract class CoroutineBaseService {protected suspend fun <T> withTransaction(block:suspend ()->Either<DomainError,T>):Either<DomainError,T>=withContext(Dispatchers.IO) {try {block()} catch (e:Exception) {UnexpectedError(e.message ?:"Unknown error").left()}}} 
File: ./application/services/table/TableManagementService.kt
-------------------------------------------
package org.blackerp.application.services.table import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.error.TableError import org.blackerp.domain.core.metadata.* import org.blackerp.application.services.metrics.TableMetrics import arrow.core.* import kotlinx.coroutines.flow.* import java.util.UUID @Service class TableManagementService(private val tableOperations:TableOperations,private val tableValidator:TableValidator,private val tableMetrics:TableMetrics) {@Transactional suspend fun createTable(command:CreateTableCommand):Either<TableError,ADTable>=tableValidator.validateCreate(command).flatMap {validatedCommand->val table=ADTable(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system"),version=VersionInfo()),name=validatedCommand.name,displayName=validatedCommand.displayName,description=validatedCommand.description,accessLevel=validatedCommand.accessLevel,columns=emptyList()) tableOperations.save(table)} suspend fun findTables():Flow<ADTable>=flow {tableOperations.findAll().fold({emitAll(flowOf())},{tables->emitAll(flowOf(*tables.toTypedArray()))})}} 
File: ./application/services/workflow/WorkflowServiceImpl.kt
-------------------------------------------
// application/services/workflow/WorkflowServiceImpl.kt package org.blackerp.application.services.workflow import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.events.WorkflowEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import org.blackerp.domain.core.shared.ValidationError import arrow.core.* import kotlinx.coroutines.flow.Flow import java.util.UUID import org.slf4j.LoggerFactory @Service class WorkflowServiceImpl(private val workflowOperations:WorkflowOperations,private val eventPublisher:DomainEventPublisher) :WorkflowService {private val logger=LoggerFactory.getLogger(WorkflowServiceImpl::class.java) override suspend fun createWorkflow(command:CreateWorkflowCommand):Either<WorkflowError,WorkflowNode> {logger.debug("Creating workflow node:{}",command.displayName) return command.toNode().flatMap {node->workflowOperations.save(node).also {result->result.fold({error->logger.error("Failed to create node:{}",error.message)},{savedNode->eventPublisher.publish(WorkflowEvent.NodeCreated(metadata=EventMetadata(user="system"),node=savedNode))})}}} override suspend fun updateWorkflow(id:UUID,command:UpdateWorkflowCommand):Either<WorkflowError,WorkflowNode> {logger.debug("Updating workflow node:{}",id) return workflowOperations.findById(id).flatMap {existing->existing?.let {node->val updated=node.copy(displayName=command.displayName ?:node.displayName,description=command.description ?:node.description) workflowOperations.save(updated).also {result->result.fold({error->logger.error("Failed to update node:{}",error.message)},{updatedNode->eventPublisher.publish(WorkflowEvent.NodeUpdated(metadata=EventMetadata(user="system"),nodeId=UUID.fromString(updatedNode.id),changes=mapOf() // Add actual changes tracking))})}} ?:WorkflowError.NotFound(id).left()}} override suspend fun validateWorkflow(id:UUID):Either<WorkflowError,ValidationResult> {logger.debug("Validating workflow:{}",id) return workflowOperations.findById(id).flatMap {node->node?.let {workflowOperations.validateWorkflow(listOf(it)).map {ValidationResult(valid=true)}} ?:WorkflowError.NotFound(id).left()}} override suspend fun executeWorkflow(id:UUID,context:WorkflowContext):Either<WorkflowError,WorkflowResult> {logger.debug("Executing workflow:{} for document:{}",id,context.document.id) return workflowOperations.findById(id).flatMap {node->node?.let {// Implement actual workflow execution logic WorkflowResult(completed=true,currentNode=UUID.fromString(node.id),nextNodes=emptyList(),attributes=context.attributes).right()} ?:WorkflowError.NotFound(id).left()}}}
File: ./application/services/workflow/WorkflowExecutionTracker.kt
-------------------------------------------
package org.blackerp.application.services.workflow import org.springframework.stereotype.Component import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Component class WorkflowExecutionTracker {private val logger=LoggerFactory.getLogger(WorkflowExecutionTracker::class.java) // In-memory tracking for POC - replace with persistence private val activeExecutions=mutableMapOf<UUID,WorkflowExecutionState>() fun startExecution(workflowId:UUID,document:UUID) {val executionId=UUID.randomUUID() activeExecutions[executionId]=WorkflowExecutionState(id=executionId,workflowId=workflowId,documentId=document,startTime=Instant.now(),status=ExecutionStatus.RUNNING) logger.info("Started workflow execution:{} for document:{}",executionId,document)} fun updateExecutionStatus(executionId:UUID,status:ExecutionStatus) {activeExecutions[executionId]?.let {state->activeExecutions[executionId]=state.copy(status=status,endTime=if (status.isTerminal()) Instant.now() else null) logger.info("Updated execution status:{}-> {}",executionId,status)}} fun getExecutionState(executionId:UUID):WorkflowExecutionState?=activeExecutions[executionId]} data class WorkflowExecutionState(val id:UUID,val workflowId:UUID,val documentId:UUID,val startTime:Instant,val endTime:Instant?=null,val status:ExecutionStatus,val currentNode:UUID?=null,val attributes:Map<String,Any>=emptyMap()) enum class ExecutionStatus {RUNNING,COMPLETED,FAILED,CANCELLED;fun isTerminal()=this != RUNNING} 
File: ./application/services/workflow/WorkflowService.kt
-------------------------------------------
package org.blackerp.application.services.workflow import org.springframework.stereotype.Service import org.blackerp.domain.core.workflow.state.WorkflowStateMachine import org.blackerp.domain.core.workflow.state.StateTransitionError import org.blackerp.domain.core.security.SecurityContext import org.blackerp.domain.core.security.DocumentAccessControl import org.blackerp.application.services.audit.AuditService import arrow.core.Either import arrow.core.flatMap import java.util.UUID import org.slf4j.LoggerFactory @Service class WorkflowService(private val stateMachine:WorkflowStateMachine,private val accessControl:DocumentAccessControl,private val auditService:AuditService) {private val logger=LoggerFactory.getLogger(WorkflowService::class.java) suspend fun transitionState(context:SecurityContext,documentId:UUID,currentState:String,targetState:String):Either<StateTransitionError,Unit> {logger.debug("Attempting state transition for document $documentId:$currentState->$targetState") return accessControl.checkAccess(context,documentId,"WORKFLOW_TRANSITION") .mapLeft {error->StateTransitionError.PermissionDenied(error.toString())} .flatMap {stateMachine.transition(context,currentState,targetState,documentId) .also {result->result.fold({error->logger.error("State transition failed:${error.message}")},{newState->auditService.logAction(context=context,entityType="DOCUMENT",entityId=documentId,action="STATE_TRANSITION",oldValue=currentState,newValue=targetState,metadata=mapOf("workflow_state" to newState.name,"transition_type" to "STATE_CHANGE"))})}} .map {Unit}}} 
File: ./application/services/workflow/WorkflowExecutionEngine.kt
-------------------------------------------
package org.blackerp.application.services.workflow import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.events.WorkflowEvent import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import org.blackerp.domain.core.ad.document.Document import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import java.util.UUID import org.slf4j.LoggerFactory @Component class WorkflowExecutionEngine(private val workflowOperations:WorkflowOperations,private val eventPublisher:DomainEventPublisher) {private val logger=LoggerFactory.getLogger(WorkflowExecutionEngine::class.java) suspend fun executeNode(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult>=withContext(Dispatchers.IO) {logger.debug("Executing workflow node:{} of type:{}",node.id,node.type) try {when (node.type) {NodeType.START->handleStartNode(node,context) NodeType.ACTIVITY->executeActivity(node,context) NodeType.DECISION->evaluateDecision(node,context) NodeType.END->handleEndNode(node,context)}} catch (e:Exception) {logger.error("Error executing node:${node.id}",e) WorkflowError.ValidationFailed("Node execution failed:${e.message}").left()}} private suspend fun handleStartNode(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult> {// Initialize workflow context and validate initial state val nextNodes=node.transitions.filter {transition->transition.condition?.let {evaluateCondition(it,context)} ?:true}.map {it.targetNode} return WorkflowExecutionResult(nodeId=UUID.fromString(node.id),status=NodeExecutionStatus.COMPLETED,nextNodes=nextNodes,outputAttributes=context.attributes).right()} private suspend fun executeActivity(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult> {// Execute activity action if present node.action?.let {action->when (action) {is NodeAction.Process->executeProcess(action,context) is NodeAction.UserTask->handleUserTask(action,context) is NodeAction.Notification->sendNotification(action,context)}} // Determine next nodes based on transitions val nextNodes=node.transitions.filter {transition->transition.condition?.let {evaluateCondition(it,context)} ?:true}.map {it.targetNode} return WorkflowExecutionResult(nodeId=UUID.fromString(node.id),status=NodeExecutionStatus.COMPLETED,nextNodes=nextNodes,outputAttributes=context.attributes).right()} private suspend fun evaluateDecision(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult> {// Evaluate conditions and determine next path val nextNodes=node.transitions .filter {transition->transition.condition?.let {evaluateCondition(it,context)} ?:false} .map {it.targetNode} if (nextNodes.isEmpty()) {return WorkflowError.ValidationFailed("No valid transition found for decision node").left()} return WorkflowExecutionResult(nodeId=UUID.fromString(node.id),status=NodeExecutionStatus.COMPLETED,nextNodes=nextNodes,outputAttributes=context.attributes).right()} private suspend fun handleEndNode(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult> {// Finalize workflow execution return WorkflowExecutionResult(nodeId=UUID.fromString(node.id),status=NodeExecutionStatus.COMPLETED,nextNodes=emptyList(),outputAttributes=context.attributes).right()} private fun evaluateCondition(condition:TransitionCondition,context:WorkflowContext):Boolean {// Simple condition evaluation - can be enhanced with expression engine return try {// Example:evaluate basic expressions on context attributes true // Placeholder for actual evaluation} catch (e:Exception) {logger.error("Error evaluating condition:${condition.expression}",e) false}} private suspend fun executeProcess(action:NodeAction.Process,context:WorkflowContext) {// Implement process execution logger.debug("Executing process:{}",action.processId)} private suspend fun handleUserTask(action:NodeAction.UserTask,context:WorkflowContext) {// Implement user task handling logger.debug("Creating user task for role:{}",action.roleId)} private suspend fun sendNotification(action:NodeAction.Notification,context:WorkflowContext) {// Implement notification sending logger.debug("Sending notification:{}",action.template)}} // Add additional data classes for execution data class WorkflowExecutionResult(val nodeId:UUID,val status:NodeExecutionStatus,val nextNodes:List<UUID>,val outputAttributes:Map<String,Any>) enum class NodeExecutionStatus {PENDING,IN_PROGRESS,COMPLETED,FAILED,CANCELLED} 
File: ./application/services/workflow/WorkflowExtensions.kt
-------------------------------------------
package org.blackerp.application.services.workflow import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.application.api.process.CreateWorkflowCommand import arrow.core.* import java.util.UUID fun CreateWorkflowCommand.toNode():Either<WorkflowError,WorkflowNode> {val metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")) return DisplayName.create(displayName) .mapLeft {WorkflowError.ValidationFailed(it.message)} .flatMap {displayName->val desc=description?.let {Description.create(it).fold({WorkflowError.ValidationFailed(it.message).left()},{it.right()})} ?:null.right() desc.map {description->WorkflowNode(metadata=metadata,displayName=displayName,description=description,type=type,action=action,transitions=transitions.map {t->WorkflowTransition(id=UUID.randomUUID(),sourceNode=UUID.randomUUID(),targetNode=t.targetNodeId,condition=t.condition?.let {TransitionCondition(it,"Auto-generated")})})}}} 
File: ./application/services/TableMetrics.kt
-------------------------------------------
package org.blackerp.application.services.metrics import org.springframework.stereotype.Component import io.micrometer.core.instrument.MeterRegistry import java.time.Duration import java.util.concurrent.TimeUnit @Component class TableMetrics(private val meterRegistry:MeterRegistry) {private val createTableCounter=meterRegistry.counter("table.create.count") private val createTableTimer=meterRegistry.timer("table.create.duration") fun incrementCreateCounter()=createTableCounter.increment() fun <T> timeCreateOperation(operation:()->T):T {val start=System.nanoTime() return try {operation()} finally {val duration=System.nanoTime() - start createTableTimer.record(duration,TimeUnit.NANOSECONDS)}}} 
File: ./application/services/DocumentLifecycleService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.events.DocumentEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import org.blackerp.application.workflow.engine.WorkflowEngine // Corrected import import org.blackerp.domain.core.security.SecurityContext import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID import java.time.Instant import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import org.slf4j.LoggerFactory @Service class DocumentLifecycleService(private val documentOperations:DocumentOperations,private val workflowEngine:WorkflowEngine,private val eventPublisher:DomainEventPublisher) {private val logger=LoggerFactory.getLogger(DocumentLifecycleService::class.java) @Transactional suspend fun changeStatus(id:UUID,command:ChangeStatusCommand):Either<DocumentError,Document>=withContext(Dispatchers.IO) {logger.debug("Changing document status:$id->${command.targetStatus}") documentOperations.findById(id).fold({error->logger.error("Failed to find document:$id",error) Either.Left(error)},{document->document?.let {doc->doc.validateStatusTransition(command.targetStatus) .flatMap {executeStatusChange(doc,command)}} ?:DocumentError.NotFound(id).left()})} private suspend fun executeStatusChange(document:Document,command:ChangeStatusCommand):Either<DocumentError,Document>=withContext(Dispatchers.IO) {try {// Execute workflow if configured if (document.type.workflowId != null) {workflowEngine.processDocument(documentId=UUID.fromString(document.id),action=command.targetStatus.name,parameters=command.attributes)} else {// Direct status change documentOperations.changeStatus(UUID.fromString(document.id),command.targetStatus).also {result->result.fold({error->logger.error("Status change failed",error)},{updatedDoc->publishStatusChangeEvent(previousStatus=document.status,newStatus=updatedDoc.status,documentId=UUID.fromString(document.id),reason=command.reason)})}}} catch (e:Exception) {logger.error("Error during status change",e) DocumentError.ValidationFailed("Status change failed:${e.message}").left()}} private suspend fun publishStatusChangeEvent(previousStatus:DocumentStatus,newStatus:DocumentStatus,documentId:UUID,reason:String?)=withContext(Dispatchers.IO) {try {eventPublisher.publish(DocumentEvent.StatusChanged(metadata=EventMetadata(user="system",// TODO:Get from security context correlationId=UUID.randomUUID().toString()),documentId=documentId,previousStatus=previousStatus,newStatus=newStatus,reason=reason))} catch (e:Exception) {logger.error("Failed to publish status change event",e)}} suspend fun getHistory(id:UUID,fromDate:Instant?=null,toDate:Instant?=null):Either<DocumentError,List<DocumentChange>>=withContext(Dispatchers.IO) {documentOperations.findById(id).map {document->document?.let {documentOperations.search(SearchCriteria(types=listOf(UUID.fromString(document.type.id)),dateRange=fromDate?.let {from->toDate?.let {to->DateRange(from,to)}})).toList()} ?:emptyList()}}} 
File: ./application/services/TransactionalImports.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.transaction.annotation.Transactional import org.springframework.transaction.annotation.Propagation 
File: ./application/services/JwtProperties.kt
-------------------------------------------
package org.blackerp.application.services data class JwtProperties(val secret:String,val expirationHours:Int=24) 
File: ./application/config/CacheConfig.kt
-------------------------------------------
package org.blackerp.application.config import org.springframework.cache.annotation.EnableCaching import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Bean import org.springframework.cache.caffeine.CaffeineCacheManager import com.github.benmanes.caffeine.cache.Caffeine import java.util.concurrent.TimeUnit @Configuration @EnableCaching class CacheConfig {@Bean fun cacheManager()=CaffeineCacheManager().apply {setCaffeine(Caffeine.newBuilder() .expireAfterWrite(30,TimeUnit.MINUTES) .maximumSize(100))}} 
File: ./application/config/DatabaseConfig.kt
-------------------------------------------
// DatabaseConfig.kt content from above 
File: ./application/api/mappers/TableMapper.kt
-------------------------------------------
// application/api/mappers/TableMapper.kt package org.blackerp.application.api.mappers import org.springframework.stereotype.Component import org.blackerp.application.api.dto.requests.CreateTableRequest import org.blackerp.domain.core.ad.table.ADTable import domain.core.shared.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.core.metadata.AuditInfo import org.blackerp.domain.core.shared.ValidationError import arrow.core.Either import java.util.UUID @Component class TableMapper {fun toDomain(request:CreateTableRequest):Either<ValidationError,ADTable>=TableName.create(request.name).map {tableName->ADTable(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),name=tableName,displayName=DisplayName.create(request.displayName).fold({throw IllegalArgumentException(it.message)},{it}),description=request.description?.let {desc->Description.create(desc).fold({throw IllegalArgumentException(it.message)},{it})},accessLevel=AccessLevel.valueOf(request.accessLevel.uppercase()))}} 
File: ./application/api/auth/dto/AuthDtos.kt
-------------------------------------------
package org.blackerp.application.api.auth.dto import java.util.UUID data class LoginRequest(val username:String,val password:String,val clientId:UUID) data class LoginResponse(val token:String,val refreshToken:String,val expiresAt:Long,val user:UserDto) data class UserDto(val id:UUID,val username:String,val email:String,val clientId:UUID,val organizationId:UUID?,val roles:List<String>) data class RefreshTokenRequest(val refreshToken:String) 
File: ./application/api/auth/controllers/AuthController.kt
-------------------------------------------
package org.blackerp.application.api.auth.controllers import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.application.api.auth.dto.* import org.blackerp.application.services.auth.AuthService import org.blackerp.domain.core.security.Credentials import jakarta.validation.Valid @RestController @RequestMapping("/api/auth") class AuthController(private val authService:AuthService) {@PostMapping("/login") suspend fun login(@Valid @RequestBody request:LoginRequest):ResponseEntity<LoginResponse>=authService.authenticate(Credentials(username=request.username,password=request.password,clientId=request.clientId)).fold({ResponseEntity.badRequest().build()},{ResponseEntity.ok(it)}) @PostMapping("/refresh") suspend fun refresh(@Valid @RequestBody request:RefreshTokenRequest):ResponseEntity<LoginResponse>=authService.refreshToken(request.refreshToken).fold({ResponseEntity.badRequest().build()},{ResponseEntity.ok(it)})} 
File: ./application/api/dto/requests/TableRequests.kt
-------------------------------------------
package org.blackerp.application.api.dto.requests import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.metadata.* import arrow.core.* import java.util.UUID data class CreateTableRequest(val name:String,val displayName:String,val description:String?,val accessLevel:String) {fun toDomain():Either<ValidationError,ADTable>=TableName.create(name).flatMap {tableName->DisplayName.create(displayName).flatMap {dispName->val descriptionResult=description?.let {desc->Description.create(desc)} ?:Either.Right(null) descriptionResult.map {desc->ADTable(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),displayName=dispName,description=desc,name=tableName,accessLevel=AccessLevel.valueOf(accessLevel.uppercase()))}}}} 
File: ./application/api/dto/requests/CreateDocumentRequest.kt
-------------------------------------------
package org.blackerp.application.api.dto.requests import java.util.UUID data class CreateDocumentRequest(val displayName:String,val description:String?,val typeId:UUID,val attributes:Map<String,Any>=emptyMap()) 
File: ./application/api/dto/requests/CreateProcessRequest.kt
-------------------------------------------
package org.blackerp.application.api.dto.requests import org.blackerp.domain.core.ad.process.* import java.util.UUID data class CreateProcessRequest(val displayName:String,val type:String,val parameters:List<ProcessParameterRequest>) data class ProcessParameterRequest(val name:String,val displayName:String,val description:String?,val mandatory:Boolean=false) 
File: ./application/api/dto/ParameterMapping.kt
-------------------------------------------
package org.blackerp.application.api.dto import org.blackerp.domain.core.ad.process.ProcessParameter as DomainProcessParameter import org.blackerp.domain.core.ad.process.ParameterType import org.blackerp.domain.core.values.DataType import java.util.UUID fun toDomainParameter(dto:org.blackerp.application.api.process.ProcessParameter):DomainProcessParameter {return DomainProcessParameter(id=UUID.randomUUID(),name=dto.name,displayName=dto.displayName,description=dto.description,parameterType=when(dto.dataType) {DataType.STRING->ParameterType.STRING DataType.INTEGER->ParameterType.NUMBER DataType.DATE->ParameterType.DATE DataType.BOOLEAN->ParameterType.BOOLEAN else->ParameterType.STRING},isMandatory=dto.mandatory,validationRule=null)} 
File: ./application/api/dto/TableDTO.kt
-------------------------------------------
package org.blackerp.application.api.dto import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.values.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.shared.ValidationError import java.util.UUID import arrow.core.Either import arrow.core.getOrElse data class TableDTO(val id:String?=null,val name:String,val displayName:String,val description:String?,val accessLevel:String) {companion object {fun fromDomain(table:ADTable)=TableDTO(id=table.id,name=table.name.value,displayName=table.displayName.value,description=table.description?.value,accessLevel=table.accessLevel.name)} fun toDomain():Either<ValidationError,ADTable>=TableName.create(name).map {tableName->ADTable(metadata=EntityMetadata(id=id ?:UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),name=tableName,displayName=DisplayName.create(displayName).getOrElse {throw IllegalArgumentException("Invalid display name")},description=description?.let {Description.create(it).getOrElse {null}},accessLevel=AccessLevel.valueOf(accessLevel))}} 
File: ./application/api/dto/responses/TableResponses.kt
-------------------------------------------
package org.blackerp.api.dto.responses // Auto-fixed by fix_application.sh import java.util.UUID data class TableResponse(val id:UUID,val name:String,val displayName:String,val description:String?,val accessLevel:String) data class TablesResponse(val tables:List<TableResponse>) 
File: ./application/api/controllers/DocumentLifecycleController.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.domain.core.ad.document.* import org.blackerp.application.services.DocumentLifecycleService import java.util.UUID import kotlinx.coroutines.runBlocking @RestController @RequestMapping("/api/documents") class DocumentLifecycleController(private val lifecycleService:DocumentLifecycleService) {@PostMapping("/{id}/status") suspend fun changeStatus(@PathVariable id:UUID,@RequestBody command:ChangeStatusCommand):ResponseEntity<Document>=lifecycleService.changeStatus(id,command) .fold({error->ResponseEntity.badRequest().build()},{document->ResponseEntity.ok(document)}) @GetMapping("/{id}/history") suspend fun getHistory(@PathVariable id:UUID):ResponseEntity<List<DocumentChange>>=lifecycleService.getHistory(id) .fold({error->ResponseEntity.badRequest().build()},{history->ResponseEntity.ok(history)})} 
File: ./application/api/controllers/DocumentController.kt
-------------------------------------------
package org.blackerp.api.controllers import org.springframework.web.bind.annotation.* import org.blackerp.domain.core.ad.document.* import org.springframework.http.ResponseEntity import java.util.UUID @RestController @RequestMapping("/api/documents") class DocumentController(private val documentService:DocumentOperations) {@GetMapping("/{id}/history") suspend fun getHistory(@PathVariable id:UUID):ResponseEntity<Any>=documentService.findById(id) .fold({ResponseEntity.badRequest().body(it)},{ResponseEntity.ok(it)})} 
File: ./application/api/controllers/Imports.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.blackerp.domain.core.shared.* import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import jakarta.validation.Valid import kotlinx.coroutines.flow.Flow import java.util.UUID 
File: ./application/api/controllers/TableController.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.application.api.dto.TableDTO import org.blackerp.application.api.dto.requests.CreateTableRequest import org.blackerp.application.services.table.TableManagementService import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.shared.ValidationError import arrow.core.* import jakarta.validation.Valid import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.toList @RestController @RequestMapping("/api/tables") class TableController(private val tableService:TableManagementService) {@GetMapping suspend fun getTables():ResponseEntity<List<TableDTO>>=tableService.findTables() .map {TableDTO.fromDomain(it)} .toList() .let {ResponseEntity.ok(it)} @PostMapping suspend fun createTable(@Valid @RequestBody request:CreateTableRequest):ResponseEntity<TableDTO>=Either.catch {TableName.create(request.name).orNull()?.let {tableName->DisplayName.create(request.displayName).orNull()?.let {displayName->val description=request.description?.let {desc->Description.create(desc).orNull()} CreateTableCommand(name=tableName,displayName=displayName,description=description,accessLevel=AccessLevel.valueOf(request.accessLevel.uppercase()),columns=emptyList())}} ?:throw IllegalArgumentException("Invalid input")}.fold({ResponseEntity.badRequest().build()},{command->tableService.createTable(command).fold({ResponseEntity.badRequest().build()},{ResponseEntity.ok(TableDTO.fromDomain(it))})})} 
File: ./application/api/controllers/ReferenceController.kt
-------------------------------------------
package org.blackerp.api.controllers // Auto-fixed by fix_application.sh import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.domain.core.ad.reference.* import org.blackerp.application.services.ReferenceService import jakarta.validation.Valid import org.slf4j.LoggerFactory import java.util.UUID @RestController @RequestMapping("/api/references") class ReferenceController(private val referenceService:ReferenceService) {private val logger=LoggerFactory.getLogger(ReferenceController::class.java) @PostMapping suspend fun createReference(@Valid @RequestBody request:CreateReferenceRequest):ResponseEntity<ADReference> {logger.debug("Creating reference:${request.name}") return referenceService.save(request.toDomain()).fold({error->ResponseEntity.badRequest().build()},{reference->ResponseEntity.ok(reference)})} @GetMapping("/{id}") suspend fun getReference(@PathVariable id:UUID):ResponseEntity<ADReference> {return referenceService.findById(id).fold({error->ResponseEntity.notFound().build()},{reference->reference?.let {ResponseEntity.ok(it)} ?:ResponseEntity.notFound().build()})} @GetMapping("/{id}/values") suspend fun getReferenceValues(@PathVariable id:UUID,@RequestParam(required=false) search:String?,@RequestParam(defaultValue="20") pageSize:Int,@RequestParam(defaultValue="0") page:Int):ResponseEntity<List<ReferenceValue<*>>> {return referenceService.getValues(id,search,pageSize,page).fold({error->ResponseEntity.badRequest().build()},{values->ResponseEntity.ok(values)})} @GetMapping("/{id}/hierarchy") suspend fun getReferenceHierarchy(@PathVariable id:UUID):ResponseEntity<List<ADReference>> {return referenceService.getHierarchy(id).fold({error->ResponseEntity.badRequest().build()},{hierarchy->ResponseEntity.ok(hierarchy)})} @DeleteMapping("/{id}") suspend fun deleteReference(@PathVariable id:UUID):ResponseEntity<Unit> {return referenceService.delete(id).fold({error->ResponseEntity.badRequest().build()},{ResponseEntity.noContent().build()})} data class CreateReferenceRequest(val name:String,val displayName:String,val description:String?,val type:ReferenceTypeRequest,val validationRule:ValidationRuleRequest?,val parentId:UUID?,val sortOrder:Int?,val cacheStrategy:String?) {fun toDomain():ADReference {// Implement conversion to domain object TODO("Implement conversion")}} data class ReferenceTypeRequest(val type:String,val config:Map<String,String>) data class ValidationRuleRequest(val expression:String,val errorMessage:String,val parameters:Map<String,String>)} 
File: ./application/api/controllers/WorkflowController.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.blackerp.application.usecases.workflow.* import org.blackerp.application.api.process.CreateWorkflowCommand import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity @RestController @RequestMapping("/api/workflows") class WorkflowController(private val createWorkflowUseCase:CreateWorkflowUseCase) {@PostMapping suspend fun createWorkflow(@RequestBody command:CreateWorkflowCommand):ResponseEntity<Any>=createWorkflowUseCase.execute(command) .fold({error->ResponseEntity.badRequest().body(error)},{workflow->ResponseEntity.ok(workflow)})} 
File: ./application/api/controllers/ProcessController.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.domain.core.ad.process.* import org.blackerp.application.services.ProcessService import jakarta.validation.Valid import org.slf4j.LoggerFactory import java.util.UUID import kotlinx.coroutines.flow.toList @RestController @RequestMapping("/api/processes") class ProcessController(private val processService:ProcessService) {private val logger=LoggerFactory.getLogger(ProcessController::class.java) @GetMapping("/{id}/history") suspend fun getProcessHistory(@PathVariable id:UUID,@RequestParam(defaultValue="20") pageSize:Int,@RequestParam(defaultValue="0") page:Int):ResponseEntity<List<ProcessExecution>> {val executions=processService.getExecutionHistory(id,pageSize,page).toList() return ResponseEntity.ok(executions)} @PostMapping("/{id}/execute") suspend fun executeProcess(@PathVariable id:UUID,@RequestBody parameters:Map<String,Any>,@RequestParam(defaultValue="false") async:Boolean):ResponseEntity<ProcessResult>=processService.execute(id,parameters,async).fold({error->ResponseEntity.badRequest().build()},{result->ResponseEntity.ok(result)}) @PostMapping("/{id}/schedule") suspend fun scheduleProcess(@PathVariable id:UUID,@Valid @RequestBody schedule:ProcessSchedule):ResponseEntity<ADProcess>=processService.schedule(id,schedule).fold({error->ResponseEntity.badRequest().build()},{process->ResponseEntity.ok(process)})} 
File: ./application/api/extensions/ProcessExtensions.kt
-------------------------------------------
package org.blackerp.application.api.extensions import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.application.api.process.CreateProcessCommand import arrow.core.* import java.util.UUID fun CreateProcessCommand.toDomain():Either<ProcessError,ADProcess>=DisplayName.create(displayName).bimap({ProcessError.ValidationFailed(it.message)},{displayName->ADProcess(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),displayName=displayName,description=description?.let {Description.create(it).orNull()},type=type,parameters=parameters.map {param->ProcessParameter(id=UUID.randomUUID(),name=param.name,displayName=param.displayName,description=param.description,parameterType=ParameterType.STRING,isMandatory=false,validationRule=null)},implementation=implementation,schedule=schedule)}) 
File: ./application/api/extensions/DomainExtensions.kt
-------------------------------------------
package org.blackerp.application.api.extensions import org.blackerp.domain.core.ad.document.Document import org.blackerp.domain.core.ad.process.ADProcess import org.blackerp.application.api.dto.requests.CreateDocumentRequest import org.blackerp.application.api.dto.requests.CreateProcessRequest import org.blackerp.domain.core.error.DomainError import arrow.core.Either import arrow.core.right fun CreateDocumentRequest.toDomain():Either<DomainError,Document>=TODO() fun CreateProcessRequest.toDomain():Either<DomainError,ADProcess>=TODO() 
File: ./application/api/process/CreateProcessCommand.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.ad.process.* import java.util.UUID data class CreateProcessCommand(val displayName:String,val description:String?,val type:ProcessType,val parameters:List<ProcessParameter>,val implementation:ProcessImplementation,val schedule:ProcessSchedule?) 
File: ./application/api/process/ApiCreateProcessCommand.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.values.* data class ApiCreateProcessCommand(val displayName:String,val description:String?,val type:ProcessType,val parameters:List<ProcessParameter>,val implementation:ProcessImplementation,val schedule:ProcessSchedule?) 
File: ./application/api/process/ProcessExtensions.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import arrow.core.* import java.util.UUID fun CreateProcessCommand.toDomain():Either<ProcessError,ADProcess> {return DisplayName.create(displayName) .mapLeft {ProcessError.ValidationFailed(it.message)} .flatMap {displayName->val descriptionValue=description?.let {desc->Description.create(desc).fold({ProcessError.ValidationFailed(it.message).left()},{it.right()})} ?:null.right() descriptionValue.map {desc->val metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")) ADProcess(metadata=metadata,displayName=displayName,description=desc,type=type,parameters=parameters.map {param->ProcessParameter(id=UUID.randomUUID(),name=param.name,displayName=param.displayName,description=param.description,parameterType=ParameterType.STRING,isMandatory=false,validationRule=null)},implementation=implementation,schedule=schedule)}}} 
File: ./application/api/process/DomainProcessParameter.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.values.DataType import org.blackerp.domain.core.ad.process.* import java.util.UUID interface Parameter {val id:UUID val name:String val displayName:String val description:String? val parameterType:ParameterType val isMandatory:Boolean val validationRule:String?} data class DomainProcessParameter(override val name:String,override val displayName:String,val dataType:DataType,val mandatory:Boolean=false,override val description:String?=null) :Parameter {override val id=UUID.randomUUID() override val parameterType=toParameterType(dataType) override val isMandatory=mandatory override val validationRule:String?=null private fun toParameterType(type:DataType):ParameterType=when(type) {DataType.STRING->ParameterType.STRING DataType.INTEGER->ParameterType.NUMBER DataType.DATE->ParameterType.DATE DataType.BOOLEAN->ParameterType.BOOLEAN else->ParameterType.STRING}} 
File: ./application/api/process/commands.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.values.DataType import org.blackerp.domain.core.ad.workflow.NodeType data class ProcessCommand(val name:String,val displayName:String,val description:String?,val type:String,val parameters:List<ProcessParameter>) data class ProcessParameter(val name:String,val displayName:String,val description:String?,val dataType:DataType,val mandatory:Boolean=false) data class WorkflowCommand(val name:String,val displayName:String,val description:String?,val nodeType:NodeType,val action:String?,val transitions:List<TransitionCommand>) data class TransitionCommand(val targetNode:String,val condition:String?) 
File: ./application/api/process/WorkflowCommands.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.ad.workflow.NodeType import org.blackerp.domain.core.ad.workflow.NodeAction import java.util.UUID data class CreateWorkflowCommand(val displayName:String,val description:String?,val type:NodeType,val action:NodeAction?,val transitions:List<CreateTransitionCommand>) data class CreateTransitionCommand(val targetNodeId:UUID,val condition:String?) 
File: ./application/api/process/types.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.process.* import arrow.core.* import java.util.UUID data class ProcessRequest(val name:String,val displayName:String,val description:String?,val parameters:List<DomainProcessParameter>) {fun toDomain():Either<ProcessError,ADProcess> {val metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")) return DisplayName.create(displayName) .mapLeft {ProcessError.ValidationFailed(it.message)} .flatMap {dispName->val desc=description?.let {Description.create(it).fold({ProcessError.ValidationFailed(it.message).left()},{it.right()})} ?:null.right() desc.map {description->ADProcess(metadata=metadata,displayName=dispName,description=description,type=ProcessType.CUSTOM,parameters=parameters.map {ProcessParameter(id=UUID.randomUUID(),name=it.name,displayName=it.displayName,description=it.description,parameterType=ParameterType.STRING,isMandatory=false,validationRule=null)},implementation=ProcessImplementation.JavaClass(name),schedule=null)}}}} 
File: ./application/api/common/Imports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.shared.* import org.blackerp.domain.core.values.* import java.util.UUID 
File: ./application/api/common/BaseService.kt
-------------------------------------------
package org.blackerp.application.api.common import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import arrow.core.Either import arrow.core.left import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.error.UnexpectedError abstract class BaseService {protected suspend fun <T> withTransaction(block:suspend ()->Either<DomainError,T>):Either<DomainError,T>=withContext(Dispatchers.IO) {try {block()} catch (e:Exception) {UnexpectedError(e.message ?:"Unknown error").left()}}} 
File: ./application/api/common/SharedImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.blackerp.domain.core.* import org.blackerp.domain.core.error.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.metadata.* import java.util.UUID 
File: ./application/api/common/ApiImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.springframework.stereotype.Component import jakarta.validation.Valid import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import java.util.* import arrow.core.Either import kotlinx.coroutines.flow.Flow 
File: ./application/api/common/ServiceImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.error.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.* import java.util.UUID 
File: ./application/api/common/StandardImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.shared.AuditInfo import org.blackerp.domain.core.shared.VersionInfo import org.blackerp.domain.events.DomainEvent import org.blackerp.domain.events.DomainEventPublisher import org.blackerp.domain.core.plugin.PluginRegistry import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.* import java.util.UUID import java.time.Instant 
File: ./application/api/common/DomainImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.blackerp.domain.core.* import org.blackerp.domain.core.error.* import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.ad.process.* import java.util.UUID 
File: ./application/api/common/WebImports.kt
-------------------------------------------
package org.blackerp.api.common import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import kotlinx.coroutines.* import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import jakarta.validation.Valid import java.util.UUID 
File: ./application/api/advice/ErrorHandler.kt
-------------------------------------------
package org.blackerp.application.api.advice import org.springframework.web.bind.annotation.ExceptionHandler import org.springframework.web.bind.annotation.RestControllerAdvice import org.springframework.http.ResponseEntity import org.blackerp.domain.core.error.DomainError @RestControllerAdvice class ErrorHandler {@ExceptionHandler fun handle(error:DomainError):ResponseEntity<Any>=ResponseEntity.badRequest().body(error.message)} 
File: ./application/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") version "1.9.20" kotlin("plugin.spring") id("org.springframework.boot")} dependencies {implementation("com.h2database:h2:2.2.224") api(project(":domain")) implementation("org.springframework.boot:spring-boot-starter-web") implementation("org.springframework.boot:spring-boot-starter-security") implementation("org.springframework.boot:spring-boot-starter-validation") implementation("org.jetbrains.kotlin:kotlin-reflect") implementation("com.fasterxml.jackson.module:jackson-module-kotlin") implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:1.7.3") implementation("org.springframework.boot:spring-boot-starter-data-jpa") implementation("io.micrometer:micrometer-core")} springBoot {mainClass.set("org.blackerp.ApplicationKt")} // Add if not already present dependencies {implementation("org.springframework.boot:spring-boot-starter-cache") implementation("com.github.ben-manes.caffeine:caffeine")} // Add if not already present dependencies {implementation("org.springframework.boot:spring-boot-starter-cache") implementation("com.github.ben-manes.caffeine:caffeine")} dependencies {implementation("org.springframework.boot:spring-boot-starter-security")} // JWT dependencies dependencies {implementation("io.jsonwebtoken:jjwt-api:0.11.5") runtimeOnly("io.jsonwebtoken:jjwt-impl:0.11.5") runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.11.5")} // JWT dependencies dependencies {implementation("io.jsonwebtoken:jjwt-api:0.11.5") runtimeOnly("io.jsonwebtoken:jjwt-impl:0.11.5") runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.11.5")} 
File: ./application/Application.kt
-------------------------------------------
package org.blackerp import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication @SpringBootApplication class Application fun main(args:Array<String>) {runApplication<Application>(*args)} 
File: ./application/usecases/process/CreateProcessUseCase.kt
-------------------------------------------
package org.blackerp.application.usecases.process import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.process.* import org.blackerp.application.api.process.ProcessRequest import arrow.core.Either import arrow.core.flatMap import kotlinx.coroutines.withContext import kotlinx.coroutines.Dispatchers @Service class CreateProcessUseCase(private val processOperations:ProcessOperations) {suspend fun execute(request:ProcessRequest):Either<ProcessError,ADProcess>=withContext(Dispatchers.IO) {request.toDomain().flatMap {process->processOperations.save(process)}}} 
File: ./application/usecases/process/ProcessExtensions.kt
-------------------------------------------
package org.blackerp.application.usecases.process import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.metadata.* import org.blackerp.application.api.dto.requests.CreateProcessRequest import arrow.core.* import java.util.UUID fun CreateProcessRequest.toDomain():Either<ProcessError,ADProcess>=DisplayName.create(displayName).bimap({ProcessError.ValidationFailed(it.message)},{displayName->ADProcess(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),displayName=displayName,description=null,type=ProcessType.valueOf(type.uppercase()),parameters=parameters.map {param->ProcessParameter(id=UUID.randomUUID(),name=param.name,displayName=param.displayName,description=param.description,parameterType=ParameterType.STRING,isMandatory=param.mandatory,validationRule=null)},implementation=ProcessImplementation.JavaClass("process"),schedule=null)}) 
File: ./application/usecases/document/CreateDocumentUseCase.kt
-------------------------------------------
package org.blackerp.application.usecases.document import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.application.services.base.CoroutineBaseService import arrow.core.* import java.util.UUID import kotlinx.coroutines.withContext import kotlinx.coroutines.Dispatchers @Service class CreateDocumentUseCase(private val documentOperations:DocumentOperations) :CoroutineBaseService() {suspend fun execute(command:CreateDocumentCommand):Either<DocumentError,Document>=withContext(Dispatchers.IO) {val description=command.description?.let {desc->Description.create(desc).fold({DocumentError.ValidationFailed("Invalid description").left()},{it.right()})} ?:DocumentError.ValidationFailed("Description required").left() description.flatMap {desc->DisplayName.create(command.displayName).fold({DocumentError.ValidationFailed("Invalid display name").left()},{displayName->val document=Document(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),displayName=displayName,description=desc,type=command.documentType) documentOperations.create(document)})}}} 
File: ./application/usecases/document/CreateDocumentCommand.kt
-------------------------------------------
package org.blackerp.application.usecases.document import org.blackerp.domain.core.ad.document.DocumentType data class CreateDocumentCommand(val displayName:String,val description:String?,val documentType:DocumentType) 
File: ./application/usecases/workflow/CreateWorkflowUseCase.kt
-------------------------------------------
package org.blackerp.application.usecases.workflow import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.workflow.* import org.blackerp.application.api.process.CreateWorkflowCommand import arrow.core.Either import arrow.core.flatMap import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext @Service class CreateWorkflowUseCase(private val workflowOperations:WorkflowOperations) {suspend fun execute(command:CreateWorkflowCommand):Either<WorkflowError,WorkflowNode> {return withContext(Dispatchers.IO) {command.toNode().flatMap {node->workflowOperations.save(node)}}}} 
File: ./application/usecases/workflow/WorkflowExtensions.kt
-------------------------------------------
package org.blackerp.application.usecases.workflow import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.application.api.process.CreateWorkflowCommand import arrow.core.* import java.util.UUID suspend fun CreateWorkflowCommand.toNode():Either<WorkflowError,WorkflowNode> {val metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")) return DisplayName.create(displayName) .mapLeft {WorkflowError.ValidationFailed(it.message)} .flatMap {displayName->val desc=description?.let {Description.create(it).fold({WorkflowError.ValidationFailed(it.message).left()},{it.right()})} ?:null.right() desc.map {description->WorkflowNode(metadata=metadata,displayName=displayName,description=description,type=type,action=action,transitions=transitions.map {t->WorkflowTransition(id=UUID.randomUUID(),sourceNode=UUID.randomUUID(),targetNode=t.targetNodeId,condition=t.condition?.let {TransitionCondition(it,"Auto-generated")})})}}} 
File: ./application/workflow/engine/WorkflowEngine.kt
-------------------------------------------
package org.blackerp.application.workflow.engine import org.springframework.stereotype.Component import org.blackerp.domain.core.workflow.transition.* import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.security.SecurityContext import org.blackerp.domain.events.WorkflowEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import java.util.UUID import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import org.springframework.transaction.annotation.Transactional @Component class WorkflowEngine(private val transitionValidator:TransitionValidator,private val documentService:DocumentService,private val securityContext:SecurityContext,private val eventPublisher:DomainEventPublisher) {private val logger=LoggerFactory.getLogger(WorkflowEngine::class.java) @Transactional suspend fun processDocument(documentId:UUID,action:String,parameters:Map<String,Any>=emptyMap()):Either<WorkflowError,Document>=withContext(Dispatchers.IO) {logger.debug("Processing workflow for document $documentId with action:$action") try {documentService.findById(documentId) .flatMap {document->document?.let {doc->executeWorkflow(doc,action,parameters)} ?:WorkflowError.NotFound(documentId).left()}} catch (e:Exception) {logger.error("Workflow execution failed for document $documentId",e) WorkflowError.ProcessingError("Workflow execution failed:${e.message}",e).left()}} private suspend fun executeWorkflow(document:Document,action:String,parameters:Map<String,Any>):Either<WorkflowError,Document> {val workflowId=document.type.workflowId ?:return WorkflowError.ValidationError("No workflow defined for document type").left() return validateTransition(document.status.name,action) .flatMap {transition->// Execute any actions defined for this transition executeTransitionActions(transition,document,parameters) .flatMap {// Update document status documentService.changeStatus(UUID.fromString(document.id),DocumentStatus.valueOf(action)).mapLeft {error->WorkflowError.ProcessingError(error.message)}}} .also {result->result.fold({error->logger.error("Workflow execution failed:${error.message}")},{updatedDoc->publishWorkflowEvent(updatedDoc,action)})}} private suspend fun validateTransition(currentState:String,targetState:String):Either<WorkflowError,StateTransition> {return transitionValidator.validate(currentState,targetState) .mapLeft {error->when (error) {is TransitionError.InvalidTransition->WorkflowError.ValidationError(error.message) is TransitionError.PermissionDenied->WorkflowError.ValidationError(error.message) else->WorkflowError.ProcessingError(error.message ?:"Unknown error")}}} private suspend fun executeTransitionActions(transition:StateTransition,document:Document,parameters:Map<String,Any>):Either<WorkflowError,Unit> {// Execute document actions defined for this transition // For now just return success return Unit.right()} private fun publishWorkflowEvent(document:Document,action:String) {eventPublisher.publish(WorkflowEvent.NodeCreated(metadata=EventMetadata(user=securityContext.user.username,correlationId=UUID.randomUUID().toString()),node=document.type.workflowId!! // Safe as we checked earlier))}} 
File: ./test-import/settings.gradle.kts
-------------------------------------------
rootProject.name="test-import" include("domain") 
File: ./test-import/domain/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm")} kotlin {jvmToolchain(17)} sourceSets {main {kotlin {srcDirs("core","core/metadata","core/shared","core/values")}}} dependencies {implementation("org.jetbrains.kotlin:kotlin-stdlib") implementation("io.arrow-kt:arrow-core:1.2.0")} 
File: ./test-import/domain/core/values/TableName.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class TableName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TableName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Table name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() else->TableName(value).right()}}} 
File: ./test-import/domain/core/DomainEntity.kt
-------------------------------------------
package org.blackerp.domain.core interface DomainEntity {val id:String} 
File: ./test-import/domain/core/shared/ValidationError.kt
-------------------------------------------
package org.blackerp.domain.core.shared sealed class ValidationError(val message:String) {data class InvalidFormat(val details:String) :ValidationError(details) data class InvalidLength(val field:String,val min:Int,val max:Int) :ValidationError("Field '$field' must be between $min and $max characters") data class Required(val field:String) :ValidationError("Field '$field' is required") data class InvalidValue(val details:String) :ValidationError(details)} 
File: ./test-import/domain/core/shared/EntityMetadata.kt
-------------------------------------------
package org.blackerp.domain.core.shared import java.util.UUID import org.blackerp.domain.core.DomainEntity data class EntityMetadata(override val id:String,val audit:AuditInfo,val version:VersionInfo=VersionInfo()) :DomainEntity data class AuditInfo(val createdBy:String,val updatedBy:String) data class VersionInfo(val version:Int=1,val active:Boolean=true) 
File: ./test-import/domain/core/metadata/EntityMetadata.kt
-------------------------------------------
package org.blackerp.domain.core.metadata import java.util.UUID import java.time.Instant data class EntityMetadata(val id:UUID=UUID.randomUUID(),val created:Instant=Instant.now(),val createdBy:String) 
File: ./test-import/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") version "1.9.20" apply false} allprojects {repositories {mavenCentral()}} 
File: ./integration-tests/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") kotlin("plugin.spring") id("org.springframework.boot")} dependencies {implementation(project(":domain")) implementation(project(":application")) testImplementation("org.springframework.boot:spring-boot-starter-test") testImplementation("com.h2database:h2") testImplementation("org.junit.jupiter:junit-jupiter-api") testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine") testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test") testImplementation("io.mockk:mockk:1.13.8")} tasks.test {useJUnitPlatform()} // Disable bootJar for test project tasks.getByName<org.springframework.boot.gradle.tasks.bundling.BootJar>("bootJar") {enabled=false} 
File: ./integration-tests/test/resources/application-test.yml
-------------------------------------------
spring:datasource:url:jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1 username:sa password:jpa:hibernate:ddl-auto:create-drop show-sql:true 
File: ./integration-tests/test/kotlin/org/blackerp/api/controllers/TableControllerTest.kt
-------------------------------------------
package org.blackerp.api.controllers import org.blackerp.test.IntegrationTest import org.blackerp.application.api.dto.requests.CreateTableRequest import org.junit.jupiter.api.Test import org.springframework.http.MediaType import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.* import org.springframework.test.web.servlet.result.MockMvcResultMatchers.* class TableControllerTest :IntegrationTest() {@Test fun `should create table with valid request`() {val request=CreateTableRequest(name="test_table",displayName="Test Table",description="Test description",accessLevel="ORGANIZATION") mockMvc.perform(post("/api/tables") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(request))) .andExpect(status().isOk) .andExpect(jsonPath("$.name").value(request.name)) .andExpect(jsonPath("$.displayName").value(request.displayName))} @Test fun `should return all tables`() {mockMvc.perform(get("/api/tables")) .andExpect(status().isOk) .andExpect(jsonPath("$").isArray)}} 
File: ./integration-tests/test/kotlin/org/blackerp/test/builders/ADTableBuilder.kt
-------------------------------------------
package org.blackerp.test.builders import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.shared.EntityMetadata import org.blackerp.domain.core.shared.AuditInfo import org.blackerp.domain.core.values.* import java.util.UUID class ADTableBuilder {private var name="test_table" private var displayName="Test Table" private var description:String?=null private var accessLevel=AccessLevel.ORGANIZATION private var columns:List<ColumnDefinition>=emptyList() fun withName(name:String)=apply {this.name=name} fun withDisplayName(displayName:String)=apply {this.displayName=displayName} fun withDescription(description:String?)=apply {this.description=description} fun withAccessLevel(accessLevel:AccessLevel)=apply {this.accessLevel=accessLevel} fun withColumns(columns:List<ColumnDefinition>)=apply {this.columns=columns} fun build():ADTable {return ADTable(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="test",updatedBy="test")),name=TableName.create(name).orNull()!!,displayName=DisplayName.create(displayName).orNull()!!,description=description?.let {Description.create(it).orNull()},accessLevel=accessLevel,columns=columns)}} 
File: ./integration-tests/test/kotlin/org/blackerp/test/fixtures/ADFixtures.kt
-------------------------------------------
package org.blackerp.test.fixtures import org.blackerp.domain.core.ad.table.* import org.blackerp.test.builders.ADTableBuilder import java.util.UUID object ADFixtures {fun createBasicTable(name:String="test_table")=ADTableBuilder() .withName(name) .withDisplayName("Test Table") .withDescription("Test Description") .withAccessLevel(AccessLevel.ORGANIZATION) .build() fun createTableWithColumns(name:String="test_table")=ADTableBuilder() .withName(name) .withDisplayName("Test Table") .withColumns(listOf(ColumnDefinition(name="id",dataType="UUID"),ColumnDefinition(name="name",dataType="STRING",length=100))) .build()} 
File: ./integration-tests/test/kotlin/org/blackerp/test/IntegrationTest.kt
-------------------------------------------
package org.blackerp.test import org.springframework.boot.test.context.SpringBootTest import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc import org.springframework.test.context.ActiveProfiles import org.springframework.test.context.DynamicPropertyRegistry import org.springframework.test.context.DynamicPropertySource import org.springframework.test.web.servlet.MockMvc import org.springframework.beans.factory.annotation.Autowired import com.fasterxml.jackson.databind.ObjectMapper @SpringBootTest @AutoConfigureMockMvc @ActiveProfiles("test") abstract class IntegrationTest {@Autowired protected lateinit var mockMvc:MockMvc @Autowired protected lateinit var objectMapper:ObjectMapper companion object {@JvmStatic @DynamicPropertySource fun properties(registry:DynamicPropertyRegistry) {registry.add("spring.datasource.url") {"jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1"} registry.add("spring.datasource.username") {"sa"} registry.add("spring.datasource.password") {""} registry.add("spring.jpa.hibernate.ddl-auto") {"create-drop"}}} protected inline fun <reified T> parseResponse(json:String):T {return objectMapper.readValue(json,T::class.java)}} 