Generating folder structure...
-------------------------------------------
.
├── apidoc_summary.md
├── bash.sh
├── build.gradle.kts
├── createdomainlayers.sh
├── createproject1.sh
├── docker-compose.yml
├── generatecontent.py
├── generate_project_listing.sh
├── .gitattributes
├── .gitignore
├── .gradle
│   ├── 8.10.2
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── expanded
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── 8.2
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   ├── dependencies-accessors.lock
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── buildOutputCleanup
│   │   ├── buildOutputCleanup.lock
│   │   ├── cache.properties
│   │   └── outputFiles.bin
│   ├── file-system.probe
│   ├── kotlin
│   │   ├── errors
│   │   └── sessions
│   └── vcs-1
│   └── gc.properties
├── gradle
│   └── wrapper
│   ├── gradle-wrapper.jar
│   └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
├── HELP.md
├── LICENSE
├── package-lock.json
├── project_documentation.txt
├── project_listing_cleaned.txt
├── project_listing_compact_optimized.txt
├── project_listing_compact.txt
├── project_listing_minimized.txt
├── project_listing.txt
├── project_summary.md
├── README.md
├── restore_tests.sh
├── settings.gradle.kts
├── src
│   ├── main
│   │   ├── kotlin
│   │   │   └── org
│   │   │   └── blackerp
│   │   │   ├── api
│   │   │   │   ├── controllers
│   │   │   │   │   └── TableController.kt
│   │   │   │   ├── dto
│   │   │   │   │   ├── request
│   │   │   │   │   │   └── CreateTableRequest.kt
│   │   │   │   │   └── response
│   │   │   │   │   └── TableResponses.kt
│   │   │   │   ├── error
│   │   │   │   │   └── ErrorHandler.kt
│   │   │   │   ├── mappers
│   │   │   │   │   └── TableMapper.kt
│   │   │   │   └── validation
│   │   │   ├── application
│   │   │   │   └── table
│   │   │   │   ├── CreateTableCommand.kt
│   │   │   │   └── CreateTableUseCase.kt
│   │   │   ├── BlackErpApplication.kt
│   │   │   ├── config
│   │   │   │   ├── EventConfig.kt
│   │   │   │   └── WebConfig.kt
│   │   │   ├── domain
│   │   │   │   ├── ad
│   │   │   │   │   ├── ADModule.kt
│   │   │   │   │   ├── ADObject.kt
│   │   │   │   │   ├── reference
│   │   │   │   │   │   ├── ADReference.kt
│   │   │   │   │   │   └── value
│   │   │   │   │   │   └── ReferenceName.kt
│   │   │   │   │   ├── tab
│   │   │   │   │   │   ├── ADTab.kt
│   │   │   │   │   │   ├── CreateTabParams.kt
│   │   │   │   │   │   ├── OrderBySpec.kt
│   │   │   │   │   │   ├── TabError.kt
│   │   │   │   │   │   ├── TabOperations.kt
│   │   │   │   │   │   └── value
│   │   │   │   │   │   └── TabName.kt
│   │   │   │   │   ├── value
│   │   │   │   │   │   └── ModuleName.kt
│   │   │   │   │   └── window
│   │   │   │   │   └── value
│   │   │   │   │   └── WindowName.kt
│   │   │   │   ├── common
│   │   │   │   ├── DomainEntity.kt
│   │   │   │   ├── DomainEvent.kt
│   │   │   │   ├── DomainException.kt
│   │   │   │   ├── EntityMetadata.kt
│   │   │   │   ├── error
│   │   │   │   │   └── DomainError.kt
│   │   │   │   ├── event
│   │   │   │   │   ├── DomainEvent.kt
│   │   │   │   │   ├── EventMetadata.kt
│   │   │   │   │   └── TableCreated.kt
│   │   │   │   ├── query
│   │   │   │   │   ├── QueryCriteria.kt
│   │   │   │   │   └── QueryResult.kt
│   │   │   │   ├── security
│   │   │   │   │   └── SecurityContext.kt
│   │   │   │   ├── table
│   │   │   │   │   ├── ADTable.kt
│   │   │   │   │   ├── behavior
│   │   │   │   │   │   └── TableBehavior.kt
│   │   │   │   │   ├── ColumnDefinition.kt
│   │   │   │   │   ├── constraint
│   │   │   │   │   │   ├── NotNullConstraint.kt
│   │   │   │   │   │   ├── ReferenceConstraint.kt
│   │   │   │   │   │   ├── TableConstraint.kt
│   │   │   │   │   │   └── UniqueConstraint.kt
│   │   │   │   │   ├── CreateColumnParams.kt
│   │   │   │   │   ├── definition
│   │   │   │   │   │   └── TableDefinition.kt
│   │   │   │   │   ├── extension
│   │   │   │   │   │   ├── TableExtension.kt
│   │   │   │   │   │   └── TableExtensionPoint.kt
│   │   │   │   │   ├── relationship
│   │   │   │   │   │   ├── constraint
│   │   │   │   │   │   │   └── IndexConstraint.kt
│   │   │   │   │   │   ├── CreateRelationshipParams.kt
│   │   │   │   │   │   ├── event
│   │   │   │   │   │   │   └── RelationshipEvent.kt
│   │   │   │   │   │   ├── RelationshipConstraint.kt
│   │   │   │   │   │   ├── RelationshipOperations.kt
│   │   │   │   │   │   ├── TableRelationshipError.kt
│   │   │   │   │   │   ├── TableRelationship.kt
│   │   │   │   │   │   └── value
│   │   │   │   │   │   ├── DeleteRule.kt
│   │   │   │   │   │   ├── RelationshipName.kt
│   │   │   │   │   │   ├── RelationType.kt
│   │   │   │   │   │   └── UpdateRule.kt
│   │   │   │   │   ├── TableCreated.kt
│   │   │   │   │   ├── TableError.kt
│   │   │   │   │   ├── TableId.kt
│   │   │   │   │   ├── TableOperations.kt
│   │   │   │   │   └── TenantAwareTable.kt
│   │   │   │   ├── tenant
│   │   │   │   │   ├── TenantAware.kt
│   │   │   │   │   ├── TenantContext.kt
│   │   │   │   │   └── TenantFilter.kt
│   │   │   │   ├── transaction
│   │   │   │   │   ├── TransactionError.kt
│   │   │   │   │   └── Transaction.kt
│   │   │   │   └── values
│   │   │   │   ├── AccessLevel.kt
│   │   │   │   ├── Amount.kt
│   │   │   │   ├── ColumnName.kt
│   │   │   │   ├── Currency.kt
│   │   │   │   ├── DataType.kt
│   │   │   │   ├── Description.kt
│   │   │   │   ├── DisplayName.kt
│   │   │   │   ├── EventMetadata.kt
│   │   │   │   ├── Length.kt
│   │   │   │   ├── Precision.kt
│   │   │   │   ├── Scale.kt
│   │   │   │   └── TableName.kt
│   │   │   ├── infrastructure
│   │   │   │   ├── cache
│   │   │   │   │   ├── CacheService.kt
│   │   │   │   │   └── InMemoryCacheService.kt
│   │   │   │   ├── event
│   │   │   │   │   ├── DefaultEventPublisher.kt
│   │   │   │   │   └── EventPublisher.kt
│   │   │   │   ├── persistence
│   │   │   │   │   └── store
│   │   │   │   │   ├── PostgresRelationshipOperations.kt
│   │   │   │   │   ├── PostgresTableOperations.kt
│   │   │   │   │   └── PostgresTabOperations.kt
│   │   │   │   └── store
│   │   │   ├── plugin
│   │   │   │   ├── discovery
│   │   │   │   │   ├── FileSystemPluginDiscovery.kt
│   │   │   │   │   └── PluginDiscovery.kt
│   │   │   │   ├── Extension.kt
│   │   │   │   ├── ExtensionRegistry.kt
│   │   │   │   ├── PluginError.kt
│   │   │   │   ├── PluginId.kt
│   │   │   │   ├── Plugin.kt
│   │   │   │   ├── PluginMetadata.kt
│   │   │   │   ├── registry
│   │   │   │   │   ├── DefaultPluginRegistry.kt
│   │   │   │   │   └── PluginRegistry.kt
│   │   │   │   └── Version.kt
│   │   │   └── shared
│   │   │   ├── ReferenceValidation.kt
│   │   │   ├── TimeBasedId.kt
│   │   │   └── ValidationError.kt
│   │   └── resources
│   │   ├── application.yml
│   │   └── db
│   │   └── migration
│   │   ├── V1__Create_table_schema.sql
│   │   ├── V2_create_relationship_schema.sql
│   │   ├── V3__Create_tab_schema.sql
│   │   └── V5__Seed_initial_data.sql
│   └── test
│   ├── kotlin
│   │   └── org
│   │   └── blackerp
│   │   ├── api
│   │   │   └── controllers
│   │   │   └── TableControllerTest.kt
│   │   ├── application
│   │   │   └── table
│   │   │   └── CreateTableUseCaseTest.kt
│   │   ├── config
│   │   │   ├── KotestProjectConfig.kt
│   │   │   ├── TestConfig.kt
│   │   │   ├── TestEventConfig.kt
│   │   │   └── UnifiedTestConfig.kt
│   │   ├── domain
│   │   │   ├── ad
│   │   │   │   ├── ADModuleTest.kt
│   │   │   │   ├── reference
│   │   │   │   │   ├── ADReferenceTest.kt
│   │   │   │   │   └── value
│   │   │   │   │   └── ReferenceNameTest.kt
│   │   │   │   ├── tab
│   │   │   │   │   ├── ADTabTest.kt
│   │   │   │   │   └── value
│   │   │   │   │   └── TabNameTest.kt
│   │   │   │   ├── value
│   │   │   │   │   └── ModuleNameTest.kt
│   │   │   │   └── window
│   │   │   │   └── value
│   │   │   │   └── WindowNameTest.kt
│   │   │   ├── EntityMetadataTest.kt
│   │   │   ├── error
│   │   │   │   └── DomainErrorTest.kt
│   │   │   ├── query
│   │   │   │   └── QueryCriteriaTest.kt
│   │   │   ├── table
│   │   │   │   ├── behavior
│   │   │   │   ├── constraint
│   │   │   │   │   ├── NotNullConstraintTest.kt
│   │   │   │   │   ├── ReferenceConstraintTest.kt
│   │   │   │   │   └── UniqueConstraintTest.kt
│   │   │   │   ├── definition
│   │   │   │   │   └── TableDefinitionTest.kt
│   │   │   │   ├── extension
│   │   │   │   │   └── TableExtensionPointTest.kt
│   │   │   │   ├── relationship
│   │   │   │   │   ├── RelationshipOperationsTest.kt
│   │   │   │   │   ├── RelationshipTestFactory.kt
│   │   │   │   │   └── TableRelationshipTest.kt
│   │   │   │   └── TableOperationsTest.kt
│   │   │   ├── tenant
│   │   │   │   ├── TenantAwareTableTest.kt
│   │   │   │   └── TenantContextTest.kt
│   │   │   ├── transaction
│   │   │   │   └── TransactionTest.kt
│   │   │   └── values
│   │   │   ├── AmountTest.kt
│   │   │   ├── CurrencyTest.kt
│   │   │   ├── DataTypeTest.kt
│   │   │   ├── DisplayNameTest.kt
│   │   │   └── TableNameTest.kt
│   │   ├── infrastructure
│   │   │   ├── cache
│   │   │   │   └── InMemoryCacheServiceTest.kt
│   │   │   └── persistence
│   │   │   ├── SimpleTest.kt
│   │   │   ├── store
│   │   │   │   ├── InMemoryRelationshipOperations.kt
│   │   │   │   ├── InMemoryTableOperations.kt
│   │   │   │   ├── InMemoryTabOperations.kt
│   │   │   │   └── PostgresTabOperationsTest.kt
│   │   │   └── TestDatabaseConfig.kt
│   │   ├── integration
│   │   │   ├── api
│   │   │   │   └── TableApiIntegrationTest.kt
│   │   │   ├── db
│   │   │   │   └── TableRepositoryIntegrationTest.kt
│   │   │   ├── IntegrationTestConfig.kt
│   │   │   └── plugin
│   │   │   └── PluginLifecycleIntegrationTest.kt
│   │   ├── plugin
│   │   │   ├── discovery
│   │   │   │   └── FileSystemPluginDiscoveryTest.kt
│   │   │   ├── InMemoryExtensionRegistry.kt
│   │   │   ├── integration
│   │   │   ├── PluginIdTest.kt
│   │   │   ├── PluginMetadataTest.kt
│   │   │   ├── PluginTest.kt
│   │   │   ├── registry
│   │   │   │   └── DefaultPluginRegistryTest.kt
│   │   │   ├── TestPlugin.kt
│   │   │   └── VersionTest.kt
│   │   └── shared
│   │   ├── TestFactory.kt
│   │   └── TimeBasedIdTest.kt
│   └── resources
│   ├── application-test.properties
│   ├── application-test.yml
│   ├── application.yml
│   ├── application.yml.backup.20241127_051405
│   ├── db
│   │   ├── h2-schema.sql
│   │   ├── migration
│   │   │   └── V4__create_test_tables.sql
│   │   └── schema.sql
│   └── logback-test.xml
├── testdebug.txt
├── verify-setup.sh
└── verify_test.sh

124 directories, 223 files


Generating file details...
-------------------------------------------

File: ./settings.gradle.kts
-------------------------------------------
rootProject.name="blackerp" 
File: ./docker-compose.yml
-------------------------------------------
version:'3.8' services:db:image:postgres:14-alpine environment:POSTGRES_DB:blackerp POSTGRES_USER:postgres POSTGRES_PASSWORD:postgres ports:- "5432:5432" volumes:- postgres_data:/var/lib/postgresql/data volumes:postgres_data:
File: ./build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") version "1.9.20" kotlin("plugin.spring") version "1.9.20" id("org.springframework.boot") version "3.2.0" id("io.spring.dependency-management") version "1.1.4" id("org.flywaydb.flyway") version "9.21.0" id("jacoco")} group="org.blackerp" version="0.0.1-SNAPSHOT" java {sourceCompatibility=JavaVersion.VERSION_17} repositories {mavenCentral()} dependencies {implementation("com.fasterxml.jackson.datatype:jackson-datatype-jsr310:2.15.3") implementation("com.h2database:h2:2.1.214") implementation("org.flywaydb:flyway-core") implementation("com.fasterxml.uuid:java-uuid-generator:4.2.0") // Kotlin implementation("org.jetbrains.kotlin:kotlin-reflect") implementation("org.jetbrains.kotlin:kotlin-stdlib") implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core") implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor") // Spring implementation("org.springframework.boot:spring-boot-starter") implementation("org.springframework.boot:spring-boot-starter-web") implementation("org.springframework.boot:spring-boot-starter-validation") implementation("org.springframework.boot:spring-boot-starter-jdbc") implementation("com.fasterxml.jackson.module:jackson-module-kotlin") // Arrow implementation("io.arrow-kt:arrow-core:1.2.0") implementation("io.arrow-kt:arrow-fx-coroutines:1.2.0") // Testing testImplementation("org.springframework.boot:spring-boot-starter-test") testImplementation("org.springframework.boot:spring-boot-starter-test") {exclude(module="mockito-core")} testImplementation("com.ninja-squad:springmockk:4.0.2") testImplementation("io.mockk:mockk:1.13.8") testImplementation("com.h2database:h2:2.1.214") // Kotest testImplementation("io.kotest:kotest-runner-junit5:5.8.0") testImplementation("io.kotest:kotest-assertions-core:5.8.0") testImplementation("io.kotest:kotest-property:5.8.0") testImplementation("io.kotest:kotest-framework-datatest:5.8.0") testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3") testImplementation("io.kotest.extensions:kotest-assertions-arrow:1.3.3") testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")} tasks.withType<Test> {useJUnitPlatform()} tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {kotlinOptions {freeCompilerArgs=listOf("-Xjsr305=strict") jvmTarget="17"}} jacoco {toolVersion="0.8.9"} tasks.jacocoTestReport {dependsOn(tasks.test) reports {xml.required.set(true) html.required.set(true) html.outputLocation.set(layout.buildDirectory.dir("reports/jacoco"))} classDirectories.setFrom(files(classDirectories.files.map {fileTree(it) {exclude(// Exclude classes that don't need test coverage "**/BlackErpApplication*","**/config/**","**/dto/**","**/*Error*","**/infrastructure/persistence/store/PostgresTabOperations.kt")}}))} tasks.test {finalizedBy(tasks.jacocoTestReport)} flyway {url="jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL" user="sa" password="" baselineOnMigrate=true locations=arrayOf("classpath:db/migration")} // Add these dependencies if they're not already present dependencies {implementation("org.springframework.boot:spring-boot-starter-web") implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor") implementation("com.fasterxml.jackson.module:jackson-module-kotlin")} dependencies {implementation("org.springframework.boot:spring-boot-starter-validation")} 
File: ./src/main/resources/application.yml
-------------------------------------------
spring:application:name:blackerp logging:level:org.blackerp:DEBUG org.springframework.web:INFO 
File: ./src/main/resources/db/migration/V3__Create_tab_schema.sql
-------------------------------------------
-- src/main/resources/db/migration/V3__Create_tab_schema.sql CREATE TABLE ad_tab (id UUID PRIMARY KEY,name VARCHAR(100) NOT NULL,display_name VARCHAR(100) NOT NULL,description TEXT,table_name VARCHAR(100) NOT NULL,created TIMESTAMP NOT NULL,created_by VARCHAR(100) NOT NULL,updated TIMESTAMP NOT NULL,updated_by VARCHAR(100) NOT NULL,version INTEGER NOT NULL DEFAULT 0,active BOOLEAN NOT NULL DEFAULT true,CONSTRAINT uk_tab_name UNIQUE (name),CONSTRAINT fk_tab_table FOREIGN KEY (table_name) REFERENCES ad_table(name));CREATE INDEX idx_tab_name ON ad_tab(name);CREATE INDEX idx_tab_table ON ad_tab(table_name);CREATE TABLE ad_tab_query_column (tab_id UUID NOT NULL,column_name VARCHAR(100) NOT NULL,sequence INTEGER NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE);CREATE TABLE ad_tab_display_column (tab_id UUID NOT NULL,column_name VARCHAR(100) NOT NULL,sequence INTEGER NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE);CREATE TABLE ad_tab_order_by (tab_id UUID NOT NULL,column_name VARCHAR(100) NOT NULL,direction VARCHAR(4) NOT NULL,sequence INTEGER NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE,CONSTRAINT chk_direction CHECK (direction IN ('ASC','DESC')));
File: ./src/main/resources/db/migration/V2_create_relationship_schema.sql
-------------------------------------------
-- File:src/main/resources/db/migration/V2__Create_relationship_schema.sql CREATE TABLE ad_table_relationship (id UUID PRIMARY KEY,name VARCHAR(100) NOT NULL,source_table VARCHAR(100) NOT NULL,target_table VARCHAR(100) NOT NULL,type VARCHAR(20) NOT NULL,source_column VARCHAR(100) NOT NULL,target_column VARCHAR(100) NOT NULL,delete_rule VARCHAR(20) NOT NULL,update_rule VARCHAR(20) NOT NULL,junction_table VARCHAR(100),created TIMESTAMP NOT NULL,created_by VARCHAR(100) NOT NULL,updated TIMESTAMP NOT NULL,updated_by VARCHAR(100) NOT NULL,version INTEGER NOT NULL DEFAULT 0,active BOOLEAN NOT NULL DEFAULT true,CONSTRAINT uk_relationship_name UNIQUE (name),CONSTRAINT fk_source_table FOREIGN KEY (source_table) REFERENCES ad_table(name),CONSTRAINT fk_target_table FOREIGN KEY (target_table) REFERENCES ad_table(name),CONSTRAINT fk_junction_table FOREIGN KEY (junction_table) REFERENCES ad_table(name),CONSTRAINT chk_relationship_type CHECK (type IN ('ONE_TO_ONE','ONE_TO_MANY','MANY_TO_MANY')),CONSTRAINT chk_delete_rule CHECK (delete_rule IN ('RESTRICT','CASCADE','SET_NULL','NO_ACTION')),CONSTRAINT chk_update_rule CHECK (update_rule IN ('RESTRICT','CASCADE','SET_NULL','NO_ACTION')));CREATE INDEX idx_relationship_source ON ad_table_relationship(source_table);CREATE INDEX idx_relationship_target ON ad_table_relationship(target_table);CREATE INDEX idx_relationship_active ON ad_table_relationship(active);COMMENT ON TABLE ad_table_relationship IS 'Table Relationship Definitions';
File: ./src/main/resources/db/migration/V5__Seed_initial_data.sql
-------------------------------------------
INSERT INTO ad_table (id,name,display_name,description,access_level,created,created_by,updated,updated_by,version,active) VALUES ('550e8400-e29b-41d4-a716-446655440000','business_partner','Business Partner','Business partner master data','ORGANIZATION',CURRENT_TIMESTAMP,'system',CURRENT_TIMESTAMP,'system',0,true),('550e8400-e29b-41d4-a716-446655440001','product','Product','Product master data','ORGANIZATION',CURRENT_TIMESTAMP,'system',CURRENT_TIMESTAMP,'system',0,true);
File: ./src/main/resources/db/migration/V1__Create_table_schema.sql
-------------------------------------------
CREATE TABLE ad_table (id UUID PRIMARY KEY,name VARCHAR(100) UNIQUE NOT NULL,display_name VARCHAR(100) NOT NULL,description TEXT,access_level VARCHAR(50) NOT NULL,created TIMESTAMP NOT NULL,created_by VARCHAR(100) NOT NULL,updated TIMESTAMP NOT NULL,updated_by VARCHAR(100) NOT NULL,version INTEGER NOT NULL DEFAULT 0,active BOOLEAN NOT NULL DEFAULT true,CONSTRAINT name_format CHECK (name ~ '^[a-z][a-z0-9_]*$'));CREATE INDEX idx_ad_table_name ON ad_table(name);CREATE INDEX idx_ad_table_active ON ad_table(active);COMMENT ON TABLE ad_table IS 'Application Dictionary Table Definitions';COMMENT ON COLUMN ad_table.id IS 'Time-based UUID primary key';COMMENT ON COLUMN ad_table.name IS 'Technical name (lowercase with underscores)';COMMENT ON COLUMN ad_table.display_name IS 'Human readable name';COMMENT ON COLUMN ad_table.description IS 'Optional description';COMMENT ON COLUMN ad_table.access_level IS 'Access level (SYSTEM,CLIENT,ORGANIZATION,etc)';COMMENT ON COLUMN ad_table.version IS 'Optimistic locking version';
File: ./src/main/kotlin/org/blackerp/infrastructure/event/DefaultEventPublisher.kt
-------------------------------------------
package org.blackerp.infrastructure.event import arrow.core.Either import arrow.core.right import org.blackerp.domain.event.DomainEvent import org.blackerp.domain.table.TableError import org.slf4j.LoggerFactory import org.springframework.stereotype.Component @Component class DefaultEventPublisher :EventPublisher {private val logger=LoggerFactory.getLogger(DefaultEventPublisher::class.java) override suspend fun publish(event:DomainEvent):Either<TableError,Unit> {logger.info("Publishing event:${event::class.simpleName} with ID:${event.metadata.id}") // In a real implementation,you might:// 1. Persist the event // 2. Send to message broker // 3. Notify subscribers return Unit.right()}} 
File: ./src/main/kotlin/org/blackerp/infrastructure/event/EventPublisher.kt
-------------------------------------------
package org.blackerp.infrastructure.event import arrow.core.Either import org.blackerp.domain.event.DomainEvent import org.blackerp.domain.table.TableError interface EventPublisher {suspend fun publish(event:DomainEvent):Either<TableError,Unit>} 
File: ./src/main/kotlin/org/blackerp/infrastructure/cache/CacheService.kt
-------------------------------------------
package org.blackerp.infrastructure.cache import arrow.core.Either import org.blackerp.domain.error.DomainError import java.time.Duration interface CacheService {suspend fun <T> get(key:String):Either<DomainError,T?> suspend fun <T> set(key:String,value:T,ttl:Duration?=null):Either<DomainError,Unit> suspend fun delete(key:String):Either<DomainError,Unit> suspend fun clear():Either<DomainError,Unit>} 
File: ./src/main/kotlin/org/blackerp/infrastructure/cache/InMemoryCacheService.kt
-------------------------------------------
package org.blackerp.infrastructure.cache import arrow.core.Either import arrow.core.right import org.blackerp.domain.error.DomainError import java.time.Duration import java.time.Instant import java.util.concurrent.ConcurrentHashMap class InMemoryCacheService :CacheService {private data class CacheEntry<T>(val value:T,val expiry:Instant?) private val cache=ConcurrentHashMap<String,CacheEntry<Any>>() @Suppress("UNCHECKED_CAST") override suspend fun <T> get(key:String):Either<DomainError,T?>=cache[key]?.let {entry->if (entry.expiry == null || entry.expiry> Instant.now()) {(entry.value as T).right()} else {cache.remove(key) null.right()}} ?:null.right() override suspend fun <T> set(key:String,value:T,ttl:Duration?):Either<DomainError,Unit> {val expiry=ttl?.let {Instant.now().plus(it)} cache[key]=CacheEntry(value as Any,expiry) return Unit.right()} override suspend fun delete(key:String):Either<DomainError,Unit> {cache.remove(key) return Unit.right()} override suspend fun clear():Either<DomainError,Unit> {cache.clear() return Unit.right()}} 
File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTableOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.EntityMetadata import org.blackerp.domain.table.ADTable import org.blackerp.domain.table.ColumnDefinition import org.blackerp.domain.table.TableError import org.blackerp.domain.table.TableOperations import org.blackerp.domain.values.* import org.springframework.dao.DataIntegrityViolationException import org.springframework.dao.EmptyResultDataAccessException import org.springframework.jdbc.core.JdbcTemplate import org.springframework.jdbc.core.RowMapper import org.springframework.stereotype.Repository import java.sql.ResultSet import java.time.Instant import java.util.UUID @Repository class PostgresTableOperations(private val jdbcTemplate:JdbcTemplate) :TableOperations {private val tableMapper=TableRowMapper() override suspend fun findAll():Either<TableError,List<ADTable>>=try {val tables=jdbcTemplate.query(""" SELECT id,name,display_name,description,access_level,created,created_by,updated,updated_by,version,active FROM ad_table WHERE active=true """,tableMapper) tables.right()} catch (e:Exception) {TableError.StorageError(e).left()} override suspend fun save(table:ADTable):Either<TableError,ADTable>=try {jdbcTemplate.update(""" INSERT INTO ad_table (id,name,display_name,description,access_level,created,created_by,updated,updated_by,version,active) VALUES (?,?,?,?,?,?,?,?,?,?,?) """,table.metadata.id,table.name.value,table.displayName.value,table.description?.value,table.accessLevel.name,table.metadata.created,table.metadata.createdBy,table.metadata.updated,table.metadata.updatedBy,table.metadata.version,table.metadata.active) table.right()} catch (e:DataIntegrityViolationException) {when {e.message?.contains("name_format") == true->TableError.StorageError(e).left() e.message?.contains("unique") == true->TableError.DuplicateTable(table.name.value).left() else->TableError.StorageError(e).left()}} catch (e:Exception) {TableError.StorageError(e).left()} override suspend fun findById(id:UUID):Either<TableError,ADTable?>=try {val table=jdbcTemplate.queryForObject(""" SELECT id,name,display_name,description,access_level,created,created_by,updated,updated_by,version,active FROM ad_table WHERE id=? """,tableMapper,id) table?.right() ?:TableError.NotFound(id.toString()).left()} catch (e:EmptyResultDataAccessException) {TableError.NotFound(id.toString()).left()} catch (e:Exception) {TableError.StorageError(e).left()} override suspend fun findByName(name:String):Either<TableError,ADTable?>=try {val table=jdbcTemplate.queryForObject(""" SELECT id,name,display_name,description,access_level,created,created_by,updated,updated_by,version,active FROM ad_table WHERE name=? """,tableMapper,name) table?.right() ?:TableError.NotFound(name).left()} catch (e:EmptyResultDataAccessException) {TableError.NotFound(name).left()} catch (e:Exception) {TableError.StorageError(e).left()} override suspend fun delete(id:UUID):Either<TableError,Unit>=try {val count=jdbcTemplate.update("DELETE FROM ad_table WHERE id=?",id) if (count> 0) Unit.right() else TableError.NotFound(id.toString()).left()} catch (e:Exception) {TableError.StorageError(e).left()} private class TableRowMapper :RowMapper<ADTable> {override fun mapRow(rs:ResultSet,rowNum:Int):ADTable {val metadata=EntityMetadata(id=UUID.fromString(rs.getString("id")),created=rs.getTimestamp("created").toInstant(),createdBy=rs.getString("created_by"),updated=rs.getTimestamp("updated").toInstant(),updatedBy=rs.getString("updated_by"),version=rs.getInt("version"),active=rs.getBoolean("active")) // Placeholder for fetching columns,replace with actual logic to retrieve columns from database val columns=listOf<ColumnDefinition>() return ADTable(metadata=metadata,name=TableName.create(rs.getString("name")).getOrNull()!!,displayName=DisplayName.create(rs.getString("display_name")).getOrNull()!!,description=rs.getString("description")?.let {Description.create(it).getOrNull()},accessLevel=AccessLevel.fromString(rs.getString("access_level")),columns=columns // Pass columns here)}}} 
File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresRelationshipOperations.kt
-------------------------------------------
// File:src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresRelationshipOperations.kt package org.blackerp.infrastructure.persistence.store import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.EntityMetadata import org.blackerp.domain.table.TableError import org.blackerp.domain.values.* import org.blackerp.domain.table.relationship.* import org.blackerp.domain.table.relationship.value.* import org.springframework.dao.DataIntegrityViolationException import org.springframework.dao.EmptyResultDataAccessException import org.springframework.jdbc.core.JdbcTemplate import org.springframework.jdbc.core.RowMapper import org.springframework.stereotype.Repository import java.sql.ResultSet import java.time.Instant import java.util.UUID @Repository class PostgresRelationshipOperations(private val jdbcTemplate:JdbcTemplate) :RelationshipOperations {private val relationshipMapper=RelationshipRowMapper() override suspend fun save(relationship:TableRelationship):Either<TableError,TableRelationship>=try {jdbcTemplate.update(""" INSERT INTO ad_table_relationship (id,name,source_table,target_table,type,source_column,target_column,delete_rule,update_rule,junction_table,created,created_by,updated,updated_by,version,active) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?,?) """,relationship.metadata.id,relationship.name.value,relationship.sourceTable.value,relationship.targetTable.value,relationship.type.name,relationship.sourceColumn.value,relationship.targetColumn.value,relationship.deleteRule.name,relationship.updateRule.name,null,// junction_table is null for non-many-to-many relationships relationship.metadata.created,relationship.metadata.createdBy,relationship.metadata.updated,relationship.metadata.updatedBy,relationship.metadata.version,relationship.metadata.active) relationship.right()} catch (e:DataIntegrityViolationException) {when {e.message?.contains("uk_relationship_name") == true->TableError.DuplicateTable(relationship.name.value).left() else->TableError.StorageError(e).left()}} catch (e:Exception) {TableError.StorageError(e).left()} override suspend fun findById(id:UUID):Either<TableError,TableRelationship?>=try {val relationship=jdbcTemplate.queryForObject(""" SELECT id,name,source_table,target_table,type,source_column,target_column,delete_rule,update_rule,junction_table,created,created_by,updated,updated_by,version,active FROM ad_table_relationship WHERE id=? """,relationshipMapper,id) relationship?.right() ?:TableError.NotFound(id.toString()).left()} catch (e:EmptyResultDataAccessException) {TableError.NotFound(id.toString()).left()} catch (e:Exception) {TableError.StorageError(e).left()} override suspend fun findByTable(tableName:TableName):Either<TableError,List<TableRelationship>>=try {val relationships=jdbcTemplate.query(""" SELECT id,name,source_table,target_table,type,source_column,target_column,delete_rule,update_rule,junction_table,created,created_by,updated,updated_by,version,active FROM ad_table_relationship WHERE source_table=? OR target_table=? """,relationshipMapper,tableName.value,tableName.value) relationships.right()} catch (e:Exception) {TableError.StorageError(e).left()} override suspend fun delete(id:UUID):Either<TableError,Unit>=try {val count=jdbcTemplate.update("DELETE FROM ad_table_relationship WHERE id=?",id) if (count> 0) Unit.right() else TableError.NotFound(id.toString()).left()} catch (e:Exception) {TableError.StorageError(e).left()} private class RelationshipRowMapper :RowMapper<TableRelationship> {override fun mapRow(rs:ResultSet,rowNum:Int):TableRelationship {val metadata=EntityMetadata(id=UUID.fromString(rs.getString("id")),created=rs.getTimestamp("created").toInstant(),createdBy=rs.getString("created_by"),updated=rs.getTimestamp("updated").toInstant(),updatedBy=rs.getString("updated_by"),version=rs.getInt("version"),active=rs.getBoolean("active")) return TableRelationship(metadata=metadata,name=RelationshipName.create(rs.getString("name")).getOrNull()!!,sourceTable=TableName.create(rs.getString("source_table")).getOrNull()!!,targetTable=TableName.create(rs.getString("target_table")).getOrNull()!!,type=RelationType.valueOf(rs.getString("type")),sourceColumn=ColumnName.create(rs.getString("source_column")).getOrNull()!!,targetColumn=ColumnName.create(rs.getString("target_column")).getOrNull()!!,constraints=emptyList(),// Load constraints if needed deleteRule=DeleteRule.valueOf(rs.getString("delete_rule")),updateRule=UpdateRule.valueOf(rs.getString("update_rule")))}}}
File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTabOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.EntityMetadata import org.blackerp.domain.ad.tab.* import org.blackerp.domain.ad.tab.value.TabName import org.blackerp.domain.values.* import org.blackerp.domain.table.TableOperations import org.blackerp.shared.ValidationError import org.springframework.jdbc.core.JdbcTemplate import org.springframework.jdbc.core.RowMapper import org.springframework.stereotype.Repository import java.sql.ResultSet import java.time.Instant import java.util.UUID import java.io.File @Repository class PostgresTabOperations(private val jdbcTemplate:JdbcTemplate,private val tableOperations:TableOperations) :TabOperations {private fun debug(msg:String) {File("testdebug.txt").appendText("${Instant.now()}:$msg\n")} override suspend fun save(tab:ADTab):Either<TabError,ADTab>=Either.catch {debug("Saving tab:${tab.name.value}") // First,verify the table exists val tableExists=jdbcTemplate.queryForObject("SELECT COUNT(*) FROM ad_table WHERE name=?",Int::class.java,tab.table.name.value) ?:0 debug("Table exists check:$tableExists") if (tableExists == 0) {throw IllegalStateException("Referenced table ${tab.table.name.value} does not exist")} // Insert/Update tab using MERGE val mergeResult=jdbcTemplate.update(""" MERGE INTO ad_tab KEY(id) VALUES (?,?,?,?,?,?,?,?,?,?,?) """,tab.metadata.id,tab.name.value,tab.displayName.value,tab.description?.value,tab.table.name.value,tab.metadata.created,tab.metadata.createdBy,tab.metadata.updated,tab.metadata.updatedBy,tab.metadata.version,tab.metadata.active) debug("Tab merge result:$mergeResult") // Update query columns jdbcTemplate.update("DELETE FROM ad_tab_query_column WHERE tab_id=?",tab.metadata.id) tab.queryColumns.forEachIndexed {index,column->val qcResult=jdbcTemplate.update(""" INSERT INTO ad_tab_query_column (tab_id,column_name,sequence) VALUES (?,?,?) """,tab.metadata.id,column.value,index) debug("Query column insert result:$qcResult")} // Update display columns jdbcTemplate.update("DELETE FROM ad_tab_display_column WHERE tab_id=?",tab.metadata.id) tab.displayColumns.forEachIndexed {index,column->val dcResult=jdbcTemplate.update(""" INSERT INTO ad_tab_display_column (tab_id,column_name,sequence) VALUES (?,?,?) """,tab.metadata.id,column.value,index) debug("Display column insert result:$dcResult")} // Update order by specifications jdbcTemplate.update("DELETE FROM ad_tab_order_by WHERE tab_id=?",tab.metadata.id) tab.orderBy.forEachIndexed {index,spec->val obResult=jdbcTemplate.update(""" INSERT INTO ad_tab_order_by (tab_id,column_name,direction,sequence) VALUES (?,?,?,?) """,tab.metadata.id,spec.column.value,spec.direction.name,index) debug("Order by insert result:$obResult")} tab}.mapLeft {e->debug("Error saving tab:${e.message}") e.printStackTrace(File("testdebug.txt").printWriter()) when (e) {is IllegalStateException->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error"))) else->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error")))}} override suspend fun findById(id:UUID):Either<TabError,ADTab?>=Either.catch {val results=jdbcTemplate.query(""" SELECT t.*,array_agg(DISTINCT qc.column_name) as query_columns,array_agg(DISTINCT dc.column_name) as display_columns,array_agg(DISTINCT ob.column_name || ',' || ob.direction) as order_by FROM ad_tab t LEFT JOIN ad_tab_query_column qc ON t.id=qc.tab_id LEFT JOIN ad_tab_display_column dc ON t.id=dc.tab_id LEFT JOIN ad_tab_order_by ob ON t.id=ob.tab_id WHERE t.id=? GROUP BY t.id,t.name,t.display_name,t.description,t.table_name,t.created,t.created_by,t.updated,t.updated_by,t.version,t.active """,TabRowMapper(tableOperations),id) results.firstOrNull()}.mapLeft {e->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error")))} override suspend fun findByTable(tableName:TableName):Either<TabError,List<ADTab>>=Either.catch {jdbcTemplate.query(""" SELECT t.*,array_agg(DISTINCT qc.column_name) as query_columns,array_agg(DISTINCT dc.column_name) as display_columns,array_agg(DISTINCT ob.column_name || ',' || ob.direction) as order_by FROM ad_tab t LEFT JOIN ad_tab_query_column qc ON t.id=qc.tab_id LEFT JOIN ad_tab_display_column dc ON t.id=dc.tab_id LEFT JOIN ad_tab_order_by ob ON t.id=ob.tab_id WHERE t.table_name=? GROUP BY t.id,t.name,t.display_name,t.description,t.table_name,t.created,t.created_by,t.updated,t.updated_by,t.version,t.active """,TabRowMapper(tableOperations),tableName.value)}.mapLeft {e->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error")))} override suspend fun delete(id:UUID):Either<TabError,Unit>=Either.catch {val count=jdbcTemplate.update("DELETE FROM ad_tab WHERE id=?",id) if (count == 0) throw IllegalStateException("Tab not found:$id") Unit}.mapLeft {e->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error")))} private class TabRowMapper(private val tableOperations:TableOperations) :RowMapper<ADTab> {override fun mapRow(rs:ResultSet,rowNum:Int):ADTab {val metadata=EntityMetadata(id=UUID.fromString(rs.getString("id")),created=rs.getTimestamp("created").toInstant(),createdBy=rs.getString("created_by"),updated=rs.getTimestamp("updated").toInstant(),updatedBy=rs.getString("updated_by"),version=rs.getInt("version"),active=rs.getBoolean("active")) val tableName=rs.getString("table_name") val table=kotlinx.coroutines.runBlocking {tableOperations.findByName(tableName).getOrNull() ?:throw IllegalStateException("Table not found:$tableName")} // Safe array handling val queryColumns=(rs.getArray("query_columns")?.array as? Array<*>) ?.filterNotNull() ?.map {it.toString()} ?.map {ColumnName.create(it).getOrNull()!!} ?:emptyList() val displayColumns=(rs.getArray("display_columns")?.array as? Array<*>) ?.filterNotNull() ?.map {it.toString()} ?.map {ColumnName.create(it).getOrNull()!!} ?:emptyList() val orderBy=(rs.getArray("order_by")?.array as? Array<*>) ?.filterNotNull() ?.map {it.toString()} ?.map {spec->val (col,dir)=spec.split(",") OrderBySpec(column=ColumnName.create(col).getOrNull()!!,direction=SortDirection.valueOf(dir))} ?:emptyList() return ADTab(metadata=metadata,name=TabName.create(rs.getString("name")).getOrNull()!!,displayName=DisplayName.create(rs.getString("display_name")).getOrNull()!!,description=rs.getString("description")?.let {Description.create(it).getOrNull()},table=table,queryColumns=queryColumns,displayColumns=displayColumns,orderBy=orderBy)}}}
File: ./src/main/kotlin/org/blackerp/BlackErpApplication.kt
-------------------------------------------
package org.blackerp import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication @SpringBootApplication(scanBasePackages=["org.blackerp"]) class BlackErpApplication fun main(args:Array<String>) {runApplication<BlackErpApplication>(*args)} 
File: ./src/main/kotlin/org/blackerp/plugin/PluginError.kt
-------------------------------------------
package org.blackerp.plugin import org.blackerp.shared.ValidationError sealed interface PluginError {data class NotFound(val id:String) :PluginError data class ValidationFailed(val errors:List<ValidationError>) :PluginError data class DuplicatePlugin(val id:String) :PluginError data class IncompatibleVersion(val required:Version,val actual:Version) :PluginError data class InitializationFailed(val id:String,val cause:Throwable) :PluginError data class DiscoveryFailed(val message:String,val cause:Throwable?=null) :PluginError data class LoadFailed(val message:String) :PluginError} 
File: ./src/main/kotlin/org/blackerp/plugin/Plugin.kt
-------------------------------------------
package org.blackerp.plugin import arrow.core.Either interface Plugin {val metadata:PluginMetadata /** * Initialize the plugin with provided context * @return Either an initialization error or Unit on success */ suspend fun initialize():Either<PluginError,Unit> /** * Register plugin extensions with the registry * @param registry Extension point registry * @return Either a registration error or Unit on success */ suspend fun registerExtensions(registry:ExtensionRegistry):Either<PluginError,Unit> /** * Clean up plugin resources * @return Either a cleanup error or Unit on success */ suspend fun shutdown():Either<PluginError,Unit>} 
File: ./src/main/kotlin/org/blackerp/plugin/discovery/FileSystemPluginDiscovery.kt
-------------------------------------------
package org.blackerp.plugin.discovery import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.plugin.Plugin import org.blackerp.plugin.PluginError import java.nio.file.Files import java.nio.file.Path import kotlin.io.path.extension import kotlin.io.path.isRegularFile class FileSystemPluginDiscovery :PluginDiscovery {override suspend fun discoverPlugins(directory:Path):Either<PluginError,List<Plugin>>=try {Files.walk(directory) .filter {it.isRegularFile() && it.extension == "jar"} .use {paths->paths.toList() .map {loadPlugin(it)} .filter {it.isRight()} .map {it.getOrNull()!!} .toList() .right()}} catch (e:Exception) {PluginError.DiscoveryFailed("Failed to discover plugins:${e.message}",e).left()} override suspend fun loadPlugin(jarPath:Path):Either<PluginError,Plugin>=try {// Placeholder for actual JAR loading logic // Will be implemented with proper classloading PluginError.LoadFailed("Plugin loading not yet implemented").left()} catch (e:Exception) {PluginError.LoadFailed("Failed to load plugin:${e.message}").left()}} 
File: ./src/main/kotlin/org/blackerp/plugin/discovery/PluginDiscovery.kt
-------------------------------------------
package org.blackerp.plugin.discovery import arrow.core.Either import org.blackerp.plugin.Plugin import org.blackerp.plugin.PluginError import java.nio.file.Path interface PluginDiscovery {suspend fun discoverPlugins(directory:Path):Either<PluginError,List<Plugin>> suspend fun loadPlugin(jarPath:Path):Either<PluginError,Plugin>} 
File: ./src/main/kotlin/org/blackerp/plugin/ExtensionRegistry.kt
-------------------------------------------
package org.blackerp.plugin import arrow.core.Either interface ExtensionRegistry {/** * Register an extension for a specific extension point * @param extension The extension implementation * @return Either a registration error or Unit on success */ suspend fun <T :Extension> register(extension:T):Either<PluginError,Unit> /** * Get all registered extensions for a specific type * @return List of registered extensions */ fun <T :Extension> getExtensions(type:Class<T>):List<T>} 
File: ./src/main/kotlin/org/blackerp/plugin/PluginId.kt
-------------------------------------------
package org.blackerp.plugin import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class PluginId private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,PluginId>=when {!value.matches(Regex("^[a-z][a-z0-9-]*$"))->ValidationError.InvalidFormat("Plugin ID must start with lowercase letter and contain only lowercase letters,numbers,and hyphens").left() value.length !in 3..50->ValidationError.InvalidLength("plugin id",3,50).left() else->PluginId(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/plugin/registry/PluginRegistry.kt
-------------------------------------------
package org.blackerp.plugin.registry import arrow.core.Either import org.blackerp.plugin.Plugin import org.blackerp.plugin.PluginError import org.blackerp.plugin.PluginId interface PluginRegistry {suspend fun register(plugin:Plugin):Either<PluginError,Unit> suspend fun unregister(pluginId:PluginId):Either<PluginError,Unit> suspend fun getPlugin(pluginId:PluginId):Either<PluginError,Plugin> fun getPlugins():List<Plugin>} 
File: ./src/main/kotlin/org/blackerp/plugin/registry/DefaultPluginRegistry.kt
-------------------------------------------
package org.blackerp.plugin.registry import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.plugin.Plugin import org.blackerp.plugin.PluginError import org.blackerp.plugin.PluginId import java.util.concurrent.ConcurrentHashMap class DefaultPluginRegistry :PluginRegistry {private val plugins=ConcurrentHashMap<PluginId,Plugin>() override suspend fun register(plugin:Plugin):Either<PluginError,Unit>=when {plugins.containsKey(plugin.metadata.id)->PluginError.DuplicatePlugin(plugin.metadata.id.value).left() else->{plugins[plugin.metadata.id]=plugin Unit.right()}} override suspend fun unregister(pluginId:PluginId):Either<PluginError,Unit>=plugins.remove(pluginId)?.let {Unit.right()} ?:PluginError.NotFound(pluginId.value).left() override suspend fun getPlugin(pluginId:PluginId):Either<PluginError,Plugin>=plugins[pluginId]?.right() ?:PluginError.NotFound(pluginId.value).left() override fun getPlugins():List<Plugin>=plugins.values.toList()} 
File: ./src/main/kotlin/org/blackerp/plugin/Version.kt
-------------------------------------------
package org.blackerp.plugin import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError data class Version private constructor(val major:Int,val minor:Int,val patch:Int) :Comparable<Version> {override fun compareTo(other:Version):Int {return when {major != other.major->major - other.major minor != other.minor->minor - other.minor else->patch - other.patch}} companion object {private val VERSION_PATTERN=Regex("^\\d+\\.\\d+\\.\\d+$") fun create(version:String):Either<ValidationError,Version> {if (!version.matches(VERSION_PATTERN)) {return ValidationError.InvalidFormat("Version must be in format major.minor.patch").left()} return try {val parts=version.split(".") if (parts.size != 3) {ValidationError.InvalidFormat("Version must be in format major.minor.patch").left()} else {Version(major=parts[0].toInt(),minor=parts[1].toInt(),patch=parts[2].toInt()).right()}} catch (e:NumberFormatException) {ValidationError.InvalidFormat("Version components must be integers").left()}}} override fun toString():String="$major.$minor.$patch"}
File: ./src/main/kotlin/org/blackerp/plugin/Extension.kt
-------------------------------------------
package org.blackerp.plugin /** * Base interface for all plugin extensions */ interface Extension {val pluginId:PluginId} 
File: ./src/main/kotlin/org/blackerp/plugin/PluginMetadata.kt
-------------------------------------------
package org.blackerp.plugin import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError data class PluginMetadata private constructor(val id:PluginId,val version:Version,val name:String,val description:String,val vendor:String) {companion object {fun create(id:PluginId,version:Version,name:String,description:String,vendor:String):Either<ValidationError,PluginMetadata>=when {name.isBlank()->ValidationError.Required("name").left() name.length !in 3..100->ValidationError.InvalidLength("name",3,100).left() description.length> 500->ValidationError.InvalidLength("description",0,500).left() vendor.isBlank()->ValidationError.Required("vendor").left() vendor.length !in 3..100->ValidationError.InvalidLength("vendor",3,100).left() else->PluginMetadata(id,version,name,description,vendor).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/ad/ADModule.kt
-------------------------------------------
package org.blackerp.domain.ad import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.EntityMetadata import org.blackerp.domain.ad.value.ModuleName import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description import org.blackerp.shared.ValidationError import org.blackerp.plugin.Version data class ADModule(override val metadata:EntityMetadata,val name:ModuleName,override val displayName:DisplayName,override val description:Description?,val version:Version) :ADObject {companion object {fun create(params:CreateModuleParams):Either<ValidationError,ADModule>=ADModule(metadata=params.metadata,name=params.name,displayName=params.displayName,description=params.description,version=params.version).right()}} data class CreateModuleParams(val metadata:EntityMetadata,val name:ModuleName,val displayName:DisplayName,val description:Description?,val version:Version) 
File: ./src/main/kotlin/org/blackerp/domain/ad/window/value/WindowName.kt
-------------------------------------------
package org.blackerp.domain.ad.window.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class WindowName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,WindowName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Window name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("window name",3,50).left() else->WindowName(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/ad/ADObject.kt
-------------------------------------------
package org.blackerp.domain.ad import org.blackerp.domain.DomainEntity import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description interface ADObject :DomainEntity {val displayName:DisplayName val description:Description?} 
File: ./src/main/kotlin/org/blackerp/domain/ad/tab/TabOperations.kt
-------------------------------------------
package org.blackerp.domain.ad.tab import arrow.core.Either import org.blackerp.domain.values.TableName import java.util.UUID interface TabOperations {suspend fun save(tab:ADTab):Either<TabError,ADTab> suspend fun findById(id:UUID):Either<TabError,ADTab?> suspend fun findByTable(tableName:TableName):Either<TabError,List<ADTab>> suspend fun delete(id:UUID):Either<TabError,Unit>}
File: ./src/main/kotlin/org/blackerp/domain/ad/tab/CreateTabParams.kt
-------------------------------------------
package org.blackerp.domain.ad.tab import org.blackerp.domain.EntityMetadata import org.blackerp.domain.table.ADTable import org.blackerp.domain.values.ColumnName import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description import org.blackerp.domain.ad.tab.value.TabName data class CreateTabParams(val metadata:EntityMetadata,val name:TabName,val displayName:DisplayName,val description:Description?,val table:ADTable,val queryColumns:List<ColumnName>,val displayColumns:List<ColumnName>,val orderBy:List<OrderBySpec>) 
File: ./src/main/kotlin/org/blackerp/domain/ad/tab/OrderBySpec.kt
-------------------------------------------
package org.blackerp.domain.ad.tab import org.blackerp.domain.values.ColumnName data class OrderBySpec(val column:ColumnName,val direction:SortDirection) enum class SortDirection {ASC,DESC;companion object {fun fromString(value:String):SortDirection=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid sort direction:$value")}} 
File: ./src/main/kotlin/org/blackerp/domain/ad/tab/value/TabName.kt
-------------------------------------------
package org.blackerp.domain.ad.tab.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class TabName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TabName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Tab name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("tab name",3,50).left() else->TabName(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/ad/tab/TabError.kt
-------------------------------------------
package org.blackerp.domain.ad.tab import org.blackerp.domain.DomainException import org.blackerp.shared.ValidationError sealed class TabError(message:String) :DomainException(message) {data class ValidationFailed(val errors:List<ValidationError>) :TabError("Validation failed:${errors.joinToString {it.message}}") data class NotFound(val id:String) :TabError("Tab not found:$id") data class DuplicateTab(val name:String) :TabError("Tab already exists:$name")} 
File: ./src/main/kotlin/org/blackerp/domain/ad/tab/ADTab.kt
-------------------------------------------
package org.blackerp.domain.ad.tab import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.domain.DomainEntity import org.blackerp.domain.EntityMetadata import org.blackerp.domain.ad.ADObject import org.blackerp.domain.ad.tab.value.TabName import org.blackerp.domain.values.* import org.blackerp.domain.table.ADTable import org.blackerp.shared.ValidationError data class ADTab(override val metadata:EntityMetadata,val name:TabName,override val displayName:DisplayName,override val description:Description?,val table:ADTable,val queryColumns:List<ColumnName>,val displayColumns:List<ColumnName>,val orderBy:List<OrderBySpec>) :ADObject {companion object {fun create(params:CreateTabParams):Either<TabError,ADTab> {val errors=mutableListOf<ValidationError>() // Validate query columns exist in table val invalidQueryColumns=params.queryColumns.filter {queryCol->!params.table.columns.any {it.name == queryCol}} if (invalidQueryColumns.isNotEmpty()) {errors.add(ValidationError.InvalidValue("Query columns not found in table:${invalidQueryColumns.joinToString {it.value}}"))} // Validate display columns exist in table val invalidDisplayColumns=params.displayColumns.filter {displayCol->!params.table.columns.any {it.name == displayCol}} if (invalidDisplayColumns.isNotEmpty()) {errors.add(ValidationError.InvalidValue("Display columns not found in table:${invalidDisplayColumns.joinToString {it.value}}"))} // Validate order by columns exist in table val invalidOrderColumns=params.orderBy.filter {orderSpec->!params.table.columns.any {it.name == orderSpec.column}} if (invalidOrderColumns.isNotEmpty()) {errors.add(ValidationError.InvalidValue("Order by columns not found in table:${invalidOrderColumns.joinToString {it.column.value}}"))} if (errors.isNotEmpty()) {return TabError.ValidationFailed(errors).left()} return ADTab(metadata=params.metadata,name=params.name,displayName=params.displayName,description=params.description,table=params.table,queryColumns=params.queryColumns,displayColumns=params.displayColumns,orderBy=params.orderBy).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/ad/value/ModuleName.kt
-------------------------------------------
package org.blackerp.domain.ad.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class ModuleName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ModuleName>=when {!value.matches(Regex("^[a-z][a-z0-9-]*$"))->ValidationError.InvalidFormat("Module name must start with lowercase letter and contain only lowercase letters,numbers,and hyphens").left() value.length !in 3..50->ValidationError.InvalidLength("module name",3,50).left() else->ModuleName(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/ad/reference/value/ReferenceName.kt
-------------------------------------------
package org.blackerp.domain.ad.reference.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class ReferenceName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ReferenceName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Reference name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("reference name",3,50).left() else->ReferenceName(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/ad/reference/ADReference.kt
-------------------------------------------
package org.blackerp.domain.ad.reference import arrow.core.Either import arrow.core.right import org.blackerp.domain.EntityMetadata import org.blackerp.domain.ad.ADObject import org.blackerp.domain.ad.reference.value.ReferenceName import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description import org.blackerp.shared.ValidationError data class ADReference(override val metadata:EntityMetadata,val name:ReferenceName,override val displayName:DisplayName,override val description:Description?,val type:ReferenceType,val validationRule:ValidationRule?) :ADObject {companion object {fun create(params:CreateReferenceParams):Either<ReferenceError,ADReference>=ADReference(metadata=params.metadata,name=params.name,displayName=params.displayName,description=params.description,type=params.type,validationRule=params.validationRule).right()}} data class ValidationRule(val expression:String,val errorMessage:String) sealed interface ReferenceType {object List :ReferenceType data class Table(val tableName:String,val keyColumn:String,val displayColumn:String) :ReferenceType object Search :ReferenceType data class Custom(val validatorClass:String) :ReferenceType} data class CreateReferenceParams(val metadata:EntityMetadata,val name:ReferenceName,val displayName:DisplayName,val description:Description?,val type:ReferenceType,val validationRule:ValidationRule?=null) sealed class ReferenceError {data class ValidationFailed(val errors:List<ValidationError>) :ReferenceError() data class DuplicateReference(val name:String) :ReferenceError() data class ReferenceNotFound(val name:String) :ReferenceError()} 
File: ./src/main/kotlin/org/blackerp/domain/event/EventMetadata.kt
-------------------------------------------
package org.blackerp.domain.event import java.time.Instant import java.util.UUID data class EventMetadata(val id:UUID,val timestamp:Instant,val user:String) 
File: ./src/main/kotlin/org/blackerp/domain/event/DomainEvent.kt
-------------------------------------------
package org.blackerp.domain.event interface DomainEvent {val metadata:EventMetadata} 
File: ./src/main/kotlin/org/blackerp/domain/event/TableCreated.kt
-------------------------------------------
package org.blackerp.domain.event import java.util.UUID data class TableCreated(override val metadata:EventMetadata,val tableId:UUID,val tableName:String) :DomainEvent 
File: ./src/main/kotlin/org/blackerp/domain/DomainException.kt
-------------------------------------------
package org.blackerp.domain abstract class DomainException(message:String) :Exception(message) 
File: ./src/main/kotlin/org/blackerp/domain/error/DomainError.kt
-------------------------------------------
package org.blackerp.domain.error sealed interface DomainError {val message:String data class ValidationError(override val message:String,val field:String?=null) :DomainError data class NotFoundError(override val message:String,val id:String) :DomainError data class SecurityError(override val message:String,val reason:String) :DomainError data class CacheError(override val message:String,val cause:Throwable?=null) :DomainError data class QueryError(override val message:String,val reason:String) :DomainError data class SystemError(override val message:String,val cause:Throwable?=null) :DomainError} 
File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantFilter.kt
-------------------------------------------
package org.blackerp.domain.tenant import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.shared.ValidationError data class TenantFilter(val tenantId:String?) {companion object {fun create(tenantId:String?):Either<ValidationError,TenantFilter>=when {tenantId == null->TenantFilter(null).right() !tenantId.matches(Regex("^[0-9a-fA-F-]{36}$"))->ValidationError.InvalidFormat("Invalid UUID format").left() else->TenantFilter(tenantId).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantContext.kt
-------------------------------------------
package org.blackerp.domain.tenant import java.util.UUID object TenantContext {private val currentTenant=ThreadLocal<UUID>() fun getCurrentTenant():UUID?=currentTenant.get() fun setCurrentTenant(tenantId:UUID) {currentTenant.set(tenantId)} fun clear() {currentTenant.remove()}} 
File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantAware.kt
-------------------------------------------
package org.blackerp.domain.tenant import java.util.UUID interface TenantAware {val tenantId:UUID} 
File: ./src/main/kotlin/org/blackerp/domain/values/DataType.kt
-------------------------------------------
package org.blackerp.domain.values enum class DataType {STRING,INTEGER,DECIMAL,BOOLEAN,DATE,TIMESTAMP,BINARY;companion object {fun fromString(value:String):DataType=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid data type:$value")}} 
File: ./src/main/kotlin/org/blackerp/domain/values/Precision.kt
-------------------------------------------
package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class Precision private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Precision>=when {value <0->ValidationError.InvalidValue("Precision cannot be negative").left() value> 20->ValidationError.InvalidValue("Precision cannot exceed 20").left() else->Precision(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/values/AccessLevel.kt
-------------------------------------------
package org.blackerp.domain.values enum class AccessLevel {SYSTEM,CLIENT,ORGANIZATION,CLIENT_ORGANIZATION;companion object {fun fromString(value:String):AccessLevel=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid access level:$value")}} 
File: ./src/main/kotlin/org/blackerp/domain/values/Description.kt
-------------------------------------------
package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class Description private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,Description>=when {value.length> 255->ValidationError.InvalidLength("description",0,255).left() else->Description(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/values/Amount.kt
-------------------------------------------
package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError import java.math.BigDecimal @JvmInline value class Amount private constructor(val value:BigDecimal) {companion object {fun create(value:BigDecimal):Either<ValidationError,Amount>=when {value <BigDecimal.ZERO->ValidationError.InvalidValue("Amount cannot be negative").left() else->Amount(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/values/ColumnName.kt
-------------------------------------------
// File:src/main/kotlin/org/blackerp/domain/values/ColumnName.kt package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class ColumnName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ColumnName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Column name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length> 30->ValidationError.InvalidLength("column name",1,30).left() else->ColumnName(value).right()}}}
File: ./src/main/kotlin/org/blackerp/domain/values/Scale.kt
-------------------------------------------
package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class Scale private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Scale>=when {value <0->ValidationError.InvalidValue("Scale cannot be negative").left() value> 10->ValidationError.InvalidValue("Scale cannot exceed 10").left() else->Scale(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/values/Length.kt
-------------------------------------------
package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class Length private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Length>=when {value <= 0->ValidationError.InvalidValue("Length must be positive").left() else->Length(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/values/EventMetadata.kt
-------------------------------------------
package org.blackerp.domain.values import java.time.Instant import java.util.UUID data class EventMetadata(val id:UUID,val timestamp:Instant,val user:String) 
File: ./src/main/kotlin/org/blackerp/domain/values/TableName.kt
-------------------------------------------
package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class TableName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TableName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Table name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() else->TableName(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/values/Currency.kt
-------------------------------------------
package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class Currency private constructor(val code:String) {companion object {fun create(code:String):Either<ValidationError,Currency>=when {!code.matches(Regex("^[A-Z]{3}$"))->ValidationError.InvalidFormat("Currency code must be 3 uppercase letters").left() else->Currency(code).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/values/DisplayName.kt
-------------------------------------------
package org.blackerp.domain.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class DisplayName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,DisplayName>=when {value.isBlank()->ValidationError.Required("display name").left() value.length !in 1..60->ValidationError.InvalidLength("display name",1,60).left() else->DisplayName(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/transaction/Transaction.kt
-------------------------------------------
package org.blackerp.domain.transaction import arrow.core.Either import arrow.core.right import org.blackerp.domain.DomainEntity import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.Amount import org.blackerp.domain.values.Currency import java.time.Instant data class Transaction(override val metadata:EntityMetadata,val amount:Amount,val currency:Currency,val timestamp:Instant,val description:String?) :DomainEntity {companion object {fun create(params:CreateTransactionParams):Either<TransactionError,Transaction>=Transaction(metadata=params.metadata,amount=params.amount,currency=params.currency,timestamp=params.timestamp,description=params.description).right()}} data class CreateTransactionParams(val metadata:EntityMetadata,val amount:Amount,val currency:Currency,val timestamp:Instant=Instant.now(),val description:String?) 
File: ./src/main/kotlin/org/blackerp/domain/transaction/TransactionError.kt
-------------------------------------------
package org.blackerp.domain.transaction import org.blackerp.shared.ValidationError sealed class TransactionError {abstract val message:String data class ValidationFailed(override val message:String,val errors:List<ValidationError>) :TransactionError() data class InvalidAmount(val amount:String,override val message:String="Invalid amount:$amount") :TransactionError() data class InvalidCurrency(val currency:String,override val message:String="Invalid currency:$currency") :TransactionError()} 
File: ./src/main/kotlin/org/blackerp/domain/query/QueryResult.kt
-------------------------------------------
package org.blackerp.domain.query import arrow.core.Either import org.blackerp.domain.error.DomainError data class QueryResult<T>(val items:List<T>,val total:Long,val page:Int,val pageSize:Int) interface QueryExecutor<T> {suspend fun execute(criteria:QueryCriteria,page:Int,pageSize:Int):Either<DomainError,QueryResult<T>>} 
File: ./src/main/kotlin/org/blackerp/domain/query/QueryCriteria.kt
-------------------------------------------
package org.blackerp.domain.query sealed interface QueryCriteria {data class Equals(val field:String,val value:Any) :QueryCriteria data class Like(val field:String,val pattern:String) :QueryCriteria data class Between(val field:String,val start:Any,val end:Any) :QueryCriteria data class In(val field:String,val values:List<Any>) :QueryCriteria data class And(val criteria:List<QueryCriteria>) :QueryCriteria data class Or(val criteria:List<QueryCriteria>) :QueryCriteria} 
File: ./src/main/kotlin/org/blackerp/domain/DomainEntity.kt
-------------------------------------------
package org.blackerp.domain interface DomainEntity {val metadata:EntityMetadata} 
File: ./src/main/kotlin/org/blackerp/domain/table/TableOperations.kt
-------------------------------------------
// File:src/main/kotlin/org/blackerp/domain/table/TableOperations.kt package org.blackerp.domain.table import arrow.core.Either import java.util.UUID interface TableOperations {/** * Returns all tables in the system * @return Either an error or list of tables */ suspend fun findAll():Either<TableError,List<ADTable>> /** * Saves a table to the store * @param table The table to save * @return Either an error or the saved table */ suspend fun save(table:ADTable):Either<TableError,ADTable> /** * Finds a table by its ID * @param id The UUID of the table * @return Either an error or the found table (null if not found) */ suspend fun findById(id:UUID):Either<TableError,ADTable?> /** * Finds a table by its name * @param name The name of the table * @return Either an error or the found table (null if not found) */ suspend fun findByName(name:String):Either<TableError,ADTable?> /** * Deletes a table by its ID * @param id The UUID of the table to delete * @return Either an error or Unit on success */ suspend fun delete(id:UUID):Either<TableError,Unit>} 
File: ./src/main/kotlin/org/blackerp/domain/table/ADTable.kt
-------------------------------------------
package org.blackerp.domain.table import arrow.core.Either import arrow.core.right import org.blackerp.domain.DomainEntity import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.TableName import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description import org.blackerp.domain.values.AccessLevel import org.blackerp.domain.table.ColumnDefinition data class ADTable(override val metadata:EntityMetadata,val name:TableName,val displayName:DisplayName,val description:Description?,val accessLevel:AccessLevel,val columns:List<ColumnDefinition> // Added columns property) :DomainEntity {companion object {fun create(params:CreateTableParams):Either<TableError,ADTable>=ADTable(metadata=params.metadata,name=params.name,displayName=params.displayName,description=params.description,accessLevel=params.accessLevel,columns=params.columns // Initialize columns).right()}} data class CreateTableParams(val metadata:EntityMetadata,val name:TableName,val displayName:DisplayName,val description:Description?,val accessLevel:AccessLevel,val columns:List<ColumnDefinition>) 
File: ./src/main/kotlin/org/blackerp/domain/table/extension/TableExtensionPoint.kt
-------------------------------------------
package org.blackerp.domain.table.extension import arrow.core.Either import org.blackerp.domain.table.ADTable import org.blackerp.plugin.Extension import org.blackerp.plugin.PluginError interface TableExtensionPoint {suspend fun beforeCreate(table:ADTable):Either<PluginError,ADTable> suspend fun afterCreate(table:ADTable) suspend fun beforeUpdate(table:ADTable):Either<PluginError,ADTable> suspend fun afterUpdate(table:ADTable) suspend fun beforeDelete(table:ADTable):Either<PluginError,Unit> suspend fun afterDelete(table:ADTable)} 
File: ./src/main/kotlin/org/blackerp/domain/table/extension/TableExtension.kt
-------------------------------------------
package org.blackerp.domain.table.extension import org.blackerp.plugin.Extension import org.blackerp.plugin.PluginId interface TableExtension :Extension,TableExtensionPoint {override val pluginId:PluginId} 
File: ./src/main/kotlin/org/blackerp/domain/table/CreateColumnParams.kt
-------------------------------------------
package org.blackerp.domain.table import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.ColumnName import org.blackerp.domain.values.DataType import org.blackerp.domain.values.Length import org.blackerp.domain.values.Precision import org.blackerp.domain.values.Scale import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description // Unified CreateColumnParams definition data class CreateColumnParams(val metadata:EntityMetadata,val name:ColumnName,val displayName:DisplayName,val description:Description?,val dataType:DataType,val length:Length?,val precision:Precision?,val scale:Scale?,val mandatory:Boolean=false,val defaultValue:String?=null) 
File: ./src/main/kotlin/org/blackerp/domain/table/TenantAwareTable.kt
-------------------------------------------
package org.blackerp.domain.table import org.blackerp.domain.tenant.TenantAware import org.blackerp.domain.DomainEntity import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.* import java.util.UUID data class TenantAwareTable(override val metadata:EntityMetadata,override val tenantId:UUID,val delegate:ADTable) :DomainEntity by delegate,TenantAware {val name:TableName get()=delegate.name val displayName:DisplayName get()=delegate.displayName companion object {fun from(table:ADTable,tenantId:UUID):TenantAwareTable=TenantAwareTable(metadata=table.metadata,tenantId=tenantId,delegate=table)}} 
File: ./src/main/kotlin/org/blackerp/domain/table/constraint/TableConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.constraint import arrow.core.Either import org.blackerp.domain.DomainEntity import org.blackerp.domain.table.definition.TableDefinition import org.blackerp.shared.ValidationError interface TableConstraint :DomainEntity {// Make the interface method suspend as well suspend fun validate(table:TableDefinition):Either<ValidationError,Unit>}
File: ./src/main/kotlin/org/blackerp/domain/table/constraint/UniqueConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.constraint import org.blackerp.domain.table.definition.TableDefinition import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.ColumnName import org.blackerp.shared.ValidationError data class UniqueConstraint(override val metadata:EntityMetadata,val columns:List<ColumnName>) :TableConstraint {override suspend fun validate(table:TableDefinition):Either<ValidationError,Unit> {val tableColumns=table.columns.map {it.name} val invalidColumns=columns.filter {it !in tableColumns} return if (invalidColumns.isEmpty()) {Unit.right()} else {ValidationError.InvalidValue("Columns not found in table:${invalidColumns.joinToString {it.value}}").left()}}} 
File: ./src/main/kotlin/org/blackerp/domain/table/constraint/NotNullConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.constraint import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.ColumnName import org.blackerp.shared.ValidationError import org.blackerp.domain.table.definition.TableDefinition data class NotNullConstraint(override val metadata:EntityMetadata,val column:ColumnName) :TableConstraint {override suspend fun validate(table:TableDefinition):Either<ValidationError,Unit> {val columnExists=table.columns.any {it.name == column} return if (columnExists) {Unit.right()} else {ValidationError.InvalidValue("Column not found in table:${column.value}").left()}}}
File: ./src/main/kotlin/org/blackerp/domain/table/constraint/ReferenceConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.constraint import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.* import org.blackerp.domain.table.TableOperations import org.blackerp.domain.table.ADTable import org.blackerp.domain.table.ColumnDefinition import org.blackerp.domain.table.definition.TableDefinition import org.blackerp.shared.ValidationError import org.blackerp.shared.ReferenceValidation data class ReferenceConstraint(override val metadata:EntityMetadata,val column:ColumnName,val referenceTable:TableName,val referenceColumn:ColumnName,private val tableOperations:TableOperations) :TableConstraint {override suspend fun validate(table:TableDefinition):Either<ValidationError,Unit> {// 1. Verify source column exists val sourceColumn=table.columns.find {it.name == column} ?:return ReferenceValidation.ColumnNotFound(column.value).left() // 2. Find reference table when (val refTableResult=tableOperations.findByName(referenceTable.value)) {is Either.Left->return ReferenceValidation.ReferenceTableNotFound(referenceTable.value).left() is Either.Right->{val refTable=refTableResult.value ?:return ReferenceValidation.ReferenceTableNotFound(referenceTable.value).left() // Convert ADTable to TableDefinition val refTableDef=toTableDefinition(refTable) // 3. Verify reference column exists val refColumn=refTableDef.columns.find {it.name == referenceColumn} ?:return ReferenceValidation.ReferenceColumnNotFound(referenceTable.value,referenceColumn.value).left() // 4. Check type compatibility if (sourceColumn.dataType != refColumn.dataType) {return ReferenceValidation.IncompatibleTypes(sourceColumn.name.value,sourceColumn.dataType.name,refColumn.name.value,refColumn.dataType.name).left()} // 5. Check length/precision compatibility for certain types when (sourceColumn.dataType) {DataType.STRING->{val sourceLength=sourceColumn.length?.value ?:0 val refLength=refColumn.length?.value ?:0 if (sourceLength> refLength) {return ValidationError.InvalidValue("Source column length ($sourceLength) cannot be greater than reference column length ($refLength)").left()}} DataType.DECIMAL->{val sourcePrecision=sourceColumn.precision?.value ?:0 val refPrecision=refColumn.precision?.value ?:0 if (sourcePrecision> refPrecision) {return ValidationError.InvalidValue("Source column precision ($sourcePrecision) cannot be greater than reference column precision ($refPrecision)").left()} val sourceScale=sourceColumn.scale?.value ?:0 val refScale=refColumn.scale?.value ?:0 if (sourceScale> refScale) {return ValidationError.InvalidValue("Source column scale ($sourceScale) cannot be greater than reference column scale ($refScale)").left()}} else->Unit} return Unit.right()}}} private fun toTableDefinition(table:ADTable):TableDefinition {return TableDefinition(metadata=table.metadata,name=table.name,displayName=table.displayName,description=table.description,accessLevel=table.accessLevel,columns=table.columns,constraints=emptyList(),behaviors=emptyList())}}
File: ./src/main/kotlin/org/blackerp/domain/table/TableCreated.kt
-------------------------------------------
package org.blackerp.domain.table import org.blackerp.domain.DomainEvent import org.blackerp.domain.values.EventMetadata import java.util.UUID data class TableCreated(override val metadata:EventMetadata,val tableId:UUID,val tableName:String) :DomainEvent 
File: ./src/main/kotlin/org/blackerp/domain/table/TableError.kt
-------------------------------------------
package org.blackerp.domain.table import org.blackerp.domain.DomainException import org.blackerp.shared.ValidationError sealed class TableError(message:String) :DomainException(message) {data class ValidationFailed(val errors:List<ValidationError>) :TableError("Validation failed:${errors.joinToString {it.message}}") data class StorageError(override val cause:Throwable) :TableError("Storage error:${cause.message}") data class DuplicateTable(val name:String) :TableError("Table already exists:$name") data class NotFound(val id:String) :TableError("Table not found:$id") data class ConcurrentModification(val id:String) :TableError("Concurrent modification detected for table:$id")} 
File: ./src/main/kotlin/org/blackerp/domain/table/definition/TableDefinition.kt
-------------------------------------------
package org.blackerp.domain.table.definition import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.DomainEntity import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.* import org.blackerp.domain.table.ColumnDefinition import org.blackerp.domain.table.TableError import org.blackerp.domain.table.constraint.TableConstraint import org.blackerp.domain.table.behavior.TableBehavior import org.blackerp.shared.ValidationError import kotlinx.coroutines.runBlocking data class TableDefinition(override val metadata:EntityMetadata,val name:TableName,val displayName:DisplayName,val description:Description?,val accessLevel:AccessLevel,val columns:List<ColumnDefinition>,val constraints:List<TableConstraint>,val behaviors:List<TableBehavior>) :DomainEntity {companion object {suspend fun create(params:CreateTableParams):Either<TableError,TableDefinition> {val errors=mutableListOf<ValidationError>() // Basic validation if (params.columns.isEmpty()) {errors.add(ValidationError.Required("at least one column"))} // Check for duplicate column names val duplicateColumns=params.columns .groupBy {it.name.value} .filter {it.value.size> 1} .keys if (duplicateColumns.isNotEmpty()) {errors.add(ValidationError.InvalidValue("Duplicate column names:${duplicateColumns.joinToString()}"))} if (errors.isNotEmpty()) {return TableError.ValidationFailed(errors).left()} val table=TableDefinition(metadata=params.metadata,name=params.name,displayName=params.displayName,description=params.description,accessLevel=params.accessLevel,columns=params.columns,constraints=params.constraints,behaviors=params.behaviors) // Validate all constraints val constraintErrors=table.constraints .map {it.validate(table)} .filter {it.isLeft()} .flatMap {(it as Either.Left).value.let {listOf(it)}} if (constraintErrors.isNotEmpty()) {return TableError.ValidationFailed(constraintErrors).left()} return table.right()}} suspend fun validate():Either<TableError,Unit> {val errors=constraints .map {it.validate(this)} .filter {it.isLeft()} .flatMap {(it as Either.Left).value.let {listOf(it)}} return if (errors.isEmpty()) {Unit.right()} else {TableError.ValidationFailed(errors).left()}}} data class CreateTableParams(val metadata:EntityMetadata,val name:TableName,val displayName:DisplayName,val description:Description?,val accessLevel:AccessLevel,val columns:List<ColumnDefinition>,val constraints:List<TableConstraint>=emptyList(),val behaviors:List<TableBehavior>=emptyList()) 
File: ./src/main/kotlin/org/blackerp/domain/table/behavior/TableBehavior.kt
-------------------------------------------
package org.blackerp.domain.table.behavior import org.blackerp.domain.table.definition.TableDefinition import arrow.core.Either import org.blackerp.domain.DomainEntity import org.blackerp.domain.table.TableError interface TableBehavior :DomainEntity {fun beforeSave(table:TableDefinition):Either<TableError,TableDefinition> fun afterSave(table:TableDefinition) fun beforeDelete(table:TableDefinition):Either<TableError,Unit> fun afterDelete(table:TableDefinition)} 
File: ./src/main/kotlin/org/blackerp/domain/table/TableId.kt
-------------------------------------------
package org.blackerp.domain.table import java.util.UUID @JvmInline value class TableId(val value:UUID) 
File: ./src/main/kotlin/org/blackerp/domain/table/ColumnDefinition.kt
-------------------------------------------
package org.blackerp.domain.table import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.DomainEntity import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.ColumnName import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description import org.blackerp.domain.values.DataType import org.blackerp.domain.values.Length import org.blackerp.domain.values.Precision import org.blackerp.domain.values.Scale import org.blackerp.shared.ValidationError data class ColumnDefinition(override val metadata:EntityMetadata,val name:ColumnName,val displayName:DisplayName,val description:Description?,val dataType:DataType,val length:Length?,val precision:Precision?,val scale:Scale?,val mandatory:Boolean=false,val defaultValue:String?=null) :DomainEntity {companion object {fun create(params:CreateColumnParams):Either<ColumnError,ColumnDefinition> {val errors=mutableListOf<ValidationError>() when (params.dataType) {DataType.STRING->{if (params.length == null) errors.add(ValidationError.Required("length for string type")) if (params.precision != null || params.scale != null) errors.add(ValidationError.InvalidValue("string type cannot have precision or scale"))} DataType.DECIMAL->{if (params.precision == null) errors.add(ValidationError.Required("precision for decimal type")) if (params.length != null) errors.add(ValidationError.InvalidValue("decimal type cannot have length"))} else->{if (params.length != null || params.precision != null || params.scale != null) errors.add(ValidationError.InvalidValue("type ${params.dataType} cannot have length,precision,or scale"))}} if (errors.isNotEmpty()) {return ColumnError.ValidationFailed(errors).left()} return ColumnDefinition(metadata=params.metadata,name=params.name,displayName=params.displayName,description=params.description,dataType=params.dataType,length=params.length,precision=params.precision,scale=params.scale,mandatory=params.mandatory,defaultValue=params.defaultValue).right()}}} sealed interface ColumnError {data class ValidationFailed(val errors:List<ValidationError>) :ColumnError data class NotFound(val columnName:String) :ColumnError} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/event/RelationshipEvent.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.event import org.blackerp.domain.event.DomainEvent import org.blackerp.domain.event.EventMetadata import java.util.UUID sealed interface RelationshipEvent :DomainEvent data class RelationshipCreated(override val metadata:EventMetadata,val relationshipId:UUID,val sourceTable:String,val targetTable:String) :RelationshipEvent data class RelationshipDeleted(override val metadata:EventMetadata,val relationshipId:UUID) :RelationshipEvent 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/CreateRelationshipParams.kt
-------------------------------------------
package org.blackerp.domain.table.relationship import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.TableName import org.blackerp.domain.values.ColumnName import org.blackerp.domain.table.relationship.value.RelationType import org.blackerp.domain.table.relationship.value.RelationshipName import org.blackerp.domain.table.relationship.value.DeleteRule import org.blackerp.domain.table.relationship.value.UpdateRule data class CreateRelationshipParams(val metadata:EntityMetadata,val name:RelationshipName,val sourceTable:TableName,val targetTable:TableName,val type:RelationType,val sourceColumn:ColumnName,val targetColumn:ColumnName,val deleteRule:DeleteRule=DeleteRule.RESTRICT, // Added this val updateRule:UpdateRule=UpdateRule.RESTRICT, // Added this val junctionTable:TableName?=null,val constraints:List<RelationshipConstraint>=emptyList()) 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/TableRelationship.kt
-------------------------------------------
package org.blackerp.domain.table.relationship import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.domain.DomainEntity import org.blackerp.domain.EntityMetadata import org.blackerp.domain.table.TableError import org.blackerp.domain.values.TableName import org.blackerp.domain.values.ColumnName import org.blackerp.domain.table.relationship.value.RelationType import org.blackerp.domain.table.relationship.value.RelationshipName import org.blackerp.domain.table.relationship.value.DeleteRule import org.blackerp.domain.table.relationship.value.UpdateRule import org.blackerp.shared.ValidationError data class TableRelationship(override val metadata:EntityMetadata,val name:RelationshipName,val sourceTable:TableName,val targetTable:TableName,val type:RelationType,val sourceColumn:ColumnName,val targetColumn:ColumnName,val constraints:List<RelationshipConstraint>,val deleteRule:DeleteRule=DeleteRule.RESTRICT, // Added this val updateRule:UpdateRule=UpdateRule.RESTRICT // Added this) :DomainEntity {companion object {fun create(params:CreateRelationshipParams):Either<TableError,TableRelationship> {// Basic validation first val errors=mutableListOf<ValidationError>() // Validate relationship consistency when (params.type) {RelationType.ONE_TO_ONE,RelationType.ONE_TO_MANY->{if (params.sourceTable == params.targetTable && params.sourceColumn == params.targetColumn) {errors.add(ValidationError.InvalidValue("Self-referential relationships must use different column names"))}} RelationType.MANY_TO_MANY->{// Many-to-many relationships might need additional validation // Consider junction table requirements}} if (errors.isNotEmpty()) {return TableError.ValidationFailed(errors).left()} return TableRelationship(metadata=params.metadata,name=params.name,sourceTable=params.sourceTable,targetTable=params.targetTable,type=params.type,sourceColumn=params.sourceColumn,targetColumn=params.targetColumn,constraints=params.constraints).right()}} suspend fun validate():Either<TableError,Unit> {val errors=constraints .map {it.validate(this)} .filter {it.isLeft()} .flatMap {(it as Either.Left).value.let {listOf(it)}} return if (errors.isEmpty()) {Unit.right()} else {TableError.ValidationFailed(errors).left()}}} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/RelationshipConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.relationship import arrow.core.Either import org.blackerp.domain.DomainEntity import org.blackerp.shared.ValidationError interface RelationshipConstraint :DomainEntity {suspend fun validate(relationship:TableRelationship):Either<ValidationError,Unit>} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/constraint/IndexConstraint.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.constraint import arrow.core.Either import arrow.core.right import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.ColumnName import org.blackerp.domain.table.relationship.RelationshipConstraint import org.blackerp.domain.table.relationship.TableRelationship import org.blackerp.shared.ValidationError data class IndexConstraint(override val metadata:EntityMetadata,val columns:List<ColumnName>,val unique:Boolean=false) :RelationshipConstraint {override suspend fun validate(relationship:TableRelationship):Either<ValidationError,Unit>=Unit.right()} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/RelationshipName.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.shared.ValidationError @JvmInline value class RelationshipName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,RelationshipName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Relationship name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("relationship name",3,50).left() else->RelationshipName(value).right()}}} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/RelationType.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.value enum class RelationType {ONE_TO_ONE,ONE_TO_MANY,MANY_TO_MANY;companion object {fun fromString(value:String):RelationType=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid relationship type:$value")}} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/DeleteRule.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.value enum class DeleteRule {RESTRICT,CASCADE,SET_NULL,NO_ACTION;companion object {fun fromString(value:String):DeleteRule=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid delete rule:$value")}} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/UpdateRule.kt
-------------------------------------------
package org.blackerp.domain.table.relationship.value enum class UpdateRule {RESTRICT,CASCADE,SET_NULL,NO_ACTION;companion object {fun fromString(value:String):UpdateRule=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid update rule:$value")}} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/RelationshipOperations.kt
-------------------------------------------
package org.blackerp.domain.table.relationship import arrow.core.Either import org.blackerp.domain.table.TableError import org.blackerp.domain.values.TableName import java.util.UUID interface RelationshipOperations {suspend fun save(relationship:TableRelationship):Either<TableError,TableRelationship> suspend fun findById(id:UUID):Either<TableError,TableRelationship?> suspend fun findByTable(tableName:TableName):Either<TableError,List<TableRelationship>> suspend fun delete(id:UUID):Either<TableError,Unit>} 
File: ./src/main/kotlin/org/blackerp/domain/table/relationship/TableRelationshipError.kt
-------------------------------------------
package org.blackerp.domain.table.relationship import org.blackerp.shared.ValidationError sealed interface TableRelationshipError {data class ValidationFailed(val errors:List<ValidationError>) :TableRelationshipError data class DuplicateRelationship(val name:String) :TableRelationshipError data class InvalidRelationType(val message:String) :TableRelationshipError data class CircularReference(val tableName:String) :TableRelationshipError} 
File: ./src/main/kotlin/org/blackerp/domain/DomainEvent.kt
-------------------------------------------
package org.blackerp.domain import org.blackerp.domain.values.EventMetadata interface DomainEvent {val metadata:EventMetadata} 
File: ./src/main/kotlin/org/blackerp/domain/EntityMetadata.kt
-------------------------------------------
package org.blackerp.domain import org.blackerp.shared.TimeBasedId import java.time.Instant import java.util.UUID data class EntityMetadata(val id:UUID=TimeBasedId.generate(),val created:Instant=Instant.now(),val createdBy:String,val updated:Instant=Instant.now(),val updatedBy:String,val version:Int=0,val active:Boolean=true) 
File: ./src/main/kotlin/org/blackerp/domain/security/SecurityContext.kt
-------------------------------------------
package org.blackerp.domain.security import arrow.core.Either import org.blackerp.domain.error.DomainError import java.util.UUID interface SecurityContext {suspend fun getCurrentUser():Either<DomainError,User> suspend fun hasPermission(permission:Permission):Either<DomainError,Boolean> suspend fun authenticate(credentials:Credentials):Either<DomainError,User>} data class User(val id:UUID,val username:String,val roles:Set<Role>,val tenantId:UUID?) data class Role(val id:UUID,val name:String,val permissions:Set<Permission>) data class Permission(val id:UUID,val name:String,val resource:String,val action:String) sealed interface Credentials {data class Basic(val username:String,val password:String) :Credentials data class Token(val token:String) :Credentials} 
File: ./src/main/kotlin/org/blackerp/config/WebConfig.kt
-------------------------------------------
package org.blackerp.config import org.springframework.context.annotation.Configuration import org.springframework.web.servlet.config.annotation.CorsRegistry import org.springframework.web.servlet.config.annotation.WebMvcConfigurer @Configuration class WebConfig :WebMvcConfigurer {override fun addCorsMappings(registry:CorsRegistry) {registry.addMapping("/api/**") .allowedOrigins("http://localhost:5173") // Vite default port .allowedMethods("GET","POST","PUT","DELETE","OPTIONS") .allowedHeaders("*")}} 
File: ./src/main/kotlin/org/blackerp/config/EventConfig.kt
-------------------------------------------
package org.blackerp.config import org.blackerp.infrastructure.event.DefaultEventPublisher import org.blackerp.infrastructure.event.EventPublisher import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.context.annotation.Profile @Configuration @Profile("!test") class EventConfig {@Bean fun eventPublisher():EventPublisher=DefaultEventPublisher()} 
File: ./src/main/kotlin/org/blackerp/api/mappers/TableMapper.kt
-------------------------------------------
// File:src/main/kotlin/org/blackerp/api/mappers/TableMapper.kt package org.blackerp.api.mappers import org.springframework.stereotype.Component import org.blackerp.api.dto.request.CreateTableRequest import org.blackerp.api.dto.request.CreateColumnRequest import org.blackerp.api.dto.response.TableResponse import org.blackerp.application.table.CreateTableCommand import org.blackerp.application.table.CreateColumnCommand import org.blackerp.domain.table.ADTable import org.blackerp.domain.values.AccessLevel import org.blackerp.domain.values.DataType @Component class TableMapper {fun toCommand(request:CreateTableRequest):CreateTableCommand=CreateTableCommand(name=request.name,displayName=request.displayName,description=request.description,accessLevel=AccessLevel.valueOf(request.accessLevel.uppercase()),createdBy="system",columns=request.columns.map {toColumnCommand(it)}) private fun toColumnCommand(request:CreateColumnRequest):CreateColumnCommand=CreateColumnCommand(name=request.name,displayName=request.displayName,description=request.description,dataType=DataType.valueOf(request.dataType.uppercase()),length=request.length,precision=request.precision,scale=request.scale) fun toResponse(table:ADTable):TableResponse=TableResponse(id=table.metadata.id,name=table.name.value,displayName=table.displayName.value,description=table.description?.value,accessLevel=table.accessLevel.name)}
File: ./src/main/kotlin/org/blackerp/api/dto/request/CreateTableRequest.kt
-------------------------------------------
package org.blackerp.api.dto.request import jakarta.validation.constraints.NotBlank import jakarta.validation.constraints.Pattern import jakarta.validation.constraints.Size import jakarta.validation.Valid import jakarta.validation.constraints.NotEmpty data class CreateTableRequest(@field:NotBlank @field:Pattern(regexp="^[a-z][a-z0-9_]*$") @field:Size(min=1,max=60) val name:String,@field:NotBlank @field:Size(min=1,max=60) val displayName:String,val description:String?,@field:NotBlank val accessLevel:String,@field:Valid @field:NotEmpty val columns:List<CreateColumnRequest>) data class CreateColumnRequest(@field:NotBlank @field:Pattern(regexp="^[a-z][a-z0-9_]*$") val name:String,@field:NotBlank val displayName:String,val description:String?,@field:NotBlank val dataType:String,val length:Int?,val precision:Int?,val scale:Int?) 
File: ./src/main/kotlin/org/blackerp/api/dto/response/TableResponses.kt
-------------------------------------------
package org.blackerp.api.dto.response import java.util.UUID data class TableResponse(val id:UUID,val name:String,val displayName:String,val description:String?,val accessLevel:String) data class TablesResponse(val tables:List<TableResponse>) 
File: ./src/main/kotlin/org/blackerp/api/error/ErrorHandler.kt
-------------------------------------------
package org.blackerp.api.error import org.springframework.http.ResponseEntity import org.springframework.web.bind.annotation.ControllerAdvice import org.springframework.web.bind.annotation.ExceptionHandler import org.blackerp.domain.DomainException import org.blackerp.domain.table.TableError import org.springframework.web.bind.MethodArgumentNotValidException import org.springframework.http.HttpStatus @ControllerAdvice class ErrorHandler {@ExceptionHandler(DomainException::class) fun handleDomainException(ex:DomainException):ResponseEntity<ErrorResponse>=when(ex) {is TableError.ValidationFailed->ResponseEntity.badRequest() .body(ErrorResponse("Validation failed",ex.errors.map {it.message})) is TableError.NotFound->ResponseEntity.notFound() .build() else->ResponseEntity.internalServerError() .body(ErrorResponse("Internal error",listOf(ex.message ?:ex.toString())))} @ExceptionHandler(MethodArgumentNotValidException::class) fun handleValidationExceptions(ex:MethodArgumentNotValidException):ResponseEntity<ErrorResponse>=ResponseEntity.badRequest().body(ErrorResponse(message="Validation failed",details=ex.bindingResult.fieldErrors.map {"${it.field}:${it.defaultMessage}"}))} data class ErrorResponse(val message:String,val details:List<String>) 
File: ./src/main/kotlin/org/blackerp/api/controllers/TableController.kt
-------------------------------------------
// File:src/main/kotlin/org/blackerp/api/controllers/TableController.kt package org.blackerp.api.controllers import org.springframework.web.bind.annotation.* import org.springframework.http.MediaType import jakarta.validation.Valid import org.blackerp.domain.table.TableOperations import org.blackerp.application.table.CreateTableUseCase import org.blackerp.api.mappers.TableMapper import org.blackerp.api.dto.response.TablesResponse import org.blackerp.api.dto.response.TableResponse import org.blackerp.api.dto.request.CreateTableRequest @RestController @RequestMapping("/api/tables") class TableController(private val tableOperations:TableOperations,private val createTableUseCase:CreateTableUseCase,private val tableMapper:TableMapper) {@GetMapping(produces=[MediaType.APPLICATION_JSON_VALUE]) suspend fun getTables():TablesResponse {val tables=tableOperations.findAll().getOrNull() ?:emptyList() return TablesResponse(tables=tables.map {tableMapper.toResponse(it)})} @PostMapping(consumes=[MediaType.APPLICATION_JSON_VALUE],produces=[MediaType.APPLICATION_JSON_VALUE]) suspend fun createTable(@Valid @RequestBody request:CreateTableRequest):TableResponse {val command=tableMapper.toCommand(request) val table=createTableUseCase.execute(command).getOrNull() ?:throw RuntimeException("Failed to create table") return tableMapper.toResponse(table)}}
File: ./src/main/kotlin/org/blackerp/application/table/CreateTableUseCase.kt
-------------------------------------------
// File:src/main/kotlin/org/blackerp/application/table/CreateTableUseCase.kt package org.blackerp.application.table import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.EntityMetadata import org.blackerp.domain.table.ADTable import org.blackerp.domain.table.TableError import org.blackerp.domain.table.CreateTableParams import org.blackerp.domain.table.CreateColumnParams import org.blackerp.domain.table.ColumnDefinition import org.blackerp.domain.table.TableOperations import org.blackerp.domain.values.* import org.blackerp.domain.event.DomainEvent import org.blackerp.domain.event.TableCreated import org.blackerp.domain.event.EventMetadata import org.blackerp.infrastructure.event.EventPublisher import org.blackerp.shared.ValidationError import java.time.Instant import java.util.UUID import org.springframework.stereotype.Service @Service class CreateTableUseCase(private val operations:TableOperations,private val eventPublisher:EventPublisher) {suspend fun execute(command:CreateTableCommand):Either<TableError,ADTable> {val errors=mutableListOf<ValidationError>() val name=TableName.create(command.name).fold({errors.add(it);null},{it}) val displayName=DisplayName.create(command.displayName).fold({errors.add(it);null},{it}) val description=command.description?.let {desc->Description.create(desc).fold({errors.add(it);null},{it})} // If name or displayName is null,return validation errors immediately if (name == null || displayName == null) {return TableError.ValidationFailed(errors).left()} val metadata=EntityMetadata(createdBy=command.createdBy,updatedBy=command.createdBy) val columns=command.columns.mapNotNull {columnCommand->ColumnDefinition.create(CreateColumnParams(metadata=metadata,name=ColumnName.create(columnCommand.name).getOrNull()!!,displayName=DisplayName.create(columnCommand.displayName).getOrNull()!!,description=columnCommand.description?.let {Description.create(it).getOrNull()},dataType=columnCommand.dataType,length=columnCommand.length?.let {Length.create(it).getOrNull()},precision=columnCommand.precision?.let {Precision.create(it).getOrNull()},scale=columnCommand.scale?.let {Scale.create(it).getOrNull()})).getOrNull()} if (errors.isNotEmpty()) {return TableError.ValidationFailed(errors).left()} val createResult:Either<TableError,ADTable>=ADTable.create(CreateTableParams(metadata=metadata,name=name,displayName=displayName,description=description,accessLevel=command.accessLevel,columns=columns)) return when (createResult) {is Either.Left->createResult is Either.Right->{val savedTable:Either<TableError,ADTable>=operations.save(createResult.value) when (savedTable) {is Either.Right->{val event:DomainEvent=TableCreated(metadata=EventMetadata(id=UUID.randomUUID(),timestamp=Instant.now(),user=savedTable.value.metadata.createdBy),tableId=savedTable.value.metadata.id,tableName=savedTable.value.name.value) eventPublisher.publish(event)} is Either.Left->Unit} savedTable}}}}
File: ./src/main/kotlin/org/blackerp/application/table/CreateTableCommand.kt
-------------------------------------------
package org.blackerp.application.table import org.blackerp.domain.values.AccessLevel import org.blackerp.domain.values.DataType // CreateTableCommand with added columns property data class CreateTableCommand(val name:String,val displayName:String,val description:String?,val accessLevel:AccessLevel,val createdBy:String,val columns:List<CreateColumnCommand>) data class CreateColumnCommand(val name:String,val dataType:DataType,val length:Int?,val precision:Int?,val displayName:String,val description:String?,val scale:Int?) 
File: ./src/main/kotlin/org/blackerp/shared/ValidationError.kt
-------------------------------------------
// File:src/main/kotlin/org/blackerp/shared/ValidationError.kt package org.blackerp.shared sealed class ValidationError(val message:String) {data class InvalidFormat(val details:String) :ValidationError(details) data class Required(val field:String) :ValidationError("Field $field is required") data class InvalidLength(val field:String,val min:Int,val max:Int) :ValidationError("Field $field must be between $min and $max characters") data class InvalidValue(val details:String) :ValidationError(details)} 
File: ./src/main/kotlin/org/blackerp/shared/TimeBasedId.kt
-------------------------------------------
package org.blackerp.shared import com.fasterxml.uuid.Generators import java.util.UUID object TimeBasedId {private val timeBasedGenerator=Generators.timeBasedGenerator() fun generate():UUID=timeBasedGenerator.generate()}
File: ./src/main/kotlin/org/blackerp/shared/ReferenceValidation.kt
-------------------------------------------
package org.blackerp.shared sealed interface ReferenceValidation {data class ColumnNotFound(val columnName:String) :ValidationError("Column not found:$columnName") data class ReferenceTableNotFound(val tableName:String) :ValidationError("Reference table not found:$tableName") data class ReferenceColumnNotFound(val tableName:String,val columnName:String) :ValidationError("Column $columnName not found in table $tableName") data class IncompatibleTypes(val sourceColumn:String,val sourceType:String,val targetColumn:String,val targetType:String) :ValidationError("Incompatible types:$sourceColumn ($sourceType) cannot reference $targetColumn ($targetType)")}
File: ./src/test/resources/application.yml
-------------------------------------------
spring:datasource:url:jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH username:sa password:driver-class-name:org.h2.Driver jpa:database-platform:org.hibernate.dialect.H2Dialect hibernate:ddl-auto:none show-sql:true properties:hibernate:format_sql:true flyway:enabled:false locations:classpath:db/migration baseline-on-migrate:true h2:console:enabled:true path:/h2-console logging:level:org.springframework:INFO org.blackerp:DEBUG org.hibernate.SQL:DEBUG org.hibernate.type.descriptor.sql:TRACE 
File: ./src/test/resources/application-test.yml
-------------------------------------------
spring:datasource:url:jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH username:sa password:driver-class-name:org.h2.Driver jpa:database-platform:org.hibernate.dialect.H2Dialect hibernate:ddl-auto:none show-sql:true properties:hibernate:format_sql:true flyway:enabled:false locations:classpath:db/migration baseline-on-migrate:true h2:console:enabled:true path:/h2-console logging:level:org.springframework:INFO org.blackerp:DEBUG org.hibernate.SQL:DEBUG org.hibernate.type.descriptor.sql:TRACE profiles:active:test 
File: ./src/test/resources/db/migration/V4__create_test_tables.sql
-------------------------------------------
CREATE TABLE IF NOT EXISTS ad_table (id VARCHAR(36) PRIMARY KEY,name VARCHAR(60) NOT NULL,display_name VARCHAR(60) NOT NULL,created_by VARCHAR(60) NOT NULL,created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,CONSTRAINT uk_ad_table_name UNIQUE (name));
File: ./src/test/resources/db/h2-schema.sql
-------------------------------------------
-- Drop existing tables if they exist DROP TABLE IF EXISTS ad_tab_order_by;DROP TABLE IF EXISTS ad_tab_display_column;DROP TABLE IF EXISTS ad_tab_query_column;DROP TABLE IF EXISTS ad_tab;DROP TABLE IF EXISTS ad_table_relationship;DROP TABLE IF EXISTS ad_table;-- Create ad_table with H2-compatible syntax CREATE TABLE ad_table (id UUID PRIMARY KEY,name VARCHAR(100) NOT NULL,display_name VARCHAR(100) NOT NULL,description TEXT,access_level VARCHAR(50) NOT NULL,created TIMESTAMP NOT NULL,created_by VARCHAR(100) NOT NULL,updated TIMESTAMP NOT NULL,updated_by VARCHAR(100) NOT NULL,version INTEGER NOT NULL DEFAULT 0,active BOOLEAN NOT NULL DEFAULT true,CONSTRAINT uk_table_name UNIQUE (name));-- Use REGEXP_LIKE for H2 name format check ALTER TABLE ad_table ADD CONSTRAINT chk_table_name CHECK (REGEXP_LIKE(name,'^[a-z][a-z0-9_]*$'));-- Create relationship table CREATE TABLE ad_table_relationship (id UUID PRIMARY KEY,name VARCHAR(100) NOT NULL,source_table VARCHAR(100) NOT NULL,target_table VARCHAR(100) NOT NULL,type VARCHAR(20) NOT NULL,source_column VARCHAR(100) NOT NULL,target_column VARCHAR(100) NOT NULL,delete_rule VARCHAR(20) NOT NULL,update_rule VARCHAR(20) NOT NULL,junction_table VARCHAR(100),created TIMESTAMP NOT NULL,created_by VARCHAR(100) NOT NULL,updated TIMESTAMP NOT NULL,updated_by VARCHAR(100) NOT NULL,version INTEGER NOT NULL DEFAULT 0,active BOOLEAN NOT NULL DEFAULT true,CONSTRAINT uk_relationship_name UNIQUE (name),CONSTRAINT fk_source_table FOREIGN KEY (source_table) REFERENCES ad_table(name),CONSTRAINT fk_target_table FOREIGN KEY (target_table) REFERENCES ad_table(name),CONSTRAINT fk_junction_table FOREIGN KEY (junction_table) REFERENCES ad_table(name),CONSTRAINT chk_relationship_type CHECK (type IN ('ONE_TO_ONE','ONE_TO_MANY','MANY_TO_MANY')),CONSTRAINT chk_delete_rule CHECK (delete_rule IN ('RESTRICT','CASCADE','SET_NULL','NO_ACTION')),CONSTRAINT chk_update_rule CHECK (update_rule IN ('RESTRICT','CASCADE','SET_NULL','NO_ACTION')));-- Create tab and related tables CREATE TABLE ad_tab (id UUID PRIMARY KEY,name VARCHAR(100) NOT NULL,display_name VARCHAR(100) NOT NULL,description TEXT,table_name VARCHAR(100) NOT NULL,created TIMESTAMP NOT NULL,created_by VARCHAR(100) NOT NULL,updated TIMESTAMP NOT NULL,updated_by VARCHAR(100) NOT NULL,version INTEGER NOT NULL DEFAULT 0,active BOOLEAN NOT NULL DEFAULT true,CONSTRAINT uk_tab_name UNIQUE (name),CONSTRAINT fk_tab_table FOREIGN KEY (table_name) REFERENCES ad_table(name));CREATE TABLE ad_tab_query_column (tab_id UUID NOT NULL,column_name VARCHAR(100) NOT NULL,sequence INTEGER NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE);CREATE TABLE ad_tab_display_column (tab_id UUID NOT NULL,column_name VARCHAR(100) NOT NULL,sequence INTEGER NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE);CREATE TABLE ad_tab_order_by (tab_id UUID NOT NULL,column_name VARCHAR(100) NOT NULL,direction VARCHAR(4) NOT NULL,sequence INTEGER NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE,CONSTRAINT chk_direction CHECK (direction IN ('ASC','DESC')));-- Create indexes for better performance CREATE INDEX idx_table_name ON ad_table(name);CREATE INDEX idx_table_active ON ad_table(active);CREATE INDEX idx_relationship_source ON ad_table_relationship(source_table);CREATE INDEX idx_relationship_target ON ad_table_relationship(target_table);CREATE INDEX idx_relationship_active ON ad_table_relationship(active);CREATE INDEX idx_tab_name ON ad_tab(name);CREATE INDEX idx_tab_table ON ad_tab(table_name);
File: ./src/test/resources/db/schema.sql
-------------------------------------------
-- src/test/resources/db/schema.sql -- Add after existing tables CREATE TABLE IF NOT EXISTS ad_tab (id UUID PRIMARY KEY,name VARCHAR(60) NOT NULL CONSTRAINT uk_tab_name UNIQUE,display_name VARCHAR(60) NOT NULL,description VARCHAR(255),table_name VARCHAR(60) NOT NULL,created TIMESTAMP NOT NULL,created_by VARCHAR(60) NOT NULL,updated TIMESTAMP NOT NULL,updated_by VARCHAR(60) NOT NULL,version INT NOT NULL DEFAULT 0,active BOOLEAN NOT NULL DEFAULT true,CONSTRAINT fk_tab_table FOREIGN KEY (table_name) REFERENCES ad_table(name));CREATE TABLE IF NOT EXISTS ad_tab_query_column (tab_id UUID NOT NULL,column_name VARCHAR(60) NOT NULL,sequence INT NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE);CREATE TABLE IF NOT EXISTS ad_tab_display_column (tab_id UUID NOT NULL,column_name VARCHAR(60) NOT NULL,sequence INT NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE);CREATE TABLE IF NOT EXISTS ad_tab_order_by (tab_id UUID NOT NULL,column_name VARCHAR(60) NOT NULL,direction VARCHAR(4) NOT NULL,sequence INT NOT NULL,PRIMARY KEY (tab_id,column_name),CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE,CONSTRAINT chk_direction CHECK (direction IN ('ASC','DESC')));
File: ./src/test/kotlin/org/blackerp/infrastructure/cache/InMemoryCacheServiceTest.kt
-------------------------------------------
package org.blackerp.infrastructure.cache import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import kotlinx.coroutines.test.runTest import java.time.Duration class InMemoryCacheServiceTest :DescribeSpec({lateinit var cacheService:CacheService beforeTest {cacheService=InMemoryCacheService()} describe("InMemoryCacheService") {it("should store and retrieve values") {runTest {cacheService.set("test","value") val result=cacheService.get<String>("test") result.getOrNull() shouldBe "value"}} it("should handle TTL") {runTest {cacheService.set("test","value",Duration.ofMillis(1)) Thread.sleep(10) val result=cacheService.get<String>("test") result.getOrNull() shouldBe null}}}}) 
File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/TestDatabaseConfig.kt
-------------------------------------------
// File:src/test/kotlin/org/blackerp/infrastructure/persistence/TestDatabaseConfig.kt package org.blackerp.infrastructure.persistence import org.springframework.boot.test.context.TestConfiguration import org.springframework.context.annotation.Bean import org.springframework.jdbc.core.JdbcTemplate import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType import org.springframework.context.annotation.Primary import javax.sql.DataSource @TestConfiguration class TestDatabaseConfig {@Bean @Primary fun dataSource():DataSource=EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("db/h2-schema.sql") .build() @Bean fun jdbcTemplate(dataSource:DataSource):JdbcTemplate=JdbcTemplate(dataSource)}
File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/SimpleTest.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import org.blackerp.config.TestConfig import org.springframework.jdbc.core.JdbcTemplate import java.time.Instant import java.util.UUID class SimpleTest :DescribeSpec({val jdbcTemplate=TestConfig().jdbcTemplate(TestConfig().dataSource()) beforeSpec {// Create test table if it doesn't exist jdbcTemplate.execute(""" CREATE TABLE IF NOT EXISTS ad_table (id VARCHAR(36) PRIMARY KEY,name VARCHAR(100) NOT NULL,display_name VARCHAR(100) NOT NULL,description VARCHAR(255),access_level VARCHAR(50),created TIMESTAMP NOT NULL,created_by VARCHAR(100) NOT NULL,updated TIMESTAMP,updated_by VARCHAR(100),version INTEGER DEFAULT 0,active BOOLEAN DEFAULT true) """)} afterSpec {jdbcTemplate.execute("DROP TABLE IF EXISTS ad_table")} describe("Database Operations") {it("should verify database connection") {val result=jdbcTemplate.queryForObject("SELECT 1",Int::class.java) result shouldBe 1} it("should insert into ad_table") {// given val id=UUID.randomUUID() val now=Instant.now() // when val insertCount=jdbcTemplate.update(""" INSERT INTO ad_table (id,name,display_name,created,created_by) VALUES (?,?,?,?,?) """,id,"test_table","Test Table",now,"test-user") // then insertCount shouldBe 1 val result=jdbcTemplate.queryForMap("SELECT * FROM ad_table WHERE id=?",id) result["name"] shouldBe "test_table" result["display_name"] shouldBe "Test Table"}}}) 
File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryTabOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.ad.tab.* import org.blackerp.domain.values.TableName import org.blackerp.shared.ValidationError import java.util.UUID import java.util.concurrent.ConcurrentHashMap class InMemoryTabOperations :TabOperations {private val tabs=ConcurrentHashMap<UUID,ADTab>() private val tabsByTable=ConcurrentHashMap<String,MutableSet<UUID>>() override suspend fun save(tab:ADTab):Either<TabError,ADTab>=Either.catch {// Check for duplicate name val existingTab=tabs.values.find {it.name == tab.name && it.metadata.id != tab.metadata.id} if (existingTab != null) {return TabError.DuplicateTab(tab.name.value).left()} tabs[tab.metadata.id]=tab tabsByTable.computeIfAbsent(tab.table.name.value) {mutableSetOf()} .add(tab.metadata.id) tab}.mapLeft {e->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error")))} override suspend fun findById(id:UUID):Either<TabError,ADTab?>=Either.catch {tabs[id]}.mapLeft {e->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error")))} override suspend fun findByTable(tableName:TableName):Either<TabError,List<ADTab>>=Either.catch {tabsByTable[tableName.value]?.mapNotNull {tabs[it]} ?:emptyList()}.mapLeft {e->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error")))} override suspend fun delete(id:UUID):Either<TabError,Unit>=Either.catch {tabs[id]?.let {tab->tabs.remove(id) tabsByTable[tab.table.name.value]?.remove(id) Unit} ?:throw IllegalStateException("Tab not found:$id")}.mapLeft {e->TabError.ValidationFailed(listOf(ValidationError.InvalidValue(e.message ?:"Unknown error")))}} 
File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryRelationshipOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.table.TableError import org.blackerp.domain.values.TableName import org.blackerp.domain.table.relationship.TableRelationship import org.blackerp.domain.table.relationship.RelationshipOperations import java.util.UUID import java.util.concurrent.ConcurrentHashMap class InMemoryRelationshipOperations :RelationshipOperations {private val relationships=ConcurrentHashMap<UUID,TableRelationship>() private val relationshipsByTable=ConcurrentHashMap<String,MutableSet<UUID>>() override suspend fun save(relationship:TableRelationship):Either<TableError,TableRelationship>=Either.catch {// Check for duplicate name if (relationships.values.any {it.name == relationship.name && it.metadata.id != relationship.metadata.id}) {return TableError.DuplicateTable(relationship.name.value).left()} relationships[relationship.metadata.id]=relationship // Index by source table relationshipsByTable.computeIfAbsent(relationship.sourceTable.value) {mutableSetOf()}.add(relationship.metadata.id) // Index by target table relationshipsByTable.computeIfAbsent(relationship.targetTable.value) {mutableSetOf()}.add(relationship.metadata.id) relationship}.mapLeft {TableError.StorageError(it)} override suspend fun findById(id:UUID):Either<TableError,TableRelationship?>=Either.catch {relationships[id]}.mapLeft {TableError.StorageError(it)} override suspend fun findByTable(tableName:TableName):Either<TableError,List<TableRelationship>>=Either.catch {relationshipsByTable[tableName.value]?.mapNotNull {relationships[it]} ?:emptyList()}.mapLeft {TableError.StorageError(it)} override suspend fun delete(id:UUID):Either<TableError,Unit>=Either.catch {relationships[id]?.let {relationship->relationships.remove(id) relationshipsByTable[relationship.sourceTable.value]?.remove(id) relationshipsByTable[relationship.targetTable.value]?.remove(id) Unit} ?:return TableError.NotFound(id.toString()).left()}.mapLeft {TableError.StorageError(it)}} 
File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryTableOperations.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store import arrow.core.left import arrow.core.Either import arrow.core.right import org.blackerp.domain.table.ADTable import org.blackerp.domain.table.TableError import org.blackerp.domain.table.TableOperations import java.util.UUID import java.util.concurrent.ConcurrentHashMap class InMemoryTableOperations :TableOperations {private val tables=ConcurrentHashMap<UUID,ADTable>() private val nameIndex=ConcurrentHashMap<String,UUID>() override suspend fun findAll():Either<TableError,List<ADTable>>=Either.catch {tables.values.toList()}.mapLeft {TableError.StorageError(it)} override suspend fun save(table:ADTable):Either<TableError,ADTable>=findByName(table.name.value).fold({error->error.left()},{existing->if (existing != null && existing.metadata.id != table.metadata.id) {TableError.DuplicateTable(table.name.value).left()} else {tables[table.metadata.id]=table nameIndex[table.name.value]=table.metadata.id table.right()}}) override suspend fun findById(id:UUID):Either<TableError,ADTable?>=Either.catch {tables[id]}.mapLeft {TableError.StorageError(it)} override suspend fun findByName(name:String):Either<TableError,ADTable?>=Either.catch {nameIndex[name]?.let {tables[it]}}.mapLeft {TableError.StorageError(it)} override suspend fun delete(id:UUID):Either<TableError,Unit>=Either.catch {tables[id]?.let {table->nameIndex.remove(table.name.value) tables.remove(id)} Unit}.mapLeft {TableError.StorageError(it)}} 
File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTabOperationsTest.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.store import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.matchers.shouldNotBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import kotlinx.coroutines.test.runTest import org.blackerp.domain.ad.tab.* import org.blackerp.domain.ad.tab.value.TabName import org.blackerp.domain.table.TableOperations import org.blackerp.domain.values.* import org.blackerp.shared.TestFactory import org.blackerp.config.UnifiedTestConfig import org.springframework.boot.test.context.SpringBootTest import org.springframework.test.context.ActiveProfiles import org.springframework.jdbc.core.JdbcTemplate import org.slf4j.LoggerFactory import java.util.UUID @SpringBootTest(classes=[UnifiedTestConfig::class]) @ActiveProfiles("test") class PostgresTabOperationsTest(private val jdbcTemplate:JdbcTemplate,private val tableOperations:TableOperations) :DescribeSpec({val logger=LoggerFactory.getLogger(PostgresTabOperationsTest::class.java) lateinit var tabOperations:PostgresTabOperations beforeTest {tabOperations=PostgresTabOperations(jdbcTemplate,tableOperations) // Clean up test data listOf("DELETE FROM ad_tab_query_column","DELETE FROM ad_tab_display_column","DELETE FROM ad_tab_order_by","DELETE FROM ad_tab","DELETE FROM ad_table").forEach {sql->try {jdbcTemplate.execute(sql)} catch (e:Exception) {logger.warn("Failed to execute cleanup SQL:$sql",e)}}} describe("PostgresTabOperations") {context("save") {it("should save tab with all related data") {runTest {// Create and save the table first val table=TestFactory.createTestTable() logger.debug("Created test table:${table.name.value}") val savedTableResult=tableOperations.save(table) savedTableResult.shouldBeRight() logger.debug("Saved test table successfully") // Verify the table exists val tableCount=jdbcTemplate.queryForObject("SELECT COUNT(*) FROM ad_table WHERE name=?",Int::class.java,table.name.value) tableCount shouldBe 1 logger.debug("Verified table exists in database") // Create the tab val columnName=table.columns.first().name val tab=ADTab(metadata=TestFactory.createMetadata(),name=TabName.create("test_tab").getOrNull()!!,displayName=DisplayName.create("Test Tab").getOrNull()!!,description=Description.create("Test Description").getOrNull(),table=table,queryColumns=listOf(columnName),displayColumns=listOf(columnName),orderBy=listOf(OrderBySpec(columnName,SortDirection.ASC))) logger.debug("Created test tab object") // Save the tab val saveResult=tabOperations.save(tab) logger.debug("Save result:$saveResult") saveResult.shouldBeRight().also {savedTab->logger.debug("Verifying saved tab...") savedTab.name.value shouldBe "test_tab" savedTab.queryColumns.size shouldBe 1 savedTab.queryColumns.first().value shouldBe columnName.value savedTab.displayColumns.size shouldBe 1 savedTab.displayColumns.first().value shouldBe columnName.value savedTab.orderBy.size shouldBe 1 savedTab.orderBy.first().column.value shouldBe columnName.value} // Verify in database val tabCount=jdbcTemplate.queryForObject("SELECT COUNT(*) FROM ad_tab WHERE name=?",Int::class.java,"test_tab") tabCount shouldBe 1 logger.debug("Verified tab exists in database")}}}}}) 
File: ./src/test/kotlin/org/blackerp/plugin/TestPlugin.kt
-------------------------------------------
// Classpath:src/test/kotlin/org/blackerp/plugin/TestPlugin.kt package org.blackerp.plugin import arrow.core.Either import arrow.core.right class TestPlugin(override val metadata:PluginMetadata,private val extensions:List<Extension>=emptyList()) :Plugin {var initialized=false var shutdown=false override suspend fun initialize():Either<PluginError,Unit> {initialized=true return Unit.right()} override suspend fun registerExtensions(registry:ExtensionRegistry):Either<PluginError,Unit> {extensions.forEach {extension->registry.register(extension)} return Unit.right()} override suspend fun shutdown():Either<PluginError,Unit> {shutdown=true return Unit.right()}}
File: ./src/test/kotlin/org/blackerp/plugin/discovery/FileSystemPluginDiscoveryTest.kt
-------------------------------------------
package org.blackerp.plugin.discovery import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import kotlinx.coroutines.test.runTest import java.nio.file.Files import kotlin.io.path.createTempDirectory import kotlin.io.path.writeText class FileSystemPluginDiscoveryTest :DescribeSpec({describe("FileSystemPluginDiscovery") {val discovery=FileSystemPluginDiscovery() it("should discover jar files") {runTest {val tempDir=createTempDirectory() val jarFile=tempDir.resolve("test.jar") jarFile.writeText("dummy jar content") val result=discovery.discoverPlugins(tempDir) result.isRight() shouldBe true Files.deleteIfExists(jarFile) Files.deleteIfExists(tempDir)}}}}) 
File: ./src/test/kotlin/org/blackerp/plugin/InMemoryExtensionRegistry.kt
-------------------------------------------
// Classpath:src/test/kotlin/org/blackerp/plugin/InMemoryExtensionRegistry.kt package org.blackerp.plugin import arrow.core.Either import arrow.core.right import java.util.concurrent.ConcurrentHashMap class InMemoryExtensionRegistry :ExtensionRegistry {private val extensions=ConcurrentHashMap<Class<*>,MutableList<Extension>>() override suspend fun <T :Extension> register(extension:T):Either<PluginError,Unit> {extensions.computeIfAbsent(extension::class.java) {mutableListOf()} .add(extension) return Unit.right()} @Suppress("UNCHECKED_CAST") override fun <T :Extension> getExtensions(type:Class<T>):List<T>=extensions[type]?.map {it as T} ?:emptyList()}
File: ./src/test/kotlin/org/blackerp/plugin/PluginIdTest.kt
-------------------------------------------
package org.blackerp.plugin import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import org.blackerp.shared.ValidationError class PluginIdTest :DescribeSpec({describe("PluginId") {describe("create") {it("should create valid plugin id") {val result=PluginId.create("valid-plugin") result.shouldBeRight().also {id->id.value shouldBe "valid-plugin"}} it("should reject invalid format") {val invalidFormats=listOf("Invalid Plugin", // Contains spaces "1invalid", // Starts with number "INVALID", // Contains uppercase "invalid!plugin" // Contains special characters) invalidFormats.forEach {invalid->val result=PluginId.create(invalid) result.shouldBeLeft().also {error->error shouldBe ValidationError.InvalidFormat("Plugin ID must start with lowercase letter and contain only lowercase letters,numbers,and hyphens")}}} it("should enforce length constraints") {// Too short PluginId.create("ab").shouldBeLeft().also {error->error shouldBe ValidationError.InvalidLength("plugin id",3,50)} // Too long PluginId.create("a".repeat(51)).shouldBeLeft().also {error->error shouldBe ValidationError.InvalidLength("plugin id",3,50)}}}}})
File: ./src/test/kotlin/org/blackerp/plugin/VersionTest.kt
-------------------------------------------
package org.blackerp.plugin import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import org.blackerp.shared.ValidationError class VersionTest :DescribeSpec({describe("Version") {describe("create") {it("should create valid version") {val result=Version.create("1.2.3") result.shouldBeRight().also {version->version.major shouldBe 1 version.minor shouldBe 2 version.patch shouldBe 3}} it("should reject invalid format") {val testCases=listOf("1" to "Version must be in format major.minor.patch","1.2" to "Version must be in format major.minor.patch","1.2.3.4" to "Version must be in format major.minor.patch","a.b.c" to "Version must be in format major.minor.patch","1.2.x" to "Version must be in format major.minor.patch",".1.2" to "Version must be in format major.minor.patch") testCases.forEach {(input,expectedMessage)->Version.create(input).shouldBeLeft().also {error->error shouldBe ValidationError.InvalidFormat(expectedMessage)}}}} describe("comparison") {it("should compare versions correctly") {val v1=Version.create("1.0.0").getOrNull()!! val v2=Version.create("2.0.0").getOrNull()!! val v3=Version.create("2.1.0").getOrNull()!! val v4=Version.create("2.1.1").getOrNull()!! (v1 <v2) shouldBe true (v2 <v3) shouldBe true (v3 <v4) shouldBe true (v4> v1) shouldBe true} it("should handle equal versions") {val v1=Version.create("1.0.0").getOrNull()!! val v2=Version.create("1.0.0").getOrNull()!! (v1 == v2) shouldBe true (v1>= v2) shouldBe true (v1 <= v2) shouldBe true}}}})
File: ./src/test/kotlin/org/blackerp/plugin/PluginTest.kt
-------------------------------------------
// Classpath:src/test/kotlin/org/blackerp/plugin/PluginTest.kt package org.blackerp.plugin import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import kotlinx.coroutines.test.runTest class PluginTest :DescribeSpec({describe("Plugin") {val validId=PluginId.create("test-plugin").getOrNull()!! val validVersion=Version.create("1.0.0").getOrNull()!! val validMetadata=PluginMetadata.create(id=validId,version=validVersion,name="Test Plugin",description="A test plugin",vendor="Test Vendor").getOrNull()!! lateinit var plugin:TestPlugin beforeTest {plugin=TestPlugin(validMetadata)} describe("lifecycle") {it("should handle initialization") {runTest {val result=plugin.initialize() result.isRight() shouldBe true plugin.initialized shouldBe true}} it("should handle shutdown") {runTest {val result=plugin.shutdown() result.isRight() shouldBe true plugin.shutdown shouldBe true}}} describe("extension registration") {it("should register extensions") {runTest {val registry=InMemoryExtensionRegistry() val result=plugin.registerExtensions(registry) result.isRight() shouldBe true}}}}})
File: ./src/test/kotlin/org/blackerp/plugin/PluginMetadataTest.kt
-------------------------------------------
package org.blackerp.plugin import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import org.blackerp.shared.ValidationError class PluginMetadataTest :DescribeSpec({describe("PluginMetadata") {describe("create") {val validId=PluginId.create("test-plugin").getOrNull()!! val validVersion=Version.create("1.0.0").getOrNull()!! it("should create valid metadata") {val result=PluginMetadata.create(id=validId,version=validVersion,name="Test Plugin",description="A test plugin",vendor="Test Vendor") result.shouldBeRight().also {metadata->metadata.id shouldBe validId metadata.version shouldBe validVersion metadata.name shouldBe "Test Plugin" metadata.description shouldBe "A test plugin" metadata.vendor shouldBe "Test Vendor"}} it("should validate name") {val result=PluginMetadata.create(id=validId,version=validVersion,name="",description="A test plugin",vendor="Test Vendor") result.shouldBeLeft().also {error->error shouldBe ValidationError.Required("name")}} it("should validate description length") {val result=PluginMetadata.create(id=validId,version=validVersion,name="Test Plugin",description="a".repeat(501),vendor="Test Vendor") result.shouldBeLeft().also {error->error shouldBe ValidationError.InvalidLength("description",0,500)}} it("should validate vendor") {// Empty vendor PluginMetadata.create(id=validId,version=validVersion,name="Test Plugin",description="A test plugin",vendor="").shouldBeLeft().also {error->error shouldBe ValidationError.Required("vendor")} // Too long vendor PluginMetadata.create(id=validId,version=validVersion,name="Test Plugin",description="A test plugin",vendor="a".repeat(101)).shouldBeLeft().also {error->error shouldBe ValidationError.InvalidLength("vendor",3,100)}}}}})
File: ./src/test/kotlin/org/blackerp/plugin/registry/DefaultPluginRegistryTest.kt
-------------------------------------------
package org.blackerp.plugin.registry import arrow.core.Either import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import kotlinx.coroutines.test.runTest import org.blackerp.plugin.* class DefaultPluginRegistryTest :DescribeSpec({describe("DefaultPluginRegistry") {val registry=DefaultPluginRegistry() val pluginId=PluginId.create("test-plugin").getOrNull()!! val version=Version.create("1.0.0").getOrNull()!! val metadata=PluginMetadata.create(id=pluginId,version=version,name="Test Plugin",description="Test plugin description",vendor="Test Vendor").getOrNull()!! val plugin=TestPlugin(metadata) it("should register plugin") {runTest {registry.register(plugin).isRight() shouldBe true registry.getPlugins().size shouldBe 1}} it("should prevent duplicate registration") {runTest {registry.register(plugin) registry.register(plugin).isLeft() shouldBe true}} it("should retrieve registered plugin") {runTest {registry.register(plugin) registry.getPlugin(pluginId).isRight() shouldBe true}} it("should unregister plugin") {runTest {registry.register(plugin) registry.unregister(pluginId).isRight() shouldBe true registry.getPlugins().isEmpty() shouldBe true}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/ad/window/value/WindowNameTest.kt
-------------------------------------------
package org.blackerp.domain.ad.window.value import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import org.blackerp.shared.ValidationError class WindowNameTest :DescribeSpec({describe("WindowName") {describe("create") {it("should create valid window name") {val result=WindowName.create("valid_window") result.shouldBeRight()} it("should reject invalid format") {val result=WindowName.create("Invalid Window") result.shouldBeLeft()} it("should enforce length constraints") {WindowName.create("ab").shouldBeLeft() WindowName.create("a".repeat(51)).shouldBeLeft()}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/ad/tab/value/TabNameTest.kt
-------------------------------------------
package org.blackerp.domain.ad.tab.value import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import org.blackerp.shared.ValidationError class TabNameTest :DescribeSpec({describe("TabName") {describe("create") {it("should create valid tab name") {val result=TabName.create("valid_tab") result.shouldBeRight()} it("should reject invalid format") {val result=TabName.create("Invalid Tab") result.shouldBeLeft()}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/ad/tab/ADTabTest.kt
-------------------------------------------
package org.blackerp.domain.ad.tab import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import org.blackerp.domain.values.* import org.blackerp.domain.ad.tab.value.TabName import org.blackerp.shared.TestFactory class ADTabTest :DescribeSpec({describe("ADTab") {it("should create valid tab") {// given val table=TestFactory.createTestTable() val columnName=table.columns.first().name val params=CreateTabParams(metadata=TestFactory.createMetadata(),name=TabName.create("test_tab").getOrNull()!!,displayName=DisplayName.create("Test Tab").getOrNull()!!,description=null,table=table,queryColumns=listOf(columnName),displayColumns=listOf(columnName),orderBy=listOf(OrderBySpec(columnName,SortDirection.ASC))) // when val result=ADTab.create(params) // then result.shouldBeRight()} it("should validate column existence") {// given val table=TestFactory.createTestTable() val invalidColumnName=ColumnName.create("invalid_column").getOrNull()!! val params=CreateTabParams(metadata=TestFactory.createMetadata(),name=TabName.create("test_tab").getOrNull()!!,displayName=DisplayName.create("Test Tab").getOrNull()!!,description=null,table=table,queryColumns=listOf(invalidColumnName),displayColumns=emptyList(),orderBy=emptyList()) // when val result=ADTab.create(params) // then result.shouldBeLeft()}}}) 
File: ./src/test/kotlin/org/blackerp/domain/ad/ADModuleTest.kt
-------------------------------------------
package org.blackerp.domain.ad import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import org.blackerp.domain.ad.value.ModuleName import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description import org.blackerp.plugin.Version import org.blackerp.shared.TestFactory class ADModuleTest :DescribeSpec({describe("ADModule") {describe("create") {it("should create valid module") {// Given val name=ModuleName.create("test-module").getOrNull()!! val displayName=DisplayName.create("Test Module").getOrNull()!! val description=Description.create("Test Description").getOrNull()!! val version=Version.create("1.0.0").getOrNull()!! val params=CreateModuleParams(metadata=TestFactory.createMetadata(),name=name,displayName=displayName,description=description,version=version) // When val result=ADModule.create(params) // Then result.shouldBeRight().also {module->module.name shouldBe name module.displayName shouldBe displayName module.description shouldBe description module.version shouldBe version}}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/ad/value/ModuleNameTest.kt
-------------------------------------------
package org.blackerp.domain.ad.value import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import org.blackerp.shared.ValidationError class ModuleNameTest :DescribeSpec({describe("ModuleName") {describe("create") {it("should create valid module name") {val result=ModuleName.create("valid-module") result.shouldBeRight().also {name->name.value shouldBe "valid-module"}} it("should reject invalid format") {val result=ModuleName.create("Invalid Module") result.shouldBeLeft().also {error->error.message shouldBe "Module name must start with lowercase letter and contain only lowercase letters,numbers,and hyphens"}} it("should enforce length constraints") {ModuleName.create("ab").shouldBeLeft().also {error->error shouldBe ValidationError.InvalidLength("module name",3,50)} ModuleName.create("a".repeat(51)).shouldBeLeft().also {error->error shouldBe ValidationError.InvalidLength("module name",3,50)}}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/ad/reference/ADReferenceTest.kt
-------------------------------------------
package org.blackerp.domain.ad.reference import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.matchers.types.shouldBeTypeOf import io.kotest.assertions.arrow.core.shouldBeRight import org.blackerp.domain.ad.reference.value.ReferenceName import org.blackerp.domain.values.DisplayName import org.blackerp.domain.values.Description import org.blackerp.shared.TestFactory class ADReferenceTest :DescribeSpec({describe("ADReference") {it("should create list reference") {// given val name=ReferenceName.create("test_reference").getOrNull()!! val displayName=DisplayName.create("Test Reference").getOrNull()!! val description=Description.create("Test reference description").getOrNull() val params=CreateReferenceParams(metadata=TestFactory.createMetadata(),name=name,displayName=displayName,description=description,type=ReferenceType.List) // when val result=ADReference.create(params) // then result.shouldBeRight().also {reference->reference.name shouldBe name reference.displayName shouldBe displayName reference.description shouldBe description reference.type shouldBe ReferenceType.List}} it("should create table reference") {// given val name=ReferenceName.create("table_reference").getOrNull()!! val displayName=DisplayName.create("Table Reference").getOrNull()!! val params=CreateReferenceParams(metadata=TestFactory.createMetadata(),name=name,displayName=displayName,description=null,type=ReferenceType.Table(tableName="test_table",keyColumn="id",displayColumn="name")) // when val result=ADReference.create(params) // then result.shouldBeRight().also {reference->val tableRef=reference.type as ReferenceType.Table tableRef.tableName shouldBe "test_table" tableRef.keyColumn shouldBe "id" tableRef.displayColumn shouldBe "name"}}}})
File: ./src/test/kotlin/org/blackerp/domain/ad/reference/value/ReferenceNameTest.kt
-------------------------------------------
package org.blackerp.domain.ad.reference.value import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import org.blackerp.shared.ValidationError class ReferenceNameTest :DescribeSpec({describe("ReferenceName") {describe("create") {it("should create valid reference name") {val result=ReferenceName.create("valid_reference") result.shouldBeRight()} it("should reject invalid format") {val result=ReferenceName.create("Invalid Reference") result.shouldBeLeft()} it("should enforce length constraints") {ReferenceName.create("ab").shouldBeLeft() ReferenceName.create("a".repeat(51)).shouldBeLeft()}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/error/DomainErrorTest.kt
-------------------------------------------
package org.blackerp.domain.error import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.matchers.types.shouldBeTypeOf class DomainErrorTest :DescribeSpec({describe("DomainError") {it("should create validation error") {val error=DomainError.ValidationError("Invalid input","field1") error.shouldBeTypeOf<DomainError.ValidationError>() error.message shouldBe "Invalid input" error.field shouldBe "field1"} it("should create security error") {val error=DomainError.SecurityError(message="Access denied",reason="Insufficient permissions") error.shouldBeTypeOf<DomainError.SecurityError>() error.message shouldBe "Access denied" error.reason shouldBe "Insufficient permissions"} it("should create system error with cause") {val cause=RuntimeException("Test exception") val error=DomainError.SystemError("System failure",cause) error.shouldBeTypeOf<DomainError.SystemError>() error.message shouldBe "System failure" error.cause shouldBe cause}}}) 
File: ./src/test/kotlin/org/blackerp/domain/tenant/TenantAwareTableTest.kt
-------------------------------------------
package org.blackerp.domain.tenant import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import org.blackerp.shared.TestFactory import org.blackerp.domain.table.TenantAwareTable import java.util.UUID class TenantAwareTableTest :DescribeSpec({describe("TenantAwareTable") {it("should wrap ADTable with tenant ID") {// given val table=TestFactory.createTestTable() val tenantId=UUID.randomUUID() // when val tenantAwareTable=TenantAwareTable.from(table,tenantId) // then tenantAwareTable.tenantId shouldBe tenantId tenantAwareTable.metadata shouldBe table.metadata tenantAwareTable.name.value shouldBe table.name.value tenantAwareTable.displayName.value shouldBe table.displayName.value}}}) 
File: ./src/test/kotlin/org/blackerp/domain/tenant/TenantContextTest.kt
-------------------------------------------
package org.blackerp.domain.tenant import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import java.util.UUID class TenantContextTest :DescribeSpec({afterTest {TenantContext.clear()} describe("TenantContext") {it("should manage current tenant") {// given val tenantId=UUID.randomUUID() // when TenantContext.setCurrentTenant(tenantId) // then TenantContext.getCurrentTenant() shouldBe tenantId} it("should clear tenant context") {// given val tenantId=UUID.randomUUID() TenantContext.setCurrentTenant(tenantId) // when TenantContext.clear() // then TenantContext.getCurrentTenant() shouldBe null}}}) 
File: ./src/test/kotlin/org/blackerp/domain/values/AmountTest.kt
-------------------------------------------
package org.blackerp.domain.values import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import java.math.BigDecimal class AmountTest :DescribeSpec({describe("Amount") {describe("create") {it("should create valid amount") {val result=Amount.create(BigDecimal("100.00")) result.shouldBeRight()} it("should reject negative amount") {val result=Amount.create(BigDecimal("-100.00")) result.shouldBeLeft()}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/values/DisplayNameTest.kt
-------------------------------------------
package org.blackerp.domain.values import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import arrow.core.Either class DisplayNameTest :DescribeSpec({describe("DisplayName") {describe("create") {it("should create valid display name") {val result=DisplayName.create("Valid Display Name") result.isRight() shouldBe true} it("should reject blank name") {val result=DisplayName.create(" ") result.isLeft() shouldBe true} it("should reject too long name") {val result=DisplayName.create("a".repeat(61)) result.isLeft() shouldBe true}}}})
File: ./src/test/kotlin/org/blackerp/domain/values/TableNameTest.kt
-------------------------------------------
package org.blackerp.domain.values import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import arrow.core.Either class TableNameTest :DescribeSpec({describe("TableName") {describe("create") {it("should create valid table name") {val result=TableName.create("valid_table_name") result.isRight() shouldBe true} it("should reject invalid format") {val result=TableName.create("Invalid Table") result.isLeft() shouldBe true} it("should reject name starting with number") {val result=TableName.create("1invalid") result.isLeft() shouldBe true}}}})
File: ./src/test/kotlin/org/blackerp/domain/values/CurrencyTest.kt
-------------------------------------------
package org.blackerp.domain.values import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft class CurrencyTest :DescribeSpec({describe("Currency") {describe("create") {it("should create valid currency code") {val result=Currency.create("USD") result.shouldBeRight()} it("should reject invalid format") {val result=Currency.create("usd") result.shouldBeLeft()}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/values/DataTypeTest.kt
-------------------------------------------
package org.blackerp.domain.values import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.throwables.shouldThrow class DataTypeTest :DescribeSpec({describe("DataType") {describe("fromString") {it("should create valid data type from string") {DataType.fromString("STRING") shouldBe DataType.STRING DataType.fromString("string") shouldBe DataType.STRING} it("should throw exception for invalid type") {shouldThrow<IllegalArgumentException> {DataType.fromString("INVALID_TYPE")}}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/transaction/TransactionTest.kt
-------------------------------------------
package org.blackerp.domain.transaction import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import org.blackerp.domain.values.Amount import org.blackerp.domain.values.Currency import org.blackerp.shared.TestFactory import java.math.BigDecimal import java.time.Instant class TransactionTest :DescribeSpec({describe("Transaction") {describe("create") {it("should create valid transaction") {val amount=Amount.create(BigDecimal("100.00")).getOrNull()!! val currency=Currency.create("USD").getOrNull()!! val params=CreateTransactionParams(metadata=TestFactory.createMetadata(),amount=amount,currency=currency,timestamp=Instant.now(),description="Test transaction") val result=Transaction.create(params) result.shouldBeRight()}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/query/QueryCriteriaTest.kt
-------------------------------------------
package org.blackerp.domain.query import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.should import io.kotest.matchers.types.beInstanceOf class QueryCriteriaTest :DescribeSpec({describe("QueryCriteria") {it("should create complex criteria") {val criteria=QueryCriteria.And(listOf(QueryCriteria.Equals("name","test"),QueryCriteria.Or(listOf(QueryCriteria.Like("description","%test%"),QueryCriteria.In("status",listOf("active","pending")))))) criteria should beInstanceOf<QueryCriteria.And>()}}}) 
File: ./src/test/kotlin/org/blackerp/domain/table/extension/TableExtensionPointTest.kt
-------------------------------------------
package org.blackerp.domain.table.extension import arrow.core.Either import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.mockk.mockk import kotlinx.coroutines.test.runTest import org.blackerp.domain.table.ADTable import org.blackerp.plugin.PluginId class TableExtensionPointTest :DescribeSpec({describe("TableExtension") {val mockTable=mockk<ADTable>() val mockPluginId=PluginId.create("test-plugin").getOrNull()!! it("should implement extension interface") {val extension=object :TableExtension {override val pluginId=mockPluginId override suspend fun beforeCreate(table:ADTable)=Either.Right(table) override suspend fun afterCreate(table:ADTable) {} override suspend fun beforeUpdate(table:ADTable)=Either.Right(table) override suspend fun afterUpdate(table:ADTable) {} override suspend fun beforeDelete(table:ADTable)=Either.Right(Unit) override suspend fun afterDelete(table:ADTable) {}} runTest {extension.beforeCreate(mockTable).isRight() shouldBe true}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/table/constraint/ReferenceConstraintTest.kt
-------------------------------------------
package org.blackerp.domain.table.constraint import arrow.core.right import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.matchers.types.shouldBeTypeOf import io.mockk.coEvery import io.mockk.every import io.mockk.mockk import kotlinx.coroutines.test.runTest import org.blackerp.domain.table.* import org.blackerp.domain.table.definition.TableDefinition import org.blackerp.domain.values.* import org.blackerp.shared.TestFactory import org.blackerp.shared.ReferenceValidation class ReferenceConstraintTest :DescribeSpec({describe("validate") {it("should fail when source column does not exist") {runTest {// given val mockTableOps=mockk<TableOperations>() val sourceTableDef=mockk<TableDefinition>() val columnName=ColumnName.create("test_column").getOrNull()!! val refTableName=TableName.create("ref_table").getOrNull()!! val refColumnName=ColumnName.create("ref_column").getOrNull()!! every {sourceTableDef.columns} returns emptyList() val constraint=ReferenceConstraint(metadata=TestFactory.createMetadata(),column=columnName,referenceTable=refTableName,referenceColumn=refColumnName,tableOperations=mockTableOps) // when val result=constraint.validate(sourceTableDef) // then result.isLeft() shouldBe true result.fold({error->error.shouldBeTypeOf<ReferenceValidation.ColumnNotFound>()},{throw AssertionError("Should not succeed")})}} it("should fail when reference table not found") {runTest {// given val mockTableOps=mockk<TableOperations>() val sourceTableDef=mockk<TableDefinition>() val columnName=ColumnName.create("test_column").getOrNull()!! val refTableName=TableName.create("ref_table").getOrNull()!! val refColumnName=ColumnName.create("ref_column").getOrNull()!! // Set up source column to exist val sourceColumn=mockk<ColumnDefinition>() every {sourceColumn.name} returns columnName every {sourceColumn.dataType} returns DataType.STRING every {sourceTableDef.columns} returns listOf(sourceColumn) // Set up reference table to not be found coEvery {mockTableOps.findByName(refTableName.value)} returns null.right() val constraint=ReferenceConstraint(metadata=TestFactory.createMetadata(),column=columnName,referenceTable=refTableName,referenceColumn=refColumnName,tableOperations=mockTableOps) // when val result=constraint.validate(sourceTableDef) // then result.isLeft() shouldBe true result.fold({error->error.shouldBeTypeOf<ReferenceValidation.ReferenceTableNotFound>()},{throw AssertionError("Should not succeed")})}} it("should fail when column types are incompatible") {runTest {// given val mockTableOps=mockk<TableOperations>() val sourceTableDef=mockk<TableDefinition>() val columnName=ColumnName.create("test_column").getOrNull()!! val refTableName=TableName.create("ref_table").getOrNull()!! val refColumnName=ColumnName.create("ref_column").getOrNull()!! // Source column with STRING type val sourceColumn=mockk<ColumnDefinition>() every {sourceColumn.name} returns columnName every {sourceColumn.dataType} returns DataType.STRING every {sourceTableDef.columns} returns listOf(sourceColumn) // Reference table setup val refTable=mockk<ADTable>() val refColumn=mockk<ColumnDefinition>() every {refColumn.name} returns refColumnName every {refColumn.dataType} returns DataType.INTEGER // Intentionally incompatible type every {refTable.columns} returns listOf(refColumn) every {refTable.metadata} returns TestFactory.createMetadata() every {refTable.name} returns refTableName every {refTable.displayName} returns DisplayName.create("Reference Table").getOrNull()!! every {refTable.description} returns null every {refTable.accessLevel} returns AccessLevel.SYSTEM // Set up TableOperations to return our mock table coEvery {mockTableOps.findByName(refTableName.value)} returns refTable.right() val constraint=ReferenceConstraint(metadata=TestFactory.createMetadata(),column=columnName,referenceTable=refTableName,referenceColumn=refColumnName,tableOperations=mockTableOps) // when val result=constraint.validate(sourceTableDef) // then result.isLeft() shouldBe true result.fold({error->error.shouldBeTypeOf<ReferenceValidation.IncompatibleTypes>()},{throw AssertionError("Should not succeed")})}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/table/constraint/UniqueConstraintTest.kt
-------------------------------------------
package org.blackerp.domain.table.constraint import arrow.core.right import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.mockk.every import io.mockk.mockk import org.blackerp.domain.EntityMetadata import org.blackerp.domain.table.ColumnDefinition import org.blackerp.domain.table.definition.TableDefinition import org.blackerp.domain.values.ColumnName import org.blackerp.shared.TestFactory import java.time.Instant // Required by EntityMetadata import java.util.UUID // Required by EntityMetadata class UniqueConstraintTest :DescribeSpec({describe("UniqueConstraint") {it("should validate when all columns exist") {// given val columnName=ColumnName.create("test_column").getOrNull()!! val mockColumn=mockk<ColumnDefinition>() every {mockColumn.name} returns columnName val mockTable=mockk<TableDefinition>() every {mockTable.columns} returns listOf(mockColumn) val constraint=UniqueConstraint(metadata=TestFactory.createMetadata(),columns=listOf(columnName)) // when val result=constraint.validate(mockTable) // then result.isRight() shouldBe true} it("should fail when columns dont exist") {// given val columnName=ColumnName.create("test_column").getOrNull()!! val mockTable=mockk<TableDefinition>() every {mockTable.columns} returns emptyList() val constraint=UniqueConstraint(metadata=TestFactory.createMetadata(),columns=listOf(columnName)) // when val result=constraint.validate(mockTable) // then result.isLeft() shouldBe true}}}) 
File: ./src/test/kotlin/org/blackerp/domain/table/constraint/NotNullConstraintTest.kt
-------------------------------------------
package org.blackerp.domain.table.constraint import arrow.core.right import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.mockk.every import io.mockk.mockk import org.blackerp.domain.EntityMetadata import org.blackerp.domain.table.ColumnDefinition import org.blackerp.domain.table.definition.TableDefinition import org.blackerp.domain.values.ColumnName import org.blackerp.shared.TestFactory import java.time.Instant // Required by EntityMetadata import java.util.UUID // Required by EntityMetadata class NotNullConstraintTest :DescribeSpec({describe("NotNullConstraint") {it("should validate when column exists") {// given val columnName=ColumnName.create("test_column").getOrNull()!! val mockColumn=mockk<ColumnDefinition>() every {mockColumn.name} returns columnName val mockTable=mockk<TableDefinition>() every {mockTable.columns} returns listOf(mockColumn) val constraint=NotNullConstraint(metadata=TestFactory.createMetadata(),column=columnName) // when val result=constraint.validate(mockTable) // then result.isRight() shouldBe true} it("should fail when column doesnt exist") {// given val columnName=ColumnName.create("test_column").getOrNull()!! val mockTable=mockk<TableDefinition>() every {mockTable.columns} returns emptyList() val constraint=NotNullConstraint(metadata=TestFactory.createMetadata(),column=columnName) // when val result=constraint.validate(mockTable) // then result.isLeft() shouldBe true}}}) 
File: ./src/test/kotlin/org/blackerp/domain/table/definition/TableDefinitionTest.kt
-------------------------------------------
package org.blackerp.domain.table.definition import arrow.core.right import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.mockk.mockk import io.mockk.every import org.blackerp.domain.table.ColumnDefinition import org.blackerp.domain.values.* import org.blackerp.shared.TestFactory import java.time.Instant import java.util.UUID class TableDefinitionTest :DescribeSpec({describe("TableDefinition") {describe("create") {it("should create valid table definition") {// given val columnName=ColumnName.create("test_column").getOrNull()!! val mockColumn=mockk<ColumnDefinition> {// Configure the mock to return values when accessed every {name} returns columnName every {metadata} returns TestFactory.createMetadata() // Add any other necessary properties that might be accessed} val params=CreateTableParams(metadata=TestFactory.createMetadata(),name=TestFactory.createValidTableName(),displayName=TestFactory.createValidDisplayName(),description=null,accessLevel=AccessLevel.SYSTEM,columns=listOf(mockColumn)) // when val result=TableDefinition.create(params) // then result.isRight() shouldBe true result.map {table->table.columns.size shouldBe 1 table.columns.first().name shouldBe columnName}} it("should fail with no columns") {// given val params=CreateTableParams(metadata=TestFactory.createMetadata(),name=TestFactory.createValidTableName(),displayName=TestFactory.createValidDisplayName(),description=null,accessLevel=AccessLevel.SYSTEM,columns=emptyList()) // when val result=TableDefinition.create(params) // then result.isLeft() shouldBe true}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/table/TableOperationsTest.kt
-------------------------------------------
// File:src/test/kotlin/org/blackerp/domain/table/TableOperationsTest.kt package org.blackerp.domain.table import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import kotlinx.coroutines.test.runTest import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.* import org.blackerp.shared.TestFactory import org.blackerp.infrastructure.persistence.store.InMemoryTableOperations class TableOperationsTest :DescribeSpec({lateinit var operations:InMemoryTableOperations beforeTest {operations=InMemoryTableOperations()} describe("TableOperations") {context("saving and retrieving tables") {it("should save and retrieve table") {runTest {// Create test table val table=TestFactory.createTestTable() // Save table val savedResult=operations.save(table) savedResult.isRight() shouldBe true // Retrieve table val retrievedResult=operations.findById(table.metadata.id) retrievedResult.isRight() shouldBe true val retrievedTable=retrievedResult.getOrNull()!! retrievedTable.name.value shouldBe table.name.value retrievedTable.displayName.value shouldBe table.displayName.value retrievedTable.description?.value shouldBe table.description?.value}}} context("finding by name") {it("should find table by name") {runTest {// Create and save test table val table=TestFactory.createTestTable() operations.save(table) // Find by name val foundResult=operations.findByName(table.name.value) foundResult.isRight() shouldBe true val foundTable=foundResult.getOrNull()!! foundTable.metadata.id shouldBe table.metadata.id}}}}})
File: ./src/test/kotlin/org/blackerp/domain/table/relationship/TableRelationshipTest.kt
-------------------------------------------
package org.blackerp.domain.table.relationship import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import org.blackerp.domain.values.TableName import org.blackerp.domain.values.ColumnName import org.blackerp.domain.table.relationship.value.RelationType import org.blackerp.domain.table.relationship.value.RelationshipName import org.blackerp.shared.TestFactory class TableRelationshipTest :DescribeSpec({describe("TableRelationship") {context("creation") {it("should create valid relationship") {// Create test parameters val params=CreateRelationshipParams(metadata=TestFactory.createMetadata(),name=RelationshipName.create("test_relation").getOrNull()!!,sourceTable=TableName.create("source_table").getOrNull()!!,targetTable=TableName.create("target_table").getOrNull()!!,type=RelationType.ONE_TO_MANY,sourceColumn=ColumnName.create("source_id").getOrNull()!!,targetColumn=ColumnName.create("target_id").getOrNull()!!) // Create relationship val result=TableRelationship.create(params) // Verify result.isRight() shouldBe true result.map {relationship->relationship.name.value shouldBe "test_relation" relationship.type shouldBe RelationType.ONE_TO_MANY}}}}}) 
File: ./src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipOperationsTest.kt
-------------------------------------------
package org.blackerp.domain.table.relationship import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.matchers.shouldNotBe import io.kotest.matchers.collections.shouldNotBeEmpty import io.kotest.matchers.types.shouldBeTypeOf import io.kotest.assertions.arrow.core.shouldBeRight import io.kotest.assertions.arrow.core.shouldBeLeft import kotlinx.coroutines.test.runTest import org.blackerp.domain.table.TableError import org.blackerp.infrastructure.persistence.store.InMemoryRelationshipOperations import org.slf4j.LoggerFactory class RelationshipOperationsTest :DescribeSpec({val logger=LoggerFactory.getLogger(RelationshipOperationsTest::class.java) lateinit var operations:RelationshipOperations beforeTest {operations=InMemoryRelationshipOperations()} describe("RelationshipOperations") {it("should save and retrieve relationship") {runTest {val relationship=RelationshipTestFactory.createValidRelationship() logger.debug("Created test relationship:${relationship.name.value}") val saveResult=operations.save(relationship) val findResult=operations.findById(relationship.metadata.id) saveResult.shouldBeRight().also {saved->saved.metadata.id shouldBe relationship.metadata.id saved.name shouldBe relationship.name} findResult.shouldBeRight().also {found->found shouldNotBe null found?.metadata?.id shouldBe relationship.metadata.id found?.name shouldBe relationship.name}}} it("should find relationships by table") {runTest {val relationship=RelationshipTestFactory.createValidRelationship() operations.save(relationship).shouldBeRight() val result=operations.findByTable(relationship.sourceTable) result.shouldBeRight().also {relationships->relationships.shouldNotBeEmpty() relationships.size shouldBe 1 val foundRelationship=relationships[0] foundRelationship.shouldBeTypeOf<TableRelationship>() foundRelationship.sourceTable.value shouldBe relationship.sourceTable.value foundRelationship.metadata.id shouldBe relationship.metadata.id}}} it("should prevent duplicate relationship names") {runTest {val first=RelationshipTestFactory.createValidRelationship() val second=RelationshipTestFactory.createValidRelationship() operations.save(first).shouldBeRight() operations.save(second).shouldBeLeft().also {error->error shouldBe TableError.DuplicateTable(second.name.value)}}} it("should delete relationship") {runTest {val relationship=RelationshipTestFactory.createValidRelationship() operations.save(relationship).shouldBeRight() operations.delete(relationship.metadata.id).shouldBeRight() operations.findById(relationship.metadata.id).shouldBeRight() shouldBe null}}}})
File: ./src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipTestFactory.kt
-------------------------------------------
// File:src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipTestFactory.kt package org.blackerp.domain.table.relationship import org.blackerp.domain.EntityMetadata import org.blackerp.domain.values.TableName import org.blackerp.domain.values.ColumnName import org.blackerp.domain.table.relationship.value.* import org.blackerp.domain.table.relationship.constraint.IndexConstraint import org.blackerp.shared.TestFactory import org.blackerp.domain.table.relationship.value.DeleteRule import org.blackerp.domain.table.relationship.value.UpdateRule object RelationshipTestFactory {fun createValidRelationship():TableRelationship {val metadata=TestFactory.createMetadata() return TableRelationship(metadata=metadata,name=createValidRelationshipName(),sourceTable=createValidTableName("source_table"),targetTable=createValidTableName("target_table"),type=RelationType.ONE_TO_MANY,sourceColumn=createValidColumnName("source_id"),targetColumn=createValidColumnName("target_id"),constraints=listOf(createValidIndexConstraint("target_id")),deleteRule=DeleteRule.RESTRICT,updateRule=UpdateRule.RESTRICT)} fun createValidRelationshipParams():CreateRelationshipParams {return CreateRelationshipParams(metadata=TestFactory.createMetadata(),name=createValidRelationshipName(),sourceTable=createValidTableName("source_table"),targetTable=createValidTableName("target_table"),type=RelationType.ONE_TO_MANY,sourceColumn=createValidColumnName("source_id"),targetColumn=createValidColumnName("target_id"),constraints=listOf(createValidIndexConstraint("target_id")),deleteRule=DeleteRule.RESTRICT,updateRule=UpdateRule.RESTRICT)} private fun createValidRelationshipName():RelationshipName=RelationshipName.create("test_relation").getOrNull() ?:throw IllegalStateException("Failed to create valid relationship name") private fun createValidTableName(name:String):TableName=TableName.create(name).getOrNull() ?:throw IllegalStateException("Failed to create valid table name:$name") private fun createValidColumnName(name:String):ColumnName=ColumnName.create(name).getOrNull() ?:throw IllegalStateException("Failed to create valid column name:$name") private fun createValidIndexConstraint(columnName:String):IndexConstraint {val column=createValidColumnName(columnName) return IndexConstraint(metadata=TestFactory.createMetadata(),columns=listOf(column))} fun createManyToManyParams():CreateRelationshipParams {return CreateRelationshipParams(metadata=TestFactory.createMetadata(),name=createValidRelationshipName(),sourceTable=createValidTableName("table_a"),targetTable=createValidTableName("table_b"),type=RelationType.MANY_TO_MANY,sourceColumn=createValidColumnName("a_id"),targetColumn=createValidColumnName("b_id"),junctionTable=createValidTableName("junction_table"))} fun createSelfReferenceParams():CreateRelationshipParams {val tableName=createValidTableName("self_ref_table") return CreateRelationshipParams(metadata=TestFactory.createMetadata(),name=createValidRelationshipName(),sourceTable=tableName,targetTable=tableName,type=RelationType.ONE_TO_MANY,sourceColumn=createValidColumnName("parent_id"),targetColumn=createValidColumnName("child_id"),constraints=listOf(createValidIndexConstraint("child_id")))}}
File: ./src/test/kotlin/org/blackerp/domain/EntityMetadataTest.kt
-------------------------------------------
package org.blackerp.domain import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.matchers.shouldNotBe class EntityMetadataTest :DescribeSpec({describe("EntityMetadata") {it("should create with default values") {val metadata=EntityMetadata(createdBy="test-user",updatedBy="test-user") metadata.createdBy shouldBe "test-user" metadata.updatedBy shouldBe "test-user" metadata.version shouldBe 0 metadata.active shouldBe true metadata.id shouldNotBe null} it("should create with custom values") {val metadata=EntityMetadata(createdBy="test-user",updatedBy="test-user",version=1,active=false) metadata.version shouldBe 1 metadata.active shouldBe false}}}) 
File: ./src/test/kotlin/org/blackerp/config/UnifiedTestConfig.kt
-------------------------------------------
package org.blackerp.config import org.springframework.boot.test.context.TestConfiguration import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Primary import org.springframework.jdbc.core.JdbcTemplate import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType import javax.sql.DataSource import org.blackerp.application.table.CreateTableUseCase import org.blackerp.domain.table.TableOperations import org.blackerp.infrastructure.event.EventPublisher import org.blackerp.infrastructure.persistence.store.* import org.springframework.boot.test.web.client.TestRestTemplate import io.mockk.mockk import org.springframework.boot.autoconfigure.flyway.FlywayMigrationStrategy @TestConfiguration class UnifiedTestConfig {@Bean @Primary fun dataSource():DataSource {return EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("db/h2-schema.sql") .build()} @Bean fun jdbcTemplate(dataSource:DataSource):JdbcTemplate=JdbcTemplate(dataSource) @Bean fun testRestTemplate():TestRestTemplate=TestRestTemplate() @Bean fun eventPublisher():EventPublisher=mockk(relaxed=true) @Bean @Primary fun tableOperations(jdbcTemplate:JdbcTemplate):TableOperations=PostgresTableOperations(jdbcTemplate) @Bean fun postgresTabOperations(jdbcTemplate:JdbcTemplate,tableOperations:TableOperations):PostgresTabOperations=PostgresTabOperations(jdbcTemplate,tableOperations) @Bean fun createTableUseCase(tableOperations:TableOperations,eventPublisher:EventPublisher):CreateTableUseCase=CreateTableUseCase(tableOperations,eventPublisher) @Bean fun flywayMigrationStrategy():FlywayMigrationStrategy=FlywayMigrationStrategy {_->/* disable automatic migrations */}}
File: ./src/test/kotlin/org/blackerp/config/TestConfig.kt
-------------------------------------------
// File:src/test/kotlin/org/blackerp/config/TestConfig.kt package org.blackerp.config import org.springframework.boot.test.context.TestConfiguration import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Primary import org.springframework.jdbc.core.JdbcTemplate import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType import javax.sql.DataSource import com.fasterxml.jackson.databind.ObjectMapper import org.blackerp.application.table.CreateTableUseCase import org.blackerp.api.mappers.TableMapper import org.blackerp.infrastructure.event.EventPublisher import org.blackerp.infrastructure.persistence.store.InMemoryTableOperations import io.mockk.mockk @TestConfiguration class TestConfig {@Bean @Primary fun dataSource():DataSource=EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .build() @Bean fun jdbcTemplate(dataSource:DataSource):JdbcTemplate=JdbcTemplate(dataSource) @Bean fun objectMapper():ObjectMapper=ObjectMapper() @Bean fun tableMapper():TableMapper=TableMapper() @Bean fun eventPublisher():EventPublisher=mockk(relaxed=true) @Bean fun tableOperations():InMemoryTableOperations=mockk<InMemoryTableOperations>(relaxed=true) @Bean fun createTableUseCase(tableOperations:InMemoryTableOperations,eventPublisher:EventPublisher):CreateTableUseCase=CreateTableUseCase(operations=tableOperations,eventPublisher=eventPublisher)}
File: ./src/test/kotlin/org/blackerp/config/KotestProjectConfig.kt
-------------------------------------------
// File:src/test/kotlin/org/blackerp/config/KotestProjectConfig.kt package org.blackerp.config import io.kotest.core.config.AbstractProjectConfig import io.kotest.core.spec.IsolationMode import io.kotest.extensions.spring.SpringExtension class KotestProjectConfig :AbstractProjectConfig() {override val isolationMode=IsolationMode.InstancePerLeaf override fun extensions()=listOf(SpringExtension)}
File: ./src/test/kotlin/org/blackerp/config/TestEventConfig.kt
-------------------------------------------
package org.blackerp.config import org.springframework.test.context.ActiveProfiles import io.mockk.mockk import org.blackerp.infrastructure.event.EventPublisher import org.springframework.boot.test.context.TestConfiguration import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Primary @ActiveProfiles("test") class TestEventConfig {@Bean @Primary fun testEventPublisher():EventPublisher=mockk(relaxed=true)} 
File: ./src/test/kotlin/org/blackerp/api/controllers/TableControllerTest.kt
-------------------------------------------
// File:src/test/kotlin/org/blackerp/api/controllers/TableControllerTest.kt package org.blackerp.api.controllers import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc import org.springframework.test.web.servlet.MockMvc import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status import org.springframework.http.MediaType import org.springframework.beans.factory.annotation.Autowired import io.kotest.core.spec.style.DescribeSpec import io.mockk.coEvery import kotlinx.coroutines.test.runTest import arrow.core.right import org.blackerp.shared.TestFactory import com.fasterxml.jackson.databind.ObjectMapper import com.ninjasquad.springmockk.MockkBean import org.blackerp.domain.table.TableOperations import org.blackerp.application.table.CreateTableUseCase import org.blackerp.api.mappers.TableMapper @WebMvcTest(TableController::class) @AutoConfigureMockMvc(addFilters=false) class TableControllerTest(@Autowired private val mockMvc:MockMvc,@Autowired private val objectMapper:ObjectMapper,@MockkBean private val tableOperations:TableOperations,@MockkBean private val createTableUseCase:CreateTableUseCase,@MockkBean private val tableMapper:TableMapper) :DescribeSpec({describe("POST /api/tables") {it("should create table successfully") {runTest {val request=TestFactory.createTableRequest() val command=TestFactory.createTableCommand() val table=TestFactory.createTestTable() val response=TestFactory.createTableResponse() coEvery {tableMapper.toCommand(request)} returns command coEvery {createTableUseCase.execute(command)} returns table.right() coEvery {tableMapper.toResponse(table)} returns response mockMvc.perform(post("/api/tables") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(request))) .andExpect(status().isOk)}}}})
File: ./src/test/kotlin/org/blackerp/application/table/CreateTableUseCaseTest.kt
-------------------------------------------
package org.blackerp.application.table import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.matchers.types.shouldBeTypeOf import io.mockk.coEvery import io.mockk.mockk import io.mockk.slot import arrow.core.Either import arrow.core.right import kotlinx.coroutines.test.runTest import org.blackerp.domain.values.AccessLevel import org.blackerp.domain.table.ADTable import org.blackerp.domain.values.DataType import org.blackerp.domain.table.TableError import org.blackerp.domain.table.TableOperations import org.blackerp.infrastructure.event.EventPublisher class CreateTableUseCaseTest :DescribeSpec({lateinit var operations:TableOperations lateinit var eventPublisher:EventPublisher lateinit var useCase:CreateTableUseCase beforeTest {operations=mockk(relaxed=true) {coEvery {save(any())} returns mockk<ADTable>().right()} eventPublisher=mockk(relaxed=true) useCase=CreateTableUseCase(operations,eventPublisher)} describe("execute") {context("with valid command") {val columns=listOf(CreateColumnCommand(name="column_name",displayName="Column Name",description="A test column",dataType=DataType.STRING,length=50,precision=null,scale=null)) val command=CreateTableCommand(name="test_table",displayName="Test Table",description="A test table",accessLevel=AccessLevel.SYSTEM,createdBy="test-user",columns=columns) it("should create and store table") {runTest {// given val tableSlot=slot<ADTable>() coEvery {operations.save(capture(tableSlot))} answers {tableSlot.captured.right()} // when val result=useCase.execute(command) // then result.fold({error->throw AssertionError("Should not fail:$error")},{table->table.name.value shouldBe "test_table" table.displayName.value shouldBe "Test Table" table.description?.value shouldBe "A test table" table.accessLevel shouldBe AccessLevel.SYSTEM table.metadata.createdBy shouldBe "test-user"})}}} context("with invalid command") {val columns=listOf(CreateColumnCommand(name="column_name",displayName="",description="A test column with an invalid name",dataType=DataType.STRING,length=50,precision=null,scale=null)) val command=CreateTableCommand(name="Invalid Name!",displayName="",description="A".repeat(300),accessLevel=AccessLevel.SYSTEM,createdBy="test-user",columns=columns) it("should return validation errors") {runTest {// when val result=useCase.execute(command) // then result.fold({error->error.shouldBeTypeOf<TableError.ValidationFailed>() error.errors.size shouldBe 3},{throw AssertionError("Should not succeed")})}}}}})
File: ./src/test/kotlin/org/blackerp/shared/TimeBasedIdTest.kt
-------------------------------------------
package org.blackerp.shared import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.matchers.shouldNotBe import java.util.UUID class TimeBasedIdTest :DescribeSpec({describe("TimeBasedId") {describe("generate") {it("should generate time-based UUIDs") {// Generate two IDs with a small delay val id1=TimeBasedId.generate() Thread.sleep(1) // Minimal delay val id2=TimeBasedId.generate() // Verify they are different id1 shouldNotBe id2 // Verify version 1 (time-based) UUID (id1.version() == 1) shouldBe true (id2.version() == 1) shouldBe true}}}})
File: ./src/test/kotlin/org/blackerp/shared/TestFactory.kt
-------------------------------------------
package org.blackerp.shared import org.blackerp.api.dto.request.CreateTableRequest import org.blackerp.api.dto.request.CreateColumnRequest import org.blackerp.api.dto.response.TableResponse import org.blackerp.application.table.CreateTableCommand import org.blackerp.application.table.CreateColumnCommand import org.blackerp.domain.EntityMetadata import org.blackerp.domain.table.ADTable import org.blackerp.domain.table.ColumnDefinition import org.blackerp.domain.values.* import java.time.Instant import java.util.UUID object TestFactory {fun createMetadata(id:UUID=TimeBasedId.generate(),createdBy:String="test-user",updatedBy:String=createdBy,version:Int=0,active:Boolean=true)=EntityMetadata(id=id,created=Instant.now(),createdBy=createdBy,updated=Instant.now(),updatedBy=updatedBy,version=version,active=active) fun createValidTableName(name:String="test_table")=TableName.create(name).getOrNull() ?:throw IllegalStateException("Failed to create valid table name:$name") fun createValidDisplayName(name:String="Test Table")=DisplayName.create(name).getOrNull() ?:throw IllegalStateException("Failed to create valid display name:$name") fun createValidDescription(text:String="Test description")=Description.create(text).getOrNull() fun createTestColumn():ColumnDefinition {val metadata=createMetadata() val name=ColumnName.create("test_column").getOrNull()!! val displayName=DisplayName.create("Test Column").getOrNull()!! val description=Description.create("Test column description").getOrNull() val length=Length.create(50).getOrNull()!! return ColumnDefinition(metadata=metadata,name=name,displayName=displayName,description=description,dataType=DataType.STRING,length=length,precision=null,scale=null,mandatory=false,defaultValue=null)} // Add inside TestFactory object fun createTableRequest()=CreateTableRequest(name="test_table",displayName="Test Table",description="Test Description",accessLevel="SYSTEM",columns=listOf(CreateColumnRequest(name="test_column",displayName="Test Column",description="Test column description",dataType="STRING",length=50,precision=null,scale=null))) fun createTableCommand()=CreateTableCommand(name="test_table",displayName="Test Table",description="Test Description",accessLevel=AccessLevel.SYSTEM,createdBy="test-user",columns=listOf(CreateColumnCommand(name="test_column",displayName="Test Column",description="Test column description",dataType=DataType.STRING,length=50,precision=null,scale=null))) fun createTableResponse()=TableResponse(id=UUID.randomUUID(),name="test_table",displayName="Test Table",description="Test Description",accessLevel="SYSTEM") fun createTestTable(id:UUID=TimeBasedId.generate(),name:String="test_table",displayName:String="Test Table",description:String?="Test Description",accessLevel:AccessLevel=AccessLevel.SYSTEM,createdBy:String="test-user",updatedBy:String=createdBy):ADTable {val metadata=createMetadata(id=id,createdBy=createdBy,updatedBy=updatedBy) return ADTable(metadata=metadata,name=createValidTableName(name),displayName=createValidDisplayName(displayName),description=description?.let {createValidDescription(it)},accessLevel=accessLevel,columns=listOf(createTestColumn()))}} 
File: ./src/test/kotlin/org/blackerp/integration/plugin/PluginLifecycleIntegrationTest.kt
-------------------------------------------
package org.blackerp.integration.plugin import io.kotest.core.spec.style.DescribeSpec import io.kotest.assertions.arrow.core.shouldBeRight import org.springframework.boot.test.context.SpringBootTest import org.springframework.test.context.ActiveProfiles import org.blackerp.integration.IntegrationTestConfig import org.springframework.context.annotation.Import import org.blackerp.plugin.* import org.blackerp.plugin.registry.DefaultPluginRegistry import org.blackerp.plugin.registry.PluginRegistry @SpringBootTest @ActiveProfiles("test") @Import(IntegrationTestConfig::class) class PluginLifecycleIntegrationTest :DescribeSpec({val pluginRegistry:PluginRegistry=DefaultPluginRegistry() describe("Plugin Lifecycle") {it("should load and initialize plugin") {// given val pluginId=PluginId.create("test-plugin").getOrNull()!! val version=Version.create("1.0.0").getOrNull()!! val metadata=PluginMetadata.create(id=pluginId,version=version,name="Test Plugin",description="Test plugin",vendor="Test Vendor").getOrNull()!! val plugin=TestPlugin(metadata) // when val registerResult=pluginRegistry.register(plugin) // then registerResult.shouldBeRight()}}}) 
File: ./src/test/kotlin/org/blackerp/integration/api/TableApiIntegrationTest.kt
-------------------------------------------
// File:src/test/kotlin/org/blackerp/integration/api/TableApiIntegrationTest.kt package org.blackerp.integration.api import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc import org.springframework.test.web.servlet.MockMvc import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status import org.springframework.http.MediaType import org.springframework.beans.factory.annotation.Autowired import io.kotest.core.spec.style.DescribeSpec import io.mockk.coEvery import kotlinx.coroutines.test.runTest import arrow.core.right import org.blackerp.shared.TestFactory import com.fasterxml.jackson.databind.ObjectMapper import com.ninjasquad.springmockk.MockkBean import org.blackerp.domain.table.TableOperations import org.blackerp.application.table.CreateTableUseCase import org.blackerp.api.mappers.TableMapper import org.blackerp.api.controllers.TableController import java.io.File @WebMvcTest(TableController::class) @AutoConfigureMockMvc(addFilters=false) class TableApiIntegrationTest @Autowired constructor(private val mockMvc:MockMvc,private val objectMapper:ObjectMapper,@MockkBean private val tableOperations:TableOperations,@MockkBean private val createTableUseCase:CreateTableUseCase,@MockkBean private val tableMapper:TableMapper) :DescribeSpec({beforeTest {File("testdebug.txt").writeText("")} describe("POST /api/tables") {it("should create table successfully") {runTest {val request=TestFactory.createTableRequest() val command=TestFactory.createTableCommand() val table=TestFactory.createTestTable() val response=TestFactory.createTableResponse() val requestJson=objectMapper.writeValueAsString(request) val expectedJson=objectMapper.writeValueAsString(response) File("testdebug.txt").appendText(""" POST Request:$requestJson Expected POST:$expectedJson """.trimIndent()) coEvery {tableMapper.toCommand(request)} returns command coEvery {createTableUseCase.execute(command)} returns table.right() coEvery {tableMapper.toResponse(table)} returns response val result=mockMvc.perform(post("/api/tables") .contentType(MediaType.APPLICATION_JSON) .content(requestJson)) .andExpect(status().isOk) .andReturn() File("testdebug.txt").appendText("\nActual POST:${result.response.contentAsString}")}}}})
File: ./src/test/kotlin/org/blackerp/integration/db/TableRepositoryIntegrationTest.kt
-------------------------------------------
package org.blackerp.integration.db import io.kotest.core.spec.style.DescribeSpec import io.kotest.matchers.shouldBe import io.kotest.assertions.arrow.core.shouldBeRight import org.springframework.boot.test.context.SpringBootTest import org.springframework.test.context.ActiveProfiles import org.blackerp.integration.IntegrationTestConfig import org.springframework.context.annotation.Import import org.blackerp.infrastructure.persistence.store.PostgresTableOperations import org.blackerp.shared.TestFactory import org.springframework.jdbc.core.JdbcTemplate @SpringBootTest @ActiveProfiles("test") @Import(IntegrationTestConfig::class) class TableRepositoryIntegrationTest(private val jdbcTemplate:JdbcTemplate) :DescribeSpec({lateinit var tableOperations:PostgresTableOperations beforeTest {tableOperations=PostgresTableOperations(jdbcTemplate)} describe("TableRepository") {it("should save and retrieve table") {// given val table=TestFactory.createTestTable() // when val saveResult=tableOperations.save(table) val findResult=tableOperations.findById(table.metadata.id) // then saveResult.shouldBeRight() findResult.shouldBeRight()}}}) 
File: ./src/test/kotlin/org/blackerp/integration/IntegrationTestConfig.kt
-------------------------------------------
package org.blackerp.integration import org.springframework.boot.test.context.TestConfiguration import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Primary import javax.sql.DataSource import org.springframework.boot.test.web.client.TestRestTemplate import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType import org.springframework.jdbc.core.JdbcTemplate import org.blackerp.application.table.CreateTableUseCase import org.blackerp.infrastructure.event.EventPublisher import org.blackerp.infrastructure.persistence.store.PostgresTableOperations import io.mockk.mockk @TestConfiguration class IntegrationTestConfig {@Bean @Primary fun dataSource():DataSource=EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("db/h2-schema.sql") .build() @Bean fun jdbcTemplate(dataSource:DataSource):JdbcTemplate=JdbcTemplate(dataSource) @Bean fun testRestTemplate()=TestRestTemplate() @Bean fun eventPublisher():EventPublisher=mockk(relaxed=true) @Bean fun tableOperations(jdbcTemplate:JdbcTemplate):PostgresTableOperations=PostgresTableOperations(jdbcTemplate) @Bean fun createTableUseCase(tableOperations:PostgresTableOperations,eventPublisher:EventPublisher):CreateTableUseCase=CreateTableUseCase(tableOperations,eventPublisher)}