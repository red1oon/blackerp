Generating folder structure...
-------------------------------------------
.  [error opening dir]

0 directories, 1 file



Generating file details...
-------------------------------------------
File: ./settings.gradle.kts
// Classpath: settings.gradle

rootProject.name = "blackerp"



File: ./frontend/node_modules/balanced-match/.github/FUNDING.yml
// Classpath: frontend.node_modules.balanced-match..github.FUNDING

tidelift: "npm/balanced-match"
patreon: juliangruber



File: ./frontend/node_modules/resolve/.github/FUNDING.yml
// Classpath: frontend.node_modules.resolve..github.FUNDING

# These are supported funding model platforms

github: [ljharb]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: npm/resolve
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
otechie: # Replace with a single Otechie username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']



File: ./frontend/node_modules/hasown/.github/FUNDING.yml
// Classpath: frontend.node_modules.hasown..github.FUNDING

# These are supported funding model platforms

github: [ljharb]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: npm/hasown
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
otechie: # Replace with a single Otechie username
custom: # Replace with a single custom sponsorship URL



File: ./frontend/node_modules/fastq/.github/workflows/ci.yml
// Classpath: frontend.node_modules.fastq..github.workflows.ci

name: ci

on: [push, pull_request]

jobs:
  legacy:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: ['0.10', '0.12', 4.x, 6.x, 8.x]

    steps:
      - uses: actions/checkout@v3
        with:
          persist-credentials: false

      - name: Use Node.js
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install
        run: |
          npm install --production && npm install tape

      - name: Run tests
        run: |
          npm run legacy

  test:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [10.x, 12.x, 13.x, 14.x, 15.x, 16.x, 18.x, 20.x]

    steps:
      - uses: actions/checkout@v3
        with:
          persist-credentials: false

      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ matrix.node-version }}

      - name: Install
        run: |
          npm install

      - name: Run tests
        run: |
          npm run test

  types:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
        with:
          persist-credentials: false

      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 16

      - name: Install
        run: |
          npm install

      - name: Run types tests
        run: |
          npm run typescript



File: ./frontend/node_modules/fastq/.github/dependabot.yml
// Classpath: frontend.node_modules.fastq..github.dependabot

version: 2
updates:
- package-ecosystem: npm
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
  ignore:
  - dependency-name: standard
    versions:
    - 16.0.3



File: ./frontend/node_modules/bl/.github/workflows/test-and-release.yml
// Classpath: frontend.node_modules.bl..github.workflows.test-and-release

name: Test & Maybe Release
on: [push, pull_request]
jobs:
  test:
    strategy:
      fail-fast: false
      matrix:
        node: [14.x, 16.x, 18.x, lts/*, current]
        os: [macos-latest, ubuntu-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3
      - name: Use Node.js ${{ matrix.node }}
        uses: actions/setup-node@v3.5.1
        with:
          node-version: ${{ matrix.node }}
      - name: Install Dependencies
        run: |
          npm install --no-progress
      - name: Run tests
        run: |
          npm config set script-shell bash
          npm run test:ci
  release:
    name: Release
    needs: test
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - name: Setup Node.js
        uses: actions/setup-node@v3.5.1
        with:
          node-version: 14
      - name: Install dependencies
        run: |
          npm install --no-progress --no-package-lock --no-save
      - name: Build
        run: |
          npm run build
      - name: Install plugins
        run: |
          npm install \
            @semantic-release/commit-analyzer \
            conventional-changelog-conventionalcommits \
            @semantic-release/release-notes-generator \
            @semantic-release/npm \
            @semantic-release/github \
            @semantic-release/git \
            @semantic-release/changelog \
            --no-progress --no-package-lock --no-save
      - name: Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: npx semantic-release




File: ./frontend/node_modules/bl/.github/dependabot.yml
// Classpath: frontend.node_modules.bl..github.dependabot

version: 2
updates:
  - package-ecosystem: 'github-actions'
    directory: '/'
    schedule:
      interval: 'daily'
    commit-message:
      prefix: 'chore'
      include: 'scope'
  - package-ecosystem: 'npm'
    directory: '/'
    schedule:
      interval: 'daily'
    commit-message:
      prefix: 'chore'
      include: 'scope'



File: ./frontend/node_modules/reusify/.coveralls.yml
// Classpath: frontend.node_modules.reusify..coveralls

repo_token: yIxhFqtaaz5iGVYfie9mODehFYogm8S8L



File: ./frontend/node_modules/reusify/.travis.yml
// Classpath: frontend.node_modules.reusify..travis

language: node_js
sudo: false

node_js:
  - 9
  - 8
  - 7
  - 6
  - 5
  - 4
  - 4.0
  - iojs-v3
  - iojs-v2
  - iojs-v1
  - 0.12
  - 0.10

cache:
  directories:
    - node_modules

after_script:
- npm run coverage

notifications:
  email:
    on_success: never
    on_failure: always



File: ./frontend/node_modules/brace-expansion/.github/FUNDING.yml
// Classpath: frontend.node_modules.brace-expansion..github.FUNDING

tidelift: "npm/brace-expansion"
patreon: juliangruber



File: ./frontend/node_modules/supports-preserve-symlinks-flag/.github/FUNDING.yml
// Classpath: frontend.node_modules.supports-preserve-symlinks-flag..github.FUNDING

# These are supported funding model platforms

github: [ljharb]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: npm/supports-preserve-symlink-flag
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
otechie: # Replace with a single Otechie username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']



File: ./frontend/node_modules/function-bind/.github/FUNDING.yml
// Classpath: frontend.node_modules.function-bind..github.FUNDING

# These are supported funding model platforms

github: [ljharb]
patreon: # Replace with a single Patreon username
open_collective: # Replace with a single Open Collective username
ko_fi: # Replace with a single Ko-fi username
tidelift: npm/function-bind
community_bridge: # Replace with a single Community Bridge project-name e.g., cloud-foundry
liberapay: # Replace with a single Liberapay username
issuehunt: # Replace with a single IssueHunt username
otechie: # Replace with a single Otechie username
custom: # Replace with up to 4 custom sponsorship URLs e.g., ['link1', 'link2']



File: ./docker-compose.yml
// Classpath: docker-compose

version: '3.8'
services:
  db:
    image: postgres:14-alpine
    environment:
      POSTGRES_DB: blackerp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:



File: ./build.gradle.kts
// Classpath: build.gradle

plugins {
    kotlin("jvm") version "1.9.20"
    kotlin("plugin.spring") version "1.9.20"
    id("org.springframework.boot") version "3.2.0"
    id("io.spring.dependency-management") version "1.1.4"
    id("org.flywaydb.flyway") version "9.21.0"
    id("jacoco")
}

group = "org.blackerp"
version = "0.0.1-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.flywaydb:flyway-core")
    implementation("com.fasterxml.uuid:java-uuid-generator:4.2.0")
    
    // Kotlin
    implementation("org.jetbrains.kotlin:kotlin-reflect")
    implementation("org.jetbrains.kotlin:kotlin-stdlib")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core")
    implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor")

    // Spring
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-validation")
    implementation("org.springframework.boot:spring-boot-starter-jdbc")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    
    // Arrow
    implementation("io.arrow-kt:arrow-core:1.2.0")
    implementation("io.arrow-kt:arrow-fx-coroutines:1.2.0")
    
    // Testing
    testImplementation("org.springframework.boot:spring-boot-starter-test") {
        exclude(module = "mockito-core")
    }
    testImplementation("com.ninja-squad:springmockk:4.0.2")
    testImplementation("io.mockk:mockk:1.13.8")
    testImplementation("com.h2database:h2:2.1.214")
    
    // Kotest
    testImplementation("io.kotest:kotest-runner-junit5:5.8.0")
    testImplementation("io.kotest:kotest-assertions-core:5.8.0")
    testImplementation("io.kotest:kotest-property:5.8.0")
    testImplementation("io.kotest:kotest-framework-datatest:5.8.0")
    testImplementation("io.kotest.extensions:kotest-extensions-spring:1.1.3")
    testImplementation("io.kotest.extensions:kotest-assertions-arrow:1.3.3")
    
    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
}

tasks.withType<Test> {
    useJUnitPlatform()
}

tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs = listOf("-Xjsr305=strict")
        jvmTarget = "17"
    }
}

jacoco {
    toolVersion = "0.8.9"
}

tasks.jacocoTestReport {
    dependsOn(tasks.test)
    
    reports {
        xml.required.set(true)
        html.required.set(true)
        html.outputLocation.set(layout.buildDirectory.dir("reports/jacoco"))
    }
    
    classDirectories.setFrom(
        files(classDirectories.files.map {
            fileTree(it) {
                exclude(
                    // Exclude classes that don't need test coverage
                    "**/BlackErpApplication*",
                    "**/config/**",
                    "**/dto/**",
                    "**/*Error*",
                    "**/infrastructure/persistence/store/PostgresTabOperations.kt"
                )
            }
        })
    )
}

tasks.test {
    finalizedBy(tasks.jacocoTestReport)
}

flyway {
    url = "jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL"
    user = "sa"
    password = ""
    baselineOnMigrate = true
    locations = arrayOf("classpath:db/migration")
}


File: ./build/resources/main/application.yml
// Classpath: build.resources.main.application

spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    username: sa
    password:
    driver-class-name: org.h2.Driver
  h2:
    console:
      enabled: true
      path: /h2-console
  flyway:
    locations: classpath:db/migration
    baseline-on-migrate: true
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    show-sql: true
    properties:
      hibernate:
        format_sql: true



File: ./build/resources/main/db/migration/V3__Create_tab_schema.sql
// Classpath: build.resources.main.db.migration.V3__Create_tab_schema

-- src/main/resources/db/migration/V3__Create_tab_schema.sql
CREATE TABLE ad_tab (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    table_name VARCHAR(100) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_tab_name UNIQUE (name),
    CONSTRAINT fk_tab_table FOREIGN KEY (table_name) 
        REFERENCES ad_table(name)
);

CREATE INDEX idx_tab_name ON ad_tab(name);
CREATE INDEX idx_tab_table ON ad_tab(table_name);

CREATE TABLE ad_tab_query_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE ad_tab_display_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE ad_tab_order_by (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE,
    CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);


File: ./build/resources/main/db/migration/V2_create_relationship_schema.sql
// Classpath: build.resources.main.db.migration.V2_create_relationship_schema

-- File: src/main/resources/db/migration/V2__Create_relationship_schema.sql
CREATE TABLE ad_table_relationship (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    source_table VARCHAR(100) NOT NULL,
    target_table VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL,
    source_column VARCHAR(100) NOT NULL,
    target_column VARCHAR(100) NOT NULL,
    delete_rule VARCHAR(20) NOT NULL,
    update_rule VARCHAR(20) NOT NULL,
    junction_table VARCHAR(100),
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_relationship_name UNIQUE (name),
    CONSTRAINT fk_source_table FOREIGN KEY (source_table) REFERENCES ad_table(name),
    CONSTRAINT fk_target_table FOREIGN KEY (target_table) REFERENCES ad_table(name),
    CONSTRAINT fk_junction_table FOREIGN KEY (junction_table) REFERENCES ad_table(name),
    CONSTRAINT chk_relationship_type CHECK (type IN ('ONE_TO_ONE', 'ONE_TO_MANY', 'MANY_TO_MANY')),
    CONSTRAINT chk_delete_rule CHECK (delete_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION')),
    CONSTRAINT chk_update_rule CHECK (update_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION'))
);

CREATE INDEX idx_relationship_source ON ad_table_relationship(source_table);
CREATE INDEX idx_relationship_target ON ad_table_relationship(target_table);
CREATE INDEX idx_relationship_active ON ad_table_relationship(active);

COMMENT ON TABLE ad_table_relationship IS 'Table Relationship Definitions';


File: ./build/resources/main/db/migration/V1__Create_table_schema.sql
// Classpath: build.resources.main.db.migration.V1__Create_table_schema

CREATE TABLE ad_table (
    id UUID PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    access_level VARCHAR(50) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT name_format CHECK (name ~ '^[a-z][a-z0-9_]*$')
);

CREATE INDEX idx_ad_table_name ON ad_table(name);
CREATE INDEX idx_ad_table_active ON ad_table(active);

COMMENT ON TABLE ad_table IS 'Application Dictionary Table Definitions';
COMMENT ON COLUMN ad_table.id IS 'Time-based UUID primary key';
COMMENT ON COLUMN ad_table.name IS 'Technical name (lowercase with underscores)';
COMMENT ON COLUMN ad_table.display_name IS 'Human readable name';
COMMENT ON COLUMN ad_table.description IS 'Optional description';
COMMENT ON COLUMN ad_table.access_level IS 'Access level (SYSTEM, CLIENT, ORGANIZATION, etc)';
COMMENT ON COLUMN ad_table.version IS 'Optimistic locking version';



File: ./build/resources/test/application.yml
// Classpath: build.resources.test.application

spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    username: sa
    password:
    driver-class-name: org.h2.Driver
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  
  flyway:
    enabled: false
    locations: classpath:db/migration
    baseline-on-migrate: true
    
  h2:
    console:
      enabled: true
      path: /h2-console

logging:
  level:
    org.springframework: INFO
    org.blackerp: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE



File: ./build/resources/test/application-test.yml
// Classpath: build.resources.test.application-test

spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    username: sa
    password:
    driver-class-name: org.h2.Driver
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  
  flyway:
    enabled: false
    locations: classpath:db/migration
    baseline-on-migrate: true
    
  h2:
    console:
      enabled: true
      path: /h2-console

logging:
  level:
    org.springframework: INFO
    org.blackerp: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE



File: ./build/resources/test/db/migration/V4__create_test_tables.sql
// Classpath: build.resources.test.db.migration.V4__create_test_tables

CREATE TABLE IF NOT EXISTS ad_table (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(60) NOT NULL,
    display_name VARCHAR(60) NOT NULL,
    created_by VARCHAR(60) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uk_ad_table_name UNIQUE (name)
);


File: ./build/resources/test/db/h2-schema.sql
// Classpath: build.resources.test.db.h2-schema

-- Drop existing tables if they exist
DROP TABLE IF EXISTS ad_tab_order_by;
DROP TABLE IF EXISTS ad_tab_display_column;
DROP TABLE IF EXISTS ad_tab_query_column;
DROP TABLE IF EXISTS ad_tab;
DROP TABLE IF EXISTS ad_table_relationship;
DROP TABLE IF EXISTS ad_table;

-- Create ad_table with H2-compatible syntax
CREATE TABLE ad_table (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    access_level VARCHAR(50) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_table_name UNIQUE (name)
);

-- Use REGEXP_LIKE for H2 name format check
ALTER TABLE ad_table ADD CONSTRAINT chk_table_name 
    CHECK (REGEXP_LIKE(name, '^[a-z][a-z0-9_]*$'));

-- Create relationship table
CREATE TABLE ad_table_relationship (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    source_table VARCHAR(100) NOT NULL,
    target_table VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL,
    source_column VARCHAR(100) NOT NULL,
    target_column VARCHAR(100) NOT NULL,
    delete_rule VARCHAR(20) NOT NULL,
    update_rule VARCHAR(20) NOT NULL,
    junction_table VARCHAR(100),
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_relationship_name UNIQUE (name),
    CONSTRAINT fk_source_table FOREIGN KEY (source_table) REFERENCES ad_table(name),
    CONSTRAINT fk_target_table FOREIGN KEY (target_table) REFERENCES ad_table(name),
    CONSTRAINT fk_junction_table FOREIGN KEY (junction_table) REFERENCES ad_table(name),
    CONSTRAINT chk_relationship_type CHECK (type IN ('ONE_TO_ONE', 'ONE_TO_MANY', 'MANY_TO_MANY')),
    CONSTRAINT chk_delete_rule CHECK (delete_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION')),
    CONSTRAINT chk_update_rule CHECK (update_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION'))
);

-- Create tab and related tables
CREATE TABLE ad_tab (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    table_name VARCHAR(100) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_tab_name UNIQUE (name),
    CONSTRAINT fk_tab_table FOREIGN KEY (table_name) REFERENCES ad_table(name)
);

CREATE TABLE ad_tab_query_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE ad_tab_display_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE ad_tab_order_by (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE,
    CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);

-- Create indexes for better performance
CREATE INDEX idx_table_name ON ad_table(name);
CREATE INDEX idx_table_active ON ad_table(active);
CREATE INDEX idx_relationship_source ON ad_table_relationship(source_table);
CREATE INDEX idx_relationship_target ON ad_table_relationship(target_table);
CREATE INDEX idx_relationship_active ON ad_table_relationship(active);
CREATE INDEX idx_tab_name ON ad_tab(name);
CREATE INDEX idx_tab_table ON ad_tab(table_name);


File: ./build/resources/test/db/schema.sql
// Classpath: build.resources.test.db.schema

-- src/test/resources/db/schema.sql
-- Add after existing tables

CREATE TABLE IF NOT EXISTS ad_tab (
    id UUID PRIMARY KEY,
    name VARCHAR(60) NOT NULL CONSTRAINT uk_tab_name UNIQUE,
    display_name VARCHAR(60) NOT NULL,
    description VARCHAR(255),
    table_name VARCHAR(60) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(60) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(60) NOT NULL,
    version INT NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT fk_tab_table FOREIGN KEY (table_name) 
        REFERENCES ad_table(name)
);

CREATE TABLE IF NOT EXISTS ad_tab_query_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(60) NOT NULL,
    sequence INT NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS ad_tab_display_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(60) NOT NULL,
    sequence INT NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS ad_tab_order_by (
    tab_id UUID NOT NULL,
    column_name VARCHAR(60) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    sequence INT NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE,
    CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);


File: ./src/main/resources/application.yml
// Classpath: src.main.resources.application

spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    username: sa
    password:
    driver-class-name: org.h2.Driver
  h2:
    console:
      enabled: true
      path: /h2-console
  flyway:
    locations: classpath:db/migration
    baseline-on-migrate: true
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    show-sql: true
    properties:
      hibernate:
        format_sql: true



File: ./src/main/resources/db/migration/V3__Create_tab_schema.sql
// Classpath: src.main.resources.db.migration.V3__Create_tab_schema

-- src/main/resources/db/migration/V3__Create_tab_schema.sql
CREATE TABLE ad_tab (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    table_name VARCHAR(100) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_tab_name UNIQUE (name),
    CONSTRAINT fk_tab_table FOREIGN KEY (table_name) 
        REFERENCES ad_table(name)
);

CREATE INDEX idx_tab_name ON ad_tab(name);
CREATE INDEX idx_tab_table ON ad_tab(table_name);

CREATE TABLE ad_tab_query_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE ad_tab_display_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE ad_tab_order_by (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE,
    CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);


File: ./src/main/resources/db/migration/V2_create_relationship_schema.sql
// Classpath: src.main.resources.db.migration.V2_create_relationship_schema

-- File: src/main/resources/db/migration/V2__Create_relationship_schema.sql
CREATE TABLE ad_table_relationship (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    source_table VARCHAR(100) NOT NULL,
    target_table VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL,
    source_column VARCHAR(100) NOT NULL,
    target_column VARCHAR(100) NOT NULL,
    delete_rule VARCHAR(20) NOT NULL,
    update_rule VARCHAR(20) NOT NULL,
    junction_table VARCHAR(100),
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_relationship_name UNIQUE (name),
    CONSTRAINT fk_source_table FOREIGN KEY (source_table) REFERENCES ad_table(name),
    CONSTRAINT fk_target_table FOREIGN KEY (target_table) REFERENCES ad_table(name),
    CONSTRAINT fk_junction_table FOREIGN KEY (junction_table) REFERENCES ad_table(name),
    CONSTRAINT chk_relationship_type CHECK (type IN ('ONE_TO_ONE', 'ONE_TO_MANY', 'MANY_TO_MANY')),
    CONSTRAINT chk_delete_rule CHECK (delete_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION')),
    CONSTRAINT chk_update_rule CHECK (update_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION'))
);

CREATE INDEX idx_relationship_source ON ad_table_relationship(source_table);
CREATE INDEX idx_relationship_target ON ad_table_relationship(target_table);
CREATE INDEX idx_relationship_active ON ad_table_relationship(active);

COMMENT ON TABLE ad_table_relationship IS 'Table Relationship Definitions';


File: ./src/main/resources/db/migration/V1__Create_table_schema.sql
// Classpath: src.main.resources.db.migration.V1__Create_table_schema

CREATE TABLE ad_table (
    id UUID PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    access_level VARCHAR(50) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT name_format CHECK (name ~ '^[a-z][a-z0-9_]*$')
);

CREATE INDEX idx_ad_table_name ON ad_table(name);
CREATE INDEX idx_ad_table_active ON ad_table(active);

COMMENT ON TABLE ad_table IS 'Application Dictionary Table Definitions';
COMMENT ON COLUMN ad_table.id IS 'Time-based UUID primary key';
COMMENT ON COLUMN ad_table.name IS 'Technical name (lowercase with underscores)';
COMMENT ON COLUMN ad_table.display_name IS 'Human readable name';
COMMENT ON COLUMN ad_table.description IS 'Optional description';
COMMENT ON COLUMN ad_table.access_level IS 'Access level (SYSTEM, CLIENT, ORGANIZATION, etc)';
COMMENT ON COLUMN ad_table.version IS 'Optimistic locking version';



File: ./src/main/kotlin/org/blackerp/infrastructure/event/EventPublisher.kt
// Classpath: src.main.kotlin.org.blackerp.infrastructure.event.EventPublisher

package org.blackerp.infrastructure.event

import arrow.core.Either
import org.blackerp.domain.event.DomainEvent
import org.blackerp.domain.table.TableError

interface EventPublisher {
    suspend fun publish(event: DomainEvent): Either<TableError, Unit>
}



File: ./src/main/kotlin/org/blackerp/infrastructure/cache/CacheService.kt
// Classpath: src.main.kotlin.org.blackerp.infrastructure.cache.CacheService

package org.blackerp.infrastructure.cache

import arrow.core.Either
import org.blackerp.domain.error.DomainError
import java.time.Duration

interface CacheService {
    suspend fun <T> get(key: String): Either<DomainError, T?>
    suspend fun <T> set(key: String, value: T, ttl: Duration? = null): Either<DomainError, Unit>
    suspend fun delete(key: String): Either<DomainError, Unit>
    suspend fun clear(): Either<DomainError, Unit>
}



File: ./src/main/kotlin/org/blackerp/infrastructure/cache/InMemoryCacheService.kt
// Classpath: src.main.kotlin.org.blackerp.infrastructure.cache.InMemoryCacheService

package org.blackerp.infrastructure.cache

import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.error.DomainError
import java.time.Duration
import java.time.Instant
import java.util.concurrent.ConcurrentHashMap

class InMemoryCacheService : CacheService {
    private data class CacheEntry<T>(
        val value: T,
        val expiry: Instant?
    )

    private val cache = ConcurrentHashMap<String, CacheEntry<Any>>()

    @Suppress("UNCHECKED_CAST")
    override suspend fun <T> get(key: String): Either<DomainError, T?> =
        cache[key]?.let { entry ->
            if (entry.expiry == null || entry.expiry > Instant.now()) {
                (entry.value as T).right()
            } else {
                cache.remove(key)
                null.right()
            }
        } ?: null.right()

    override suspend fun <T> set(key: String, value: T, ttl: Duration?): Either<DomainError, Unit> {
        val expiry = ttl?.let { Instant.now().plus(it) }
        cache[key] = CacheEntry(value as Any, expiry)
        return Unit.right()
    }

    override suspend fun delete(key: String): Either<DomainError, Unit> {
        cache.remove(key)
        return Unit.right()
    }

    override suspend fun clear(): Either<DomainError, Unit> {
        cache.clear()
        return Unit.right()
    }
}



File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTableOperations.kt
// Classpath: src.main.kotlin.org.blackerp.infrastructure.persistence.store.PostgresTableOperations

package org.blackerp.infrastructure.persistence.store

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.TableOperations
import org.blackerp.domain.values.*
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.dao.EmptyResultDataAccessException
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.RowMapper
import org.springframework.stereotype.Repository
import java.sql.ResultSet
import java.time.Instant
import java.util.UUID

@Repository
class PostgresTableOperations(
    private val jdbcTemplate: JdbcTemplate
) : TableOperations {
    private val tableMapper = TableRowMapper()

    override suspend fun save(table: ADTable): Either<TableError, ADTable> = try {
        jdbcTemplate.update("""
            INSERT INTO ad_table (
                id, name, display_name, description, access_level,
                created, created_by, updated, updated_by, version, active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
            table.metadata.id,
            table.name.value,
            table.displayName.value,
            table.description?.value,
            table.accessLevel.name,
            table.metadata.created,
            table.metadata.createdBy,
            table.metadata.updated,
            table.metadata.updatedBy,
            table.metadata.version,
            table.metadata.active
        )
        table.right()
    } catch (e: DataIntegrityViolationException) {
        when {
            e.message?.contains("name_format") == true ->
                TableError.StorageError(e).left()
            e.message?.contains("unique") == true ->
                TableError.DuplicateTable(table.name.value).left()
            else -> TableError.StorageError(e).left()
        }
    } catch (e: Exception) {
        TableError.StorageError(e).left()
    }

    override suspend fun findById(id: UUID): Either<TableError, ADTable?> = try {
        val table = jdbcTemplate.queryForObject(
            """
            SELECT id, name, display_name, description, access_level,
                   created, created_by, updated, updated_by, version, active
            FROM ad_table WHERE id = ?
            """,
            tableMapper,
            id
        )
        table?.right() ?: TableError.NotFound(id.toString()).left()
    } catch (e: EmptyResultDataAccessException) {
        TableError.NotFound(id.toString()).left()
    } catch (e: Exception) {
        TableError.StorageError(e).left()
    }

    override suspend fun findByName(name: String): Either<TableError, ADTable?> = try {
        val table = jdbcTemplate.queryForObject(
            """
            SELECT id, name, display_name, description, access_level,
                   created, created_by, updated, updated_by, version, active
            FROM ad_table WHERE name = ?
            """,
            tableMapper,
            name
        )
        table?.right() ?: TableError.NotFound(name).left()
    } catch (e: EmptyResultDataAccessException) {
        TableError.NotFound(name).left()
    } catch (e: Exception) {
        TableError.StorageError(e).left()
    }

    override suspend fun delete(id: UUID): Either<TableError, Unit> = try {
        val count = jdbcTemplate.update("DELETE FROM ad_table WHERE id = ?", id)
        if (count > 0) Unit.right() else TableError.NotFound(id.toString()).left()
    } catch (e: Exception) {
        TableError.StorageError(e).left()
    }

    private class TableRowMapper : RowMapper<ADTable> {
        override fun mapRow(rs: ResultSet, rowNum: Int): ADTable {
            val metadata = EntityMetadata(
                id = UUID.fromString(rs.getString("id")),
                created = rs.getTimestamp("created").toInstant(),
                createdBy = rs.getString("created_by"),
                updated = rs.getTimestamp("updated").toInstant(),
                updatedBy = rs.getString("updated_by"),
                version = rs.getInt("version"),
                active = rs.getBoolean("active")
            )

            // Placeholder for fetching columns, replace with actual logic to retrieve columns from database
            val columns = listOf<ColumnDefinition>()

            return ADTable(
                metadata = metadata,
                name = TableName.create(rs.getString("name")).getOrNull()!!,
                displayName = DisplayName.create(rs.getString("display_name")).getOrNull()!!,
                description = rs.getString("description")?.let { 
                    Description.create(it).getOrNull()
                },
                accessLevel = AccessLevel.fromString(rs.getString("access_level")),
                columns = columns // Pass columns here
            )
        }
    }
}



File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresRelationshipOperations.kt
// Classpath: src.main.kotlin.org.blackerp.infrastructure.persistence.store.PostgresRelationshipOperations

// File: src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresRelationshipOperations.kt
package org.blackerp.infrastructure.persistence.store

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.TableError
import org.blackerp.domain.values.*
import org.blackerp.domain.table.relationship.*
import org.blackerp.domain.table.relationship.value.*
import org.springframework.dao.DataIntegrityViolationException
import org.springframework.dao.EmptyResultDataAccessException
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.RowMapper
import org.springframework.stereotype.Repository
import java.sql.ResultSet
import java.time.Instant
import java.util.UUID

@Repository
class PostgresRelationshipOperations(
    private val jdbcTemplate: JdbcTemplate
) : RelationshipOperations {
    private val relationshipMapper = RelationshipRowMapper()

    override suspend fun save(relationship: TableRelationship): Either<TableError, TableRelationship> = try {
        jdbcTemplate.update("""
            INSERT INTO ad_table_relationship (
                id, name, source_table, target_table, type,
                source_column, target_column, delete_rule, update_rule,
                junction_table, created, created_by, updated, updated_by,
                version, active
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
            relationship.metadata.id,
            relationship.name.value,
            relationship.sourceTable.value,
            relationship.targetTable.value,
            relationship.type.name,
            relationship.sourceColumn.value,
            relationship.targetColumn.value,
            relationship.deleteRule.name,
            relationship.updateRule.name,
            null, // junction_table is null for non-many-to-many relationships
            relationship.metadata.created,
            relationship.metadata.createdBy,
            relationship.metadata.updated,
            relationship.metadata.updatedBy,
            relationship.metadata.version,
            relationship.metadata.active
        )
        relationship.right()
    } catch (e: DataIntegrityViolationException) {
        when {
            e.message?.contains("uk_relationship_name") == true ->
                TableError.DuplicateTable(relationship.name.value).left()
            else -> TableError.StorageError(e).left()
        }
    } catch (e: Exception) {
        TableError.StorageError(e).left()
    }

    override suspend fun findById(id: UUID): Either<TableError, TableRelationship?> = try {
        val relationship = jdbcTemplate.queryForObject(
            """
            SELECT id, name, source_table, target_table, type,
                   source_column, target_column, delete_rule, update_rule,
                   junction_table, created, created_by, updated, updated_by,
                   version, active
            FROM ad_table_relationship WHERE id = ?
            """,
            relationshipMapper,
            id
        )
        relationship?.right() ?: TableError.NotFound(id.toString()).left()
    } catch (e: EmptyResultDataAccessException) {
        TableError.NotFound(id.toString()).left()
    } catch (e: Exception) {
        TableError.StorageError(e).left()
    }

    override suspend fun findByTable(tableName: TableName): Either<TableError, List<TableRelationship>> = try {
        val relationships = jdbcTemplate.query(
            """
            SELECT id, name, source_table, target_table, type,
                   source_column, target_column, delete_rule, update_rule,
                   junction_table, created, created_by, updated, updated_by,
                   version, active
            FROM ad_table_relationship 
            WHERE source_table = ? OR target_table = ?
            """,
            relationshipMapper,
            tableName.value,
            tableName.value
        )
        relationships.right()
    } catch (e: Exception) {
        TableError.StorageError(e).left()
    }

    override suspend fun delete(id: UUID): Either<TableError, Unit> = try {
        val count = jdbcTemplate.update("DELETE FROM ad_table_relationship WHERE id = ?", id)
        if (count > 0) Unit.right() else TableError.NotFound(id.toString()).left()
    } catch (e: Exception) {
        TableError.StorageError(e).left()
    }

    private class RelationshipRowMapper : RowMapper<TableRelationship> {
        override fun mapRow(rs: ResultSet, rowNum: Int): TableRelationship {
            val metadata = EntityMetadata(
                id = UUID.fromString(rs.getString("id")),
                created = rs.getTimestamp("created").toInstant(),
                createdBy = rs.getString("created_by"),
                updated = rs.getTimestamp("updated").toInstant(),
                updatedBy = rs.getString("updated_by"),
                version = rs.getInt("version"),
                active = rs.getBoolean("active")
            )

            return TableRelationship(
                metadata = metadata,
                name = RelationshipName.create(rs.getString("name")).getOrNull()!!,
                sourceTable = TableName.create(rs.getString("source_table")).getOrNull()!!,
                targetTable = TableName.create(rs.getString("target_table")).getOrNull()!!,
                type = RelationType.valueOf(rs.getString("type")),
                sourceColumn = ColumnName.create(rs.getString("source_column")).getOrNull()!!,
                targetColumn = ColumnName.create(rs.getString("target_column")).getOrNull()!!,
                constraints = emptyList(), // Load constraints if needed
                deleteRule = DeleteRule.valueOf(rs.getString("delete_rule")),
                updateRule = UpdateRule.valueOf(rs.getString("update_rule"))
            )
        }
    }
}


File: ./src/main/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTabOperations.kt
// Classpath: src.main.kotlin.org.blackerp.infrastructure.persistence.store.PostgresTabOperations

package org.blackerp.infrastructure.persistence.store

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.ad.tab.*
import org.blackerp.domain.ad.tab.value.TabName
import org.blackerp.domain.values.*
import org.blackerp.domain.table.TableOperations
import org.blackerp.shared.ValidationError
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.core.RowMapper
import org.springframework.stereotype.Repository
import java.sql.ResultSet
import java.time.Instant
import java.util.UUID
import java.io.File

@Repository
class PostgresTabOperations(
    private val jdbcTemplate: JdbcTemplate,
    private val tableOperations: TableOperations
) : TabOperations {

    private fun debug(msg: String) {
        File("testdebug.txt").appendText("${Instant.now()}: $msg\n")
    }
    
    override suspend fun save(tab: ADTab): Either<TabError, ADTab> = 
        Either.catch {
            debug("Saving tab: ${tab.name.value}")
            
            // First, verify the table exists
            val tableExists = jdbcTemplate.queryForObject(
                "SELECT COUNT(*) FROM ad_table WHERE name = ?",
                Int::class.java,
                tab.table.name.value
            ) ?: 0
            
            debug("Table exists check: $tableExists")
            if (tableExists == 0) {
                throw IllegalStateException("Referenced table ${tab.table.name.value} does not exist")
            }

            // Insert/Update tab using MERGE
            val mergeResult = jdbcTemplate.update("""
                MERGE INTO ad_tab KEY(id) VALUES (
                    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                )
                """,
                tab.metadata.id,
                tab.name.value,
                tab.displayName.value,
                tab.description?.value,
                tab.table.name.value,
                tab.metadata.created,
                tab.metadata.createdBy,
                tab.metadata.updated,
                tab.metadata.updatedBy,
                tab.metadata.version,
                tab.metadata.active
            )
            debug("Tab merge result: $mergeResult")

            // Update query columns
            jdbcTemplate.update("DELETE FROM ad_tab_query_column WHERE tab_id = ?", tab.metadata.id)
            tab.queryColumns.forEachIndexed { index, column ->
                val qcResult = jdbcTemplate.update("""
                    INSERT INTO ad_tab_query_column (tab_id, column_name, sequence)
                    VALUES (?, ?, ?)
                    """,
                    tab.metadata.id,
                    column.value,
                    index
                )
                debug("Query column insert result: $qcResult")
            }

            // Update display columns
            jdbcTemplate.update("DELETE FROM ad_tab_display_column WHERE tab_id = ?", tab.metadata.id)
            tab.displayColumns.forEachIndexed { index, column ->
                val dcResult = jdbcTemplate.update("""
                    INSERT INTO ad_tab_display_column (tab_id, column_name, sequence)
                    VALUES (?, ?, ?)
                    """,
                    tab.metadata.id,
                    column.value,
                    index
                )
                debug("Display column insert result: $dcResult")
            }

            // Update order by specifications
            jdbcTemplate.update("DELETE FROM ad_tab_order_by WHERE tab_id = ?", tab.metadata.id)
            tab.orderBy.forEachIndexed { index, spec ->
                val obResult = jdbcTemplate.update("""
                    INSERT INTO ad_tab_order_by (tab_id, column_name, direction, sequence)
                    VALUES (?, ?, ?, ?)
                    """,
                    tab.metadata.id,
                    spec.column.value,
                    spec.direction.name,
                    index
                )
                debug("Order by insert result: $obResult")
            }

            tab
        }.mapLeft { e -> 
            debug("Error saving tab: ${e.message}")
            e.printStackTrace(File("testdebug.txt").printWriter())
            when (e) {
                is IllegalStateException -> TabError.ValidationFailed(
                    listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
                )
                else -> TabError.ValidationFailed(
                    listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
                )
            }
        }

    override suspend fun findById(id: UUID): Either<TabError, ADTab?> =
        Either.catch {
            val results = jdbcTemplate.query(
                """
                SELECT t.*, 
                       array_agg(DISTINCT qc.column_name) as query_columns,
                       array_agg(DISTINCT dc.column_name) as display_columns,
                       array_agg(DISTINCT ob.column_name || ',' || ob.direction) as order_by
                FROM ad_tab t
                LEFT JOIN ad_tab_query_column qc ON t.id = qc.tab_id
                LEFT JOIN ad_tab_display_column dc ON t.id = dc.tab_id
                LEFT JOIN ad_tab_order_by ob ON t.id = ob.tab_id
                WHERE t.id = ?
                GROUP BY t.id, t.name, t.display_name, t.description, t.table_name,
                         t.created, t.created_by, t.updated, t.updated_by, t.version, t.active
                """,
                TabRowMapper(tableOperations),
                id
            )
            
            results.firstOrNull()
        }.mapLeft { e -> 
            TabError.ValidationFailed(
                listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
            )
        }

    override suspend fun findByTable(tableName: TableName): Either<TabError, List<ADTab>> =
        Either.catch {
            jdbcTemplate.query(
                """
                SELECT t.*, 
                       array_agg(DISTINCT qc.column_name) as query_columns,
                       array_agg(DISTINCT dc.column_name) as display_columns,
                       array_agg(DISTINCT ob.column_name || ',' || ob.direction) as order_by
                FROM ad_tab t
                LEFT JOIN ad_tab_query_column qc ON t.id = qc.tab_id
                LEFT JOIN ad_tab_display_column dc ON t.id = dc.tab_id
                LEFT JOIN ad_tab_order_by ob ON t.id = ob.tab_id
                WHERE t.table_name = ?
                GROUP BY t.id, t.name, t.display_name, t.description, t.table_name,
                         t.created, t.created_by, t.updated, t.updated_by, t.version, t.active
                """,
                TabRowMapper(tableOperations),
                tableName.value
            )
        }.mapLeft { e -> 
            TabError.ValidationFailed(
                listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
            )
        }

    override suspend fun delete(id: UUID): Either<TabError, Unit> =
        Either.catch {
            val count = jdbcTemplate.update("DELETE FROM ad_tab WHERE id = ?", id)
            if (count == 0) throw IllegalStateException("Tab not found: $id")
            Unit
        }.mapLeft { e -> 
            TabError.ValidationFailed(
                listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
            )
        }

    private class TabRowMapper(
        private val tableOperations: TableOperations
    ) : RowMapper<ADTab> {
        override fun mapRow(rs: ResultSet, rowNum: Int): ADTab {
            val metadata = EntityMetadata(
                id = UUID.fromString(rs.getString("id")),
                created = rs.getTimestamp("created").toInstant(),
                createdBy = rs.getString("created_by"),
                updated = rs.getTimestamp("updated").toInstant(),
                updatedBy = rs.getString("updated_by"),
                version = rs.getInt("version"),
                active = rs.getBoolean("active")
            )

            val tableName = rs.getString("table_name")
            val table = kotlinx.coroutines.runBlocking { 
                tableOperations.findByName(tableName).getOrNull()
                    ?: throw IllegalStateException("Table not found: $tableName")
            }

            // Safe array handling
            val queryColumns = (rs.getArray("query_columns")?.array as? Array<*>)
                ?.filterNotNull()
                ?.map { it.toString() }
                ?.map { ColumnName.create(it).getOrNull()!! }
                ?: emptyList()

            val displayColumns = (rs.getArray("display_columns")?.array as? Array<*>)
                ?.filterNotNull()
                ?.map { it.toString() }
                ?.map { ColumnName.create(it).getOrNull()!! }
                ?: emptyList()

            val orderBy = (rs.getArray("order_by")?.array as? Array<*>)
                ?.filterNotNull()
                ?.map { it.toString() }
                ?.map { spec -> 
                    val (col, dir) = spec.split(",")
                    OrderBySpec(
                        column = ColumnName.create(col).getOrNull()!!,
                        direction = SortDirection.valueOf(dir)
                    )
                }
                ?: emptyList()

            return ADTab(
                metadata = metadata,
                name = TabName.create(rs.getString("name")).getOrNull()!!,
                displayName = DisplayName.create(rs.getString("display_name")).getOrNull()!!,
                description = rs.getString("description")?.let { 
                    Description.create(it).getOrNull()
                },
                table = table,
                queryColumns = queryColumns,
                displayColumns = displayColumns,
                orderBy = orderBy
            )
        }
    }
}


File: ./src/main/kotlin/org/blackerp/BlackErpApplication.kt
// Classpath: src.main.kotlin.org.blackerp.BlackErpApplication

// File: src/main/kotlin/org/blackerp/BlackErpApplication.kt
package org.blackerp

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class BlackErpApplication

fun main(args: Array<String>) {
    runApplication<BlackErpApplication>(*args)
}


File: ./src/main/kotlin/org/blackerp/plugin/PluginError.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.PluginError

package org.blackerp.plugin

import org.blackerp.shared.ValidationError

sealed interface PluginError {
    data class NotFound(val id: String) : PluginError
    data class ValidationFailed(val errors: List<ValidationError>) : PluginError
    data class DuplicatePlugin(val id: String) : PluginError
    data class IncompatibleVersion(val required: Version, val actual: Version) : PluginError
    data class InitializationFailed(val id: String, val cause: Throwable) : PluginError
    data class DiscoveryFailed(val message: String, val cause: Throwable? = null) : PluginError
    data class LoadFailed(val message: String) : PluginError
}



File: ./src/main/kotlin/org/blackerp/plugin/Plugin.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.Plugin

package org.blackerp.plugin

import arrow.core.Either

interface Plugin {
    val metadata: PluginMetadata
    
    /**
     * Initialize the plugin with provided context
     * @return Either an initialization error or Unit on success
     */
    suspend fun initialize(): Either<PluginError, Unit>
    
    /**
     * Register plugin extensions with the registry
     * @param registry Extension point registry
     * @return Either a registration error or Unit on success
     */
    suspend fun registerExtensions(registry: ExtensionRegistry): Either<PluginError, Unit>
    
    /**
     * Clean up plugin resources
     * @return Either a cleanup error or Unit on success
     */
    suspend fun shutdown(): Either<PluginError, Unit>
}



File: ./src/main/kotlin/org/blackerp/plugin/discovery/FileSystemPluginDiscovery.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.discovery.FileSystemPluginDiscovery

package org.blackerp.plugin.discovery

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.plugin.Plugin
import org.blackerp.plugin.PluginError
import java.nio.file.Files
import java.nio.file.Path
import kotlin.io.path.extension
import kotlin.io.path.isRegularFile

class FileSystemPluginDiscovery : PluginDiscovery {
    override suspend fun discoverPlugins(directory: Path): Either<PluginError, List<Plugin>> =
        try {
            Files.walk(directory)
                .filter { it.isRegularFile() && it.extension == "jar" }
                .use { paths ->
                    paths.toList()
                        .map { loadPlugin(it) }
                        .filter { it.isRight() }
                        .map { it.getOrNull()!! }
                        .toList()
                        .right()
                }
        } catch (e: Exception) {
            PluginError.DiscoveryFailed("Failed to discover plugins: ${e.message}", e).left()
        }

    override suspend fun loadPlugin(jarPath: Path): Either<PluginError, Plugin> =
        try {
            // Placeholder for actual JAR loading logic
            // Will be implemented with proper classloading
            PluginError.LoadFailed("Plugin loading not yet implemented").left()
        } catch (e: Exception) {
            PluginError.LoadFailed("Failed to load plugin: ${e.message}").left()
        }
}



File: ./src/main/kotlin/org/blackerp/plugin/discovery/PluginDiscovery.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.discovery.PluginDiscovery

package org.blackerp.plugin.discovery

import arrow.core.Either
import org.blackerp.plugin.Plugin
import org.blackerp.plugin.PluginError
import java.nio.file.Path

interface PluginDiscovery {
    suspend fun discoverPlugins(directory: Path): Either<PluginError, List<Plugin>>
    suspend fun loadPlugin(jarPath: Path): Either<PluginError, Plugin>
}



File: ./src/main/kotlin/org/blackerp/plugin/ExtensionRegistry.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.ExtensionRegistry

package org.blackerp.plugin

import arrow.core.Either

interface ExtensionRegistry {
    /**
     * Register an extension for a specific extension point
     * @param extension The extension implementation
     * @return Either a registration error or Unit on success
     */
    suspend fun <T : Extension> register(extension: T): Either<PluginError, Unit>
    
    /**
     * Get all registered extensions for a specific type
     * @return List of registered extensions
     */
    fun <T : Extension> getExtensions(type: Class<T>): List<T>
}



File: ./src/main/kotlin/org/blackerp/plugin/PluginId.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.PluginId

package org.blackerp.plugin

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class PluginId private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, PluginId> =
            when {
                !value.matches(Regex("^[a-z][a-z0-9-]*$")) ->
                    ValidationError.InvalidFormat(
                        "Plugin ID must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"
                    ).left()
                value.length !in 3..50 ->
                    ValidationError.InvalidLength("plugin id", 3, 50).left()
                else -> PluginId(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/plugin/registry/PluginRegistry.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.registry.PluginRegistry

package org.blackerp.plugin.registry

import arrow.core.Either
import org.blackerp.plugin.Plugin
import org.blackerp.plugin.PluginError
import org.blackerp.plugin.PluginId

interface PluginRegistry {
    suspend fun register(plugin: Plugin): Either<PluginError, Unit>
    suspend fun unregister(pluginId: PluginId): Either<PluginError, Unit>
    suspend fun getPlugin(pluginId: PluginId): Either<PluginError, Plugin>
    fun getPlugins(): List<Plugin>
}



File: ./src/main/kotlin/org/blackerp/plugin/registry/DefaultPluginRegistry.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.registry.DefaultPluginRegistry

package org.blackerp.plugin.registry

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.plugin.Plugin
import org.blackerp.plugin.PluginError
import org.blackerp.plugin.PluginId
import java.util.concurrent.ConcurrentHashMap

class DefaultPluginRegistry : PluginRegistry {
    private val plugins = ConcurrentHashMap<PluginId, Plugin>()

    override suspend fun register(plugin: Plugin): Either<PluginError, Unit> =
        when {
            plugins.containsKey(plugin.metadata.id) -> 
                PluginError.DuplicatePlugin(plugin.metadata.id.value).left()
            else -> {
                plugins[plugin.metadata.id] = plugin
                Unit.right()
            }
        }

    override suspend fun unregister(pluginId: PluginId): Either<PluginError, Unit> =
        plugins.remove(pluginId)?.let {
            Unit.right()
        } ?: PluginError.NotFound(pluginId.value).left()

    override suspend fun getPlugin(pluginId: PluginId): Either<PluginError, Plugin> =
        plugins[pluginId]?.right() ?: PluginError.NotFound(pluginId.value).left()

    override fun getPlugins(): List<Plugin> = plugins.values.toList()
}



File: ./src/main/kotlin/org/blackerp/plugin/Version.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.Version

package org.blackerp.plugin

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

data class Version private constructor(
    val major: Int,
    val minor: Int,
    val patch: Int
) : Comparable<Version> {
    override fun compareTo(other: Version): Int {
        return when {
            major != other.major -> major - other.major
            minor != other.minor -> minor - other.minor
            else -> patch - other.patch
        }
    }

    companion object {
        private val VERSION_PATTERN = Regex("^\\d+\\.\\d+\\.\\d+$")

        fun create(version: String): Either<ValidationError, Version> {
            if (!version.matches(VERSION_PATTERN)) {
                return ValidationError.InvalidFormat("Version must be in format major.minor.patch").left()
            }

            return try {
                val parts = version.split(".")
                if (parts.size != 3) {
                    ValidationError.InvalidFormat("Version must be in format major.minor.patch").left()
                } else {
                    Version(
                        major = parts[0].toInt(),
                        minor = parts[1].toInt(),
                        patch = parts[2].toInt()
                    ).right()
                }
            } catch (e: NumberFormatException) {
                ValidationError.InvalidFormat("Version components must be integers").left()
            }
        }
    }

    override fun toString(): String = "$major.$minor.$patch"
}


File: ./src/main/kotlin/org/blackerp/plugin/Extension.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.Extension

package org.blackerp.plugin

/**
 * Base interface for all plugin extensions
 */
interface Extension {
    val pluginId: PluginId
}



File: ./src/main/kotlin/org/blackerp/plugin/PluginMetadata.kt
// Classpath: src.main.kotlin.org.blackerp.plugin.PluginMetadata

package org.blackerp.plugin

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

data class PluginMetadata private constructor(
    val id: PluginId,
    val version: Version,
    val name: String,
    val description: String,
    val vendor: String
) {
    companion object {
        fun create(
            id: PluginId,
            version: Version,
            name: String,
            description: String,
            vendor: String
        ): Either<ValidationError, PluginMetadata> =
            when {
                name.isBlank() ->
                    ValidationError.Required("name").left()
                name.length !in 3..100 ->
                    ValidationError.InvalidLength("name", 3, 100).left()
                description.length > 500 ->
                    ValidationError.InvalidLength("description", 0, 500).left()
                vendor.isBlank() ->
                    ValidationError.Required("vendor").left()
                vendor.length !in 3..100 ->
                    ValidationError.InvalidLength("vendor", 3, 100).left()
                else -> PluginMetadata(id, version, name, description, vendor).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/ad/ADModule.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.ADModule

package org.blackerp.domain.ad

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.ad.value.ModuleName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.shared.ValidationError
import org.blackerp.plugin.Version

data class ADModule(
    override val metadata: EntityMetadata,
    val name: ModuleName,
    override val displayName: DisplayName,
    override val description: Description?,
    val version: Version
) : ADObject {
    companion object {
        fun create(params: CreateModuleParams): Either<ValidationError, ADModule> =
            ADModule(
                metadata = params.metadata,
                name = params.name,
                displayName = params.displayName,
                description = params.description,
                version = params.version
            ).right()
    }
}

data class CreateModuleParams(
    val metadata: EntityMetadata,
    val name: ModuleName,
    val displayName: DisplayName,
    val description: Description?,
    val version: Version
)



File: ./src/main/kotlin/org/blackerp/domain/ad/window/value/WindowName.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.window.value.WindowName


package org.blackerp.domain.ad.window.value

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class WindowName private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, WindowName> =
            when {
                !value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
                    ValidationError.InvalidFormat(
                        "Window name must start with lowercase letter and contain only lowercase letters, numbers, and underscores"
                    ).left()
                value.length !in 3..50 ->
                    ValidationError.InvalidLength("window name", 3, 50).left()
                else -> WindowName(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/ad/ADObject.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.ADObject

package org.blackerp.domain.ad

import org.blackerp.domain.DomainEntity
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description

interface ADObject : DomainEntity {
    val displayName: DisplayName
    val description: Description?
}



File: ./src/main/kotlin/org/blackerp/domain/ad/tab/TabOperations.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.tab.TabOperations

package org.blackerp.domain.ad.tab

import arrow.core.Either
import org.blackerp.domain.values.TableName
import java.util.UUID

interface TabOperations {
    suspend fun save(tab: ADTab): Either<TabError, ADTab>
    suspend fun findById(id: UUID): Either<TabError, ADTab?>
    suspend fun findByTable(tableName: TableName): Either<TabError, List<ADTab>>
    suspend fun delete(id: UUID): Either<TabError, Unit>
}


File: ./src/main/kotlin/org/blackerp/domain/ad/tab/CreateTabParams.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.tab.CreateTabParams


package org.blackerp.domain.ad.tab

import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.domain.ad.tab.value.TabName

data class CreateTabParams(
    val metadata: EntityMetadata,
    val name: TabName,
    val displayName: DisplayName,
    val description: Description?,
    val table: ADTable,
    val queryColumns: List<ColumnName>,
    val displayColumns: List<ColumnName>,
    val orderBy: List<OrderBySpec>
)



File: ./src/main/kotlin/org/blackerp/domain/ad/tab/OrderBySpec.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.tab.OrderBySpec


package org.blackerp.domain.ad.tab

import org.blackerp.domain.values.ColumnName

data class OrderBySpec(
    val column: ColumnName,
    val direction: SortDirection
)

enum class SortDirection {
    ASC, DESC;

    companion object {
        fun fromString(value: String): SortDirection =
            values().find { it.name.equals(value, ignoreCase = true) }
                ?: throw IllegalArgumentException("Invalid sort direction: $value")
    }
}



File: ./src/main/kotlin/org/blackerp/domain/ad/tab/value/TabName.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.tab.value.TabName


package org.blackerp.domain.ad.tab.value

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class TabName private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, TabName> =
            when {
                !value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
                    ValidationError.InvalidFormat(
                        "Tab name must start with lowercase letter and contain only lowercase letters, numbers, and underscores"
                    ).left()
                value.length !in 3..50 ->
                    ValidationError.InvalidLength("tab name", 3, 50).left()
                else -> TabName(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/ad/tab/TabError.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.tab.TabError


package org.blackerp.domain.ad.tab

import org.blackerp.domain.DomainException
import org.blackerp.shared.ValidationError

sealed class TabError(message: String) : DomainException(message) {
    data class ValidationFailed(val errors: List<ValidationError>) : 
        TabError("Validation failed: ${errors.joinToString { it.message }}")
    
    data class NotFound(val id: String) : 
        TabError("Tab not found: $id")
    
    data class DuplicateTab(val name: String) : 
        TabError("Tab already exists: $name")
}



File: ./src/main/kotlin/org/blackerp/domain/ad/tab/ADTab.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.tab.ADTab


package org.blackerp.domain.ad.tab

import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.ad.ADObject
import org.blackerp.domain.ad.tab.value.TabName
import org.blackerp.domain.values.*
import org.blackerp.domain.table.ADTable
import org.blackerp.shared.ValidationError

data class ADTab(
    override val metadata: EntityMetadata,
    val name: TabName,
    override val displayName: DisplayName,
    override val description: Description?,
    val table: ADTable,
    val queryColumns: List<ColumnName>,
    val displayColumns: List<ColumnName>,
    val orderBy: List<OrderBySpec>
) : ADObject {
    companion object {
        fun create(params: CreateTabParams): Either<TabError, ADTab> {
            val errors = mutableListOf<ValidationError>()
            
            // Validate query columns exist in table
            val invalidQueryColumns = params.queryColumns.filter { queryCol ->
                !params.table.columns.any { it.name == queryCol }
            }
            if (invalidQueryColumns.isNotEmpty()) {
                errors.add(ValidationError.InvalidValue(
                    "Query columns not found in table: ${invalidQueryColumns.joinToString { it.value }}"
                ))
            }
            
            // Validate display columns exist in table
            val invalidDisplayColumns = params.displayColumns.filter { displayCol ->
                !params.table.columns.any { it.name == displayCol }
            }
            if (invalidDisplayColumns.isNotEmpty()) {
                errors.add(ValidationError.InvalidValue(
                    "Display columns not found in table: ${invalidDisplayColumns.joinToString { it.value }}"
                ))
            }

            // Validate order by columns exist in table
            val invalidOrderColumns = params.orderBy.filter { orderSpec ->
                !params.table.columns.any { it.name == orderSpec.column }
            }
            if (invalidOrderColumns.isNotEmpty()) {
                errors.add(ValidationError.InvalidValue(
                    "Order by columns not found in table: ${invalidOrderColumns.joinToString { it.column.value }}"
                ))
            }

            if (errors.isNotEmpty()) {
                return TabError.ValidationFailed(errors).left()
            }

            return ADTab(
                metadata = params.metadata,
                name = params.name,
                displayName = params.displayName,
                description = params.description,
                table = params.table,
                queryColumns = params.queryColumns,
                displayColumns = params.displayColumns,
                orderBy = params.orderBy
            ).right()
        }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/ad/value/ModuleName.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.value.ModuleName

package org.blackerp.domain.ad.value

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class ModuleName private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, ModuleName> =
            when {
                !value.matches(Regex("^[a-z][a-z0-9-]*$")) ->
                    ValidationError.InvalidFormat(
                        "Module name must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"
                    ).left()
                value.length !in 3..50 ->
                    ValidationError.InvalidLength("module name", 3, 50).left()
                else -> ModuleName(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/ad/reference/value/ReferenceName.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.reference.value.ReferenceName


package org.blackerp.domain.ad.reference.value

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class ReferenceName private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, ReferenceName> =
            when {
                !value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
                    ValidationError.InvalidFormat(
                        "Reference name must start with lowercase letter and contain only lowercase letters, numbers, and underscores"
                    ).left()
                value.length !in 3..50 ->
                    ValidationError.InvalidLength("reference name", 3, 50).left()
                else -> ReferenceName(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/ad/reference/ADReference.kt
// Classpath: src.main.kotlin.org.blackerp.domain.ad.reference.ADReference


package org.blackerp.domain.ad.reference

import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.ad.ADObject
import org.blackerp.domain.ad.reference.value.ReferenceName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.shared.ValidationError

data class ADReference(
    override val metadata: EntityMetadata,
    val name: ReferenceName,
    override val displayName: DisplayName,
    override val description: Description?,
    val type: ReferenceType,
    val validationRule: ValidationRule?
) : ADObject {
    companion object {
        fun create(params: CreateReferenceParams): Either<ReferenceError, ADReference> =
            ADReference(
                metadata = params.metadata,
                name = params.name,
                displayName = params.displayName,
                description = params.description,
                type = params.type,
                validationRule = params.validationRule
            ).right()
    }
}

data class ValidationRule(
    val expression: String,
    val errorMessage: String
)

sealed interface ReferenceType {
    object List : ReferenceType
    data class Table(val tableName: String, val keyColumn: String, val displayColumn: String) : ReferenceType
    object Search : ReferenceType
    data class Custom(val validatorClass: String) : ReferenceType
}

data class CreateReferenceParams(
    val metadata: EntityMetadata,
    val name: ReferenceName,
    val displayName: DisplayName,
    val description: Description?,
    val type: ReferenceType,
    val validationRule: ValidationRule? = null
)

sealed class ReferenceError {
    data class ValidationFailed(val errors: List<ValidationError>) : ReferenceError()
    data class DuplicateReference(val name: String) : ReferenceError()
    data class ReferenceNotFound(val name: String) : ReferenceError()
}



File: ./src/main/kotlin/org/blackerp/domain/event/EventMetadata.kt
// Classpath: src.main.kotlin.org.blackerp.domain.event.EventMetadata

package org.blackerp.domain.event

import java.time.Instant
import java.util.UUID

data class EventMetadata(
    val id: UUID,
    val timestamp: Instant,
    val user: String
)



File: ./src/main/kotlin/org/blackerp/domain/event/DomainEvent.kt
// Classpath: src.main.kotlin.org.blackerp.domain.event.DomainEvent

package org.blackerp.domain.event

interface DomainEvent {
    val metadata: EventMetadata
}



File: ./src/main/kotlin/org/blackerp/domain/event/TableCreated.kt
// Classpath: src.main.kotlin.org.blackerp.domain.event.TableCreated

package org.blackerp.domain.event

import java.util.UUID

data class TableCreated(
    override val metadata: EventMetadata,
    val tableId: UUID,
    val tableName: String
) : DomainEvent



File: ./src/main/kotlin/org/blackerp/domain/DomainException.kt
// Classpath: src.main.kotlin.org.blackerp.domain.DomainException

package org.blackerp.domain

abstract class DomainException(message: String) : Exception(message)



File: ./src/main/kotlin/org/blackerp/domain/error/DomainError.kt
// Classpath: src.main.kotlin.org.blackerp.domain.error.DomainError

package org.blackerp.domain.error

sealed interface DomainError {
    val message: String
    
    data class ValidationError(
        override val message: String,
        val field: String? = null
    ) : DomainError

    data class NotFoundError(
        override val message: String,
        val id: String
    ) : DomainError
    
    data class SecurityError(
        override val message: String,
        val reason: String
    ) : DomainError
    
    data class CacheError(
        override val message: String,
        val cause: Throwable? = null
    ) : DomainError
    
    data class QueryError(
        override val message: String,
        val reason: String
    ) : DomainError

    data class SystemError(
        override val message: String,
        val cause: Throwable? = null
    ) : DomainError
}



File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantFilter.kt
// Classpath: src.main.kotlin.org.blackerp.domain.tenant.TenantFilter

package org.blackerp.domain.tenant

import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.shared.ValidationError

data class TenantFilter(val tenantId: String?) {
    companion object {
        fun create(tenantId: String?): Either<ValidationError, TenantFilter> =
            when {
                tenantId == null -> TenantFilter(null).right()
                !tenantId.matches(Regex("^[0-9a-fA-F-]{36}$")) ->
                    ValidationError.InvalidFormat("Invalid UUID format").left()
                else -> TenantFilter(tenantId).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantContext.kt
// Classpath: src.main.kotlin.org.blackerp.domain.tenant.TenantContext

package org.blackerp.domain.tenant

import java.util.UUID

object TenantContext {
    private val currentTenant = ThreadLocal<UUID>()
    
    fun getCurrentTenant(): UUID? = currentTenant.get()
    
    fun setCurrentTenant(tenantId: UUID) {
        currentTenant.set(tenantId)
    }
    
    fun clear() {
        currentTenant.remove()
    }
}



File: ./src/main/kotlin/org/blackerp/domain/tenant/TenantAware.kt
// Classpath: src.main.kotlin.org.blackerp.domain.tenant.TenantAware

package org.blackerp.domain.tenant

import java.util.UUID

interface TenantAware {
    val tenantId: UUID
}



File: ./src/main/kotlin/org/blackerp/domain/values/DataType.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.DataType


package org.blackerp.domain.values

enum class DataType {
    STRING,
    INTEGER,
    DECIMAL,
    BOOLEAN,
    DATE,
    TIMESTAMP,
    BINARY;

    companion object {
        fun fromString(value: String): DataType =
            values().find { it.name.equals(value, ignoreCase = true) }
                ?: throw IllegalArgumentException("Invalid data type: $value")
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/Precision.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.Precision


package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class Precision private constructor(val value: Int) {
    companion object {
        fun create(value: Int): Either<ValidationError, Precision> =
            when {
                value < 0 ->
                    ValidationError.InvalidValue("Precision cannot be negative").left()
                value > 20 ->
                    ValidationError.InvalidValue("Precision cannot exceed 20").left()
                else -> Precision(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/AccessLevel.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.AccessLevel

package org.blackerp.domain.values

enum class AccessLevel {
    SYSTEM,
    CLIENT,
    ORGANIZATION,
    CLIENT_ORGANIZATION;
    
    companion object {
        fun fromString(value: String): AccessLevel =
            values().find { it.name.equals(value, ignoreCase = true) }
                ?: throw IllegalArgumentException("Invalid access level: $value")
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/Description.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.Description

package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class Description private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, Description> =
            when {
                value.length > 255 ->
                    ValidationError.InvalidLength("description", 0, 255).left()
                else -> Description(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/Amount.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.Amount

package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError
import java.math.BigDecimal

@JvmInline
value class Amount private constructor(val value: BigDecimal) {
    companion object {
        fun create(value: BigDecimal): Either<ValidationError, Amount> =
            when {
                value < BigDecimal.ZERO ->
                    ValidationError.InvalidValue("Amount cannot be negative").left()
                else -> Amount(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/ColumnName.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.ColumnName

// File: src/main/kotlin/org/blackerp/domain/values/ColumnName.kt
package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class ColumnName private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, ColumnName> =
            when {
                !value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
                    ValidationError.InvalidFormat("Column name must start with lowercase letter and contain only lowercase letters, numbers, and underscores").left()
                value.length > 30 ->
                    ValidationError.InvalidLength("column name", 1, 30).left()
                else -> ColumnName(value).right()
            }
    }
}


File: ./src/main/kotlin/org/blackerp/domain/values/Scale.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.Scale


package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class Scale private constructor(val value: Int) {
    companion object {
        fun create(value: Int): Either<ValidationError, Scale> =
            when {
                value < 0 ->
                    ValidationError.InvalidValue("Scale cannot be negative").left()
                value > 10 ->
                    ValidationError.InvalidValue("Scale cannot exceed 10").left()
                else -> Scale(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/Length.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.Length


package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class Length private constructor(val value: Int) {
    companion object {
        fun create(value: Int): Either<ValidationError, Length> =
            when {
                value <= 0 ->
                    ValidationError.InvalidValue("Length must be positive").left()
                else -> Length(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/EventMetadata.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.EventMetadata

package org.blackerp.domain.values

import java.time.Instant
import java.util.UUID

data class EventMetadata(
    val id: UUID,
    val timestamp: Instant,
    val user: String
)



File: ./src/main/kotlin/org/blackerp/domain/values/TableName.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.TableName

package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class TableName private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, TableName> =
            when {
                !value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
                    ValidationError.InvalidFormat("Table name must start with lowercase letter and contain only lowercase letters, numbers, and underscores").left()
                else -> TableName(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/Currency.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.Currency

package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class Currency private constructor(val code: String) {
    companion object {
        fun create(code: String): Either<ValidationError, Currency> =
            when {
                !code.matches(Regex("^[A-Z]{3}$")) ->
                    ValidationError.InvalidFormat("Currency code must be 3 uppercase letters").left()
                else -> Currency(code).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/values/DisplayName.kt
// Classpath: src.main.kotlin.org.blackerp.domain.values.DisplayName

package org.blackerp.domain.values

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class DisplayName private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, DisplayName> =
            when {
                value.isBlank() -> 
                    ValidationError.Required("display name").left()
                value.length !in 1..60 ->
                    ValidationError.InvalidLength("display name", 1, 60).left()
                else -> DisplayName(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/transaction/Transaction.kt
// Classpath: src.main.kotlin.org.blackerp.domain.transaction.Transaction

package org.blackerp.domain.transaction

import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.Amount
import org.blackerp.domain.values.Currency
import java.time.Instant

data class Transaction(
    override val metadata: EntityMetadata,
    val amount: Amount,
    val currency: Currency,
    val timestamp: Instant,
    val description: String?
) : DomainEntity {
    companion object {
        fun create(params: CreateTransactionParams): Either<TransactionError, Transaction> =
            Transaction(
                metadata = params.metadata,
                amount = params.amount,
                currency = params.currency,
                timestamp = params.timestamp,
                description = params.description
            ).right()
    }
}

data class CreateTransactionParams(
    val metadata: EntityMetadata,
    val amount: Amount,
    val currency: Currency,
    val timestamp: Instant = Instant.now(),
    val description: String?
)



File: ./src/main/kotlin/org/blackerp/domain/transaction/TransactionError.kt
// Classpath: src.main.kotlin.org.blackerp.domain.transaction.TransactionError

package org.blackerp.domain.transaction

import org.blackerp.shared.ValidationError

sealed class TransactionError {
    abstract val message: String

    data class ValidationFailed(
        override val message: String,
        val errors: List<ValidationError>
    ) : TransactionError()
    
    data class InvalidAmount(
        val amount: String,
        override val message: String = "Invalid amount: $amount"
    ) : TransactionError()
    
    data class InvalidCurrency(
        val currency: String,
        override val message: String = "Invalid currency: $currency"
    ) : TransactionError()
}



File: ./src/main/kotlin/org/blackerp/domain/query/QueryResult.kt
// Classpath: src.main.kotlin.org.blackerp.domain.query.QueryResult

package org.blackerp.domain.query

import arrow.core.Either
import org.blackerp.domain.error.DomainError

data class QueryResult<T>(
    val items: List<T>,
    val total: Long,
    val page: Int,
    val pageSize: Int
)

interface QueryExecutor<T> {
    suspend fun execute(criteria: QueryCriteria, page: Int, pageSize: Int): Either<DomainError, QueryResult<T>>
}



File: ./src/main/kotlin/org/blackerp/domain/query/QueryCriteria.kt
// Classpath: src.main.kotlin.org.blackerp.domain.query.QueryCriteria

package org.blackerp.domain.query

sealed interface QueryCriteria {
    data class Equals(val field: String, val value: Any) : QueryCriteria
    data class Like(val field: String, val pattern: String) : QueryCriteria
    data class Between(val field: String, val start: Any, val end: Any) : QueryCriteria
    data class In(val field: String, val values: List<Any>) : QueryCriteria
    data class And(val criteria: List<QueryCriteria>) : QueryCriteria
    data class Or(val criteria: List<QueryCriteria>) : QueryCriteria
}



File: ./src/main/kotlin/org/blackerp/domain/DomainEntity.kt
// Classpath: src.main.kotlin.org.blackerp.domain.DomainEntity

package org.blackerp.domain

interface DomainEntity {
    val metadata: EntityMetadata
}



File: ./src/main/kotlin/org/blackerp/domain/table/TableOperations.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.TableOperations

// File: src/main/kotlin/org/blackerp/domain/table/TableOperations.kt
package org.blackerp.domain.table

import arrow.core.Either
import java.util.UUID

interface TableOperations {
    /**
     * Saves a table to the store
     * @param table The table to save
     * @return Either an error or the saved table
     */
    suspend fun save(table: ADTable): Either<TableError, ADTable>
    
    /**
     * Finds a table by its ID
     * @param id The UUID of the table
     * @return Either an error or the found table (null if not found)
     */
    suspend fun findById(id: UUID): Either<TableError, ADTable?>
    
    /**
     * Finds a table by its name
     * @param name The name of the table
     * @return Either an error or the found table (null if not found)
     */
    suspend fun findByName(name: String): Either<TableError, ADTable?>
    
    /**
     * Deletes a table by its ID
     * @param id The UUID of the table to delete
     * @return Either an error or Unit on success
     */
    suspend fun delete(id: UUID): Either<TableError, Unit>
}



File: ./src/main/kotlin/org/blackerp/domain/table/ADTable.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.ADTable

package org.blackerp.domain.table

import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.domain.values.AccessLevel
import org.blackerp.domain.table.ColumnDefinition

data class ADTable(
    override val metadata: EntityMetadata,
    val name: TableName,
    val displayName: DisplayName,
    val description: Description?,
    val accessLevel: AccessLevel,
    val columns: List<ColumnDefinition> // Added columns property
) : DomainEntity {
    companion object {
        fun create(params: CreateTableParams): Either<TableError, ADTable> =
            ADTable(
                metadata = params.metadata,
                name = params.name,
                displayName = params.displayName,
                description = params.description,
                accessLevel = params.accessLevel,
                columns = params.columns // Initialize columns
            ).right()
    }
}

data class CreateTableParams(
    val metadata: EntityMetadata,
    val name: TableName,
    val displayName: DisplayName,
    val description: Description?,
    val accessLevel: AccessLevel,
    val columns: List<ColumnDefinition>  
)



File: ./src/main/kotlin/org/blackerp/domain/table/extension/TableExtensionPoint.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.extension.TableExtensionPoint

package org.blackerp.domain.table.extension

import arrow.core.Either
import org.blackerp.domain.table.ADTable
import org.blackerp.plugin.Extension
import org.blackerp.plugin.PluginError

interface TableExtensionPoint {
    suspend fun beforeCreate(table: ADTable): Either<PluginError, ADTable>
    suspend fun afterCreate(table: ADTable)
    suspend fun beforeUpdate(table: ADTable): Either<PluginError, ADTable>
    suspend fun afterUpdate(table: ADTable)
    suspend fun beforeDelete(table: ADTable): Either<PluginError, Unit>
    suspend fun afterDelete(table: ADTable)
}



File: ./src/main/kotlin/org/blackerp/domain/table/extension/TableExtension.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.extension.TableExtension

package org.blackerp.domain.table.extension

import org.blackerp.plugin.Extension
import org.blackerp.plugin.PluginId

interface TableExtension : Extension, TableExtensionPoint {
    override val pluginId: PluginId
}



File: ./src/main/kotlin/org/blackerp/domain/table/CreateColumnParams.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.CreateColumnParams

package org.blackerp.domain.table

import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.values.DataType
import org.blackerp.domain.values.Length
import org.blackerp.domain.values.Precision
import org.blackerp.domain.values.Scale
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description

// Unified CreateColumnParams definition

data class CreateColumnParams(
    val metadata: EntityMetadata,
    val name: ColumnName,
    val displayName: DisplayName,
    val description: Description?,
    val dataType: DataType,
    val length: Length?,
    val precision: Precision?,
    val scale: Scale?,
    val mandatory: Boolean = false,
    val defaultValue: String? = null
)



File: ./src/main/kotlin/org/blackerp/domain/table/TenantAwareTable.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.TenantAwareTable

package org.blackerp.domain.table

import org.blackerp.domain.tenant.TenantAware
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.*
import java.util.UUID

data class TenantAwareTable(
    override val metadata: EntityMetadata,
    override val tenantId: UUID,
    val delegate: ADTable
) : DomainEntity by delegate, TenantAware {
    val name: TableName
        get() = delegate.name

    val displayName: DisplayName
        get() = delegate.displayName
    companion object {
        fun from(table: ADTable, tenantId: UUID): TenantAwareTable =
            TenantAwareTable(
                metadata = table.metadata,
                tenantId = tenantId,
                delegate = table
            )
    }
}



File: ./src/main/kotlin/org/blackerp/domain/table/constraint/TableConstraint.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.constraint.TableConstraint

package org.blackerp.domain.table.constraint

import arrow.core.Either
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.shared.ValidationError

interface TableConstraint : DomainEntity {
    // Make the interface method suspend as well
    suspend fun validate(table: TableDefinition): Either<ValidationError, Unit>
}


File: ./src/main/kotlin/org/blackerp/domain/table/constraint/UniqueConstraint.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.constraint.UniqueConstraint


package org.blackerp.domain.table.constraint

import org.blackerp.domain.table.definition.TableDefinition
import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.shared.ValidationError

data class UniqueConstraint(
    override val metadata: EntityMetadata,
    val columns: List<ColumnName>
) : TableConstraint {
    override suspend fun validate(table: TableDefinition): Either<ValidationError, Unit> {
        val tableColumns = table.columns.map { it.name }
        val invalidColumns = columns.filter { it !in tableColumns }
        
        return if (invalidColumns.isEmpty()) {
            Unit.right()
        } else {
            ValidationError.InvalidValue(
                "Columns not found in table: ${invalidColumns.joinToString { it.value }}"
            ).left()
        }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/table/constraint/NotNullConstraint.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.constraint.NotNullConstraint

package org.blackerp.domain.table.constraint

import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.domain.EntityMetadata 
import org.blackerp.domain.values.ColumnName
import org.blackerp.shared.ValidationError
import org.blackerp.domain.table.definition.TableDefinition

data class NotNullConstraint(
    override val metadata: EntityMetadata,
    val column: ColumnName
) : TableConstraint {
    override suspend fun validate(table: TableDefinition): Either<ValidationError, Unit> {
        val columnExists = table.columns.any { it.name == column }
        
        return if (columnExists) {
            Unit.right()
        } else {
            ValidationError.InvalidValue("Column not found in table: ${column.value}").left()
        }
    }
}


File: ./src/main/kotlin/org/blackerp/domain/table/constraint/ReferenceConstraint.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.constraint.ReferenceConstraint

package org.blackerp.domain.table.constraint

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.*
import org.blackerp.domain.table.TableOperations
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.shared.ValidationError
import org.blackerp.shared.ReferenceValidation

data class ReferenceConstraint(
    override val metadata: EntityMetadata,
    val column: ColumnName,
    val referenceTable: TableName,
    val referenceColumn: ColumnName,
    private val tableOperations: TableOperations
) : TableConstraint {
    override suspend fun validate(table: TableDefinition): Either<ValidationError, Unit> {
        // 1. Verify source column exists
        val sourceColumn = table.columns.find { it.name == column }
            ?: return ReferenceValidation.ColumnNotFound(column.value).left()

        // 2. Find reference table
        when (val refTableResult = tableOperations.findByName(referenceTable.value)) {
            is Either.Left -> return ReferenceValidation.ReferenceTableNotFound(referenceTable.value).left()
            is Either.Right -> {
                val refTable = refTableResult.value 
                    ?: return ReferenceValidation.ReferenceTableNotFound(referenceTable.value).left()

                // Convert ADTable to TableDefinition
                val refTableDef = toTableDefinition(refTable)

                // 3. Verify reference column exists
                val refColumn = refTableDef.columns.find { it.name == referenceColumn }
                    ?: return ReferenceValidation.ReferenceColumnNotFound(
                        referenceTable.value,
                        referenceColumn.value
                    ).left()

                // 4. Check type compatibility
                if (sourceColumn.dataType != refColumn.dataType) {
                    return ReferenceValidation.IncompatibleTypes(
                        sourceColumn.name.value,
                        sourceColumn.dataType.name,
                        refColumn.name.value,
                        refColumn.dataType.name
                    ).left()
                }

                // 5. Check length/precision compatibility for certain types
                when (sourceColumn.dataType) {
                    DataType.STRING -> {
                        val sourceLength = sourceColumn.length?.value ?: 0
                        val refLength = refColumn.length?.value ?: 0
                        if (sourceLength > refLength) {
                            return ValidationError.InvalidValue(
                                "Source column length ($sourceLength) cannot be greater than reference column length ($refLength)"
                            ).left()
                        }
                    }
                    DataType.DECIMAL -> {
                        val sourcePrecision = sourceColumn.precision?.value ?: 0
                        val refPrecision = refColumn.precision?.value ?: 0
                        if (sourcePrecision > refPrecision) {
                            return ValidationError.InvalidValue(
                                "Source column precision ($sourcePrecision) cannot be greater than reference column precision ($refPrecision)"
                            ).left()
                        }
                        val sourceScale = sourceColumn.scale?.value ?: 0
                        val refScale = refColumn.scale?.value ?: 0
                        if (sourceScale > refScale) {
                            return ValidationError.InvalidValue(
                                "Source column scale ($sourceScale) cannot be greater than reference column scale ($refScale)"
                            ).left()
                        }
                    }
                    else -> Unit
                }

                return Unit.right()
            }
        }
    }

    private fun toTableDefinition(table: ADTable): TableDefinition {
        return TableDefinition(
            metadata = table.metadata,
            name = table.name,
            displayName = table.displayName,
            description = table.description,
            accessLevel = table.accessLevel,
            columns = table.columns,
            constraints = emptyList(),
            behaviors = emptyList()
        )
    }
}


File: ./src/main/kotlin/org/blackerp/domain/table/TableCreated.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.TableCreated

package org.blackerp.domain.table

import org.blackerp.domain.DomainEvent
import org.blackerp.domain.values.EventMetadata
import java.util.UUID

data class TableCreated(
    override val metadata: EventMetadata,
    val tableId: UUID,
    val tableName: String
) : DomainEvent



File: ./src/main/kotlin/org/blackerp/domain/table/TableError.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.TableError

package org.blackerp.domain.table

import org.blackerp.domain.DomainException
import org.blackerp.shared.ValidationError

sealed class TableError(message: String) : DomainException(message) {
    data class ValidationFailed(val errors: List<ValidationError>) : 
        TableError("Validation failed: ${errors.joinToString { it.message }}")
    
    data class StorageError(override val cause: Throwable) : 
        TableError("Storage error: ${cause.message}")
    
    data class DuplicateTable(val name: String) : 
        TableError("Table already exists: $name")
    
    data class NotFound(val id: String) : 
        TableError("Table not found: $id")
    
    data class ConcurrentModification(val id: String) : 
        TableError("Concurrent modification detected for table: $id")
}



File: ./src/main/kotlin/org/blackerp/domain/table/definition/TableDefinition.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.definition.TableDefinition

package org.blackerp.domain.table.definition

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.*
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.constraint.TableConstraint
import org.blackerp.domain.table.behavior.TableBehavior
import org.blackerp.shared.ValidationError
import kotlinx.coroutines.runBlocking

data class TableDefinition(
    override val metadata: EntityMetadata,
    val name: TableName,
    val displayName: DisplayName,
    val description: Description?,
    val accessLevel: AccessLevel,
    val columns: List<ColumnDefinition>,
    val constraints: List<TableConstraint>,
    val behaviors: List<TableBehavior>
) : DomainEntity {

    companion object {
        suspend fun create(params: CreateTableParams): Either<TableError, TableDefinition> {
            val errors = mutableListOf<ValidationError>()
            
            // Basic validation
            if (params.columns.isEmpty()) {
                errors.add(ValidationError.Required("at least one column"))
            }

            // Check for duplicate column names
            val duplicateColumns = params.columns
                .groupBy { it.name.value }
                .filter { it.value.size > 1 }
                .keys
            
            if (duplicateColumns.isNotEmpty()) {
                errors.add(ValidationError.InvalidValue(
                    "Duplicate column names: ${duplicateColumns.joinToString()}"
                ))
            }

            if (errors.isNotEmpty()) {
                return TableError.ValidationFailed(errors).left()
            }

            val table = TableDefinition(
                metadata = params.metadata,
                name = params.name,
                displayName = params.displayName,
                description = params.description,
                accessLevel = params.accessLevel,
                columns = params.columns,
                constraints = params.constraints,
                behaviors = params.behaviors
            )

            // Validate all constraints
            val constraintErrors = table.constraints
                .map { it.validate(table) }
                .filter { it.isLeft() }
                .flatMap { (it as Either.Left).value.let { listOf(it) } }

            if (constraintErrors.isNotEmpty()) {
                return TableError.ValidationFailed(constraintErrors).left()
            }

            return table.right()
        }
    }

    suspend fun validate(): Either<TableError, Unit> {
        val errors = constraints
            .map { it.validate(this) }
            .filter { it.isLeft() }
            .flatMap { (it as Either.Left).value.let { listOf(it) } }

        return if (errors.isEmpty()) {
            Unit.right()
        } else {
            TableError.ValidationFailed(errors).left()
        }
    }
}

data class CreateTableParams(
    val metadata: EntityMetadata,
    val name: TableName,
    val displayName: DisplayName,
    val description: Description?,
    val accessLevel: AccessLevel,
    val columns: List<ColumnDefinition>,
    val constraints: List<TableConstraint> = emptyList(),
    val behaviors: List<TableBehavior> = emptyList()
)



File: ./src/main/kotlin/org/blackerp/domain/table/behavior/TableBehavior.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.behavior.TableBehavior


package org.blackerp.domain.table.behavior

import org.blackerp.domain.table.definition.TableDefinition
import arrow.core.Either
import org.blackerp.domain.DomainEntity 
import org.blackerp.domain.table.TableError

interface TableBehavior : DomainEntity {
    fun beforeSave(table: TableDefinition): Either<TableError, TableDefinition>
    fun afterSave(table: TableDefinition)
    fun beforeDelete(table: TableDefinition): Either<TableError, Unit>
    fun afterDelete(table: TableDefinition)
}



File: ./src/main/kotlin/org/blackerp/domain/table/TableId.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.TableId

package org.blackerp.domain.table

import java.util.UUID

@JvmInline
value class TableId(val value: UUID)



File: ./src/main/kotlin/org/blackerp/domain/table/ColumnDefinition.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.ColumnDefinition


package org.blackerp.domain.table

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.domain.values.DataType
import org.blackerp.domain.values.Length
import org.blackerp.domain.values.Precision
import org.blackerp.domain.values.Scale
import org.blackerp.shared.ValidationError

data class ColumnDefinition(
    override val metadata: EntityMetadata,
    val name: ColumnName,
    val displayName: DisplayName,
    val description: Description?,
    val dataType: DataType,
    val length: Length?,
    val precision: Precision?,
    val scale: Scale?,
    val mandatory: Boolean = false,
    val defaultValue: String? = null
) : DomainEntity {

    companion object {
        fun create(params: CreateColumnParams): Either<ColumnError, ColumnDefinition> {
            val errors = mutableListOf<ValidationError>()

            when (params.dataType) {
                DataType.STRING -> {
                    if (params.length == null) 
                        errors.add(ValidationError.Required("length for string type"))
                    if (params.precision != null || params.scale != null) 
                        errors.add(ValidationError.InvalidValue("string type cannot have precision or scale"))
                }
                DataType.DECIMAL -> {
                    if (params.precision == null) 
                        errors.add(ValidationError.Required("precision for decimal type"))
                    if (params.length != null) 
                        errors.add(ValidationError.InvalidValue("decimal type cannot have length"))
                }
                else -> {
                    if (params.length != null || params.precision != null || params.scale != null) 
                        errors.add(ValidationError.InvalidValue("type ${params.dataType} cannot have length, precision, or scale"))
                }
            }

            if (errors.isNotEmpty()) {
                return ColumnError.ValidationFailed(errors).left()
            }

            return ColumnDefinition(
                metadata = params.metadata,
                name = params.name,
                displayName = params.displayName,
                description = params.description,
                dataType = params.dataType,
                length = params.length,
                precision = params.precision,
                scale = params.scale,
                mandatory = params.mandatory,
                defaultValue = params.defaultValue
            ).right()
        }
    }
}

sealed interface ColumnError {
    data class ValidationFailed(val errors: List<ValidationError>) : ColumnError
    data class NotFound(val columnName: String) : ColumnError
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/event/RelationshipEvent.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.event.RelationshipEvent

package org.blackerp.domain.table.relationship.event

import org.blackerp.domain.event.DomainEvent
import org.blackerp.domain.event.EventMetadata
import java.util.UUID

sealed interface RelationshipEvent : DomainEvent

data class RelationshipCreated(
    override val metadata: EventMetadata,
    val relationshipId: UUID,
    val sourceTable: String,
    val targetTable: String
) : RelationshipEvent

data class RelationshipDeleted(
    override val metadata: EventMetadata,
    val relationshipId: UUID
) : RelationshipEvent



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/CreateRelationshipParams.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.CreateRelationshipParams

package org.blackerp.domain.table.relationship

import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.value.RelationType
import org.blackerp.domain.table.relationship.value.RelationshipName
import org.blackerp.domain.table.relationship.value.DeleteRule
import org.blackerp.domain.table.relationship.value.UpdateRule

data class CreateRelationshipParams(
    val metadata: EntityMetadata,
    val name: RelationshipName,
    val sourceTable: TableName,
    val targetTable: TableName,
    val type: RelationType,
    val sourceColumn: ColumnName,
    val targetColumn: ColumnName,
    val deleteRule: DeleteRule = DeleteRule.RESTRICT,    // Added this
    val updateRule: UpdateRule = UpdateRule.RESTRICT,    // Added this
    val junctionTable: TableName? = null, 
    val constraints: List<RelationshipConstraint> = emptyList()
)



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/TableRelationship.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.TableRelationship

package org.blackerp.domain.table.relationship

import arrow.core.Either
import arrow.core.right
import arrow.core.left
import org.blackerp.domain.DomainEntity
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.TableError
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.value.RelationType
import org.blackerp.domain.table.relationship.value.RelationshipName
import org.blackerp.domain.table.relationship.value.DeleteRule
import org.blackerp.domain.table.relationship.value.UpdateRule
import org.blackerp.shared.ValidationError

data class TableRelationship(
    override val metadata: EntityMetadata,
    val name: RelationshipName,
    val sourceTable: TableName,
    val targetTable: TableName,
    val type: RelationType,
    val sourceColumn: ColumnName,
    val targetColumn: ColumnName,
    val constraints: List<RelationshipConstraint>,
    val deleteRule: DeleteRule = DeleteRule.RESTRICT,    // Added this
    val updateRule: UpdateRule = UpdateRule.RESTRICT     // Added this
) : DomainEntity {
    companion object {
        fun create(params: CreateRelationshipParams): Either<TableError, TableRelationship> {
            // Basic validation first
            val errors = mutableListOf<ValidationError>()
            
            // Validate relationship consistency
            when (params.type) {
                RelationType.ONE_TO_ONE, RelationType.ONE_TO_MANY -> {
                    if (params.sourceTable == params.targetTable && params.sourceColumn == params.targetColumn) {
                        errors.add(ValidationError.InvalidValue("Self-referential relationships must use different column names"))
                    }
                }
                RelationType.MANY_TO_MANY -> {
                    // Many-to-many relationships might need additional validation
                    // Consider junction table requirements
                }
            }

            if (errors.isNotEmpty()) {
                return TableError.ValidationFailed(errors).left()
            }

            return TableRelationship(
                metadata = params.metadata,
                name = params.name,
                sourceTable = params.sourceTable,
                targetTable = params.targetTable,
                type = params.type,
                sourceColumn = params.sourceColumn,
                targetColumn = params.targetColumn,
                constraints = params.constraints
            ).right()
        }
    }

    suspend fun validate(): Either<TableError, Unit> {
        val errors = constraints
            .map { it.validate(this) }
            .filter { it.isLeft() }
            .flatMap { (it as Either.Left).value.let { listOf(it) } }

        return if (errors.isEmpty()) {
            Unit.right()
        } else {
            TableError.ValidationFailed(errors).left()
        }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/RelationshipConstraint.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.RelationshipConstraint

package org.blackerp.domain.table.relationship

import arrow.core.Either
import org.blackerp.domain.DomainEntity
import org.blackerp.shared.ValidationError

interface RelationshipConstraint : DomainEntity {
    suspend fun validate(relationship: TableRelationship): Either<ValidationError, Unit>
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/constraint/IndexConstraint.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.constraint.IndexConstraint

package org.blackerp.domain.table.relationship.constraint

import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.RelationshipConstraint
import org.blackerp.domain.table.relationship.TableRelationship
import org.blackerp.shared.ValidationError

data class IndexConstraint(
    override val metadata: EntityMetadata,
    val columns: List<ColumnName>,
    val unique: Boolean = false
) : RelationshipConstraint {
    override suspend fun validate(relationship: TableRelationship): Either<ValidationError, Unit> = Unit.right()
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/RelationshipName.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.value.RelationshipName

package org.blackerp.domain.table.relationship.value

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.shared.ValidationError

@JvmInline
value class RelationshipName private constructor(val value: String) {
    companion object {
        fun create(value: String): Either<ValidationError, RelationshipName> =
            when {
                !value.matches(Regex("^[a-z][a-z0-9_]*$")) ->
                    ValidationError.InvalidFormat(
                        "Relationship name must start with lowercase letter and contain only lowercase letters, numbers, and underscores"
                    ).left()
                value.length !in 3..50 ->
                    ValidationError.InvalidLength("relationship name", 3, 50).left()
                else -> RelationshipName(value).right()
            }
    }
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/RelationType.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.value.RelationType

package org.blackerp.domain.table.relationship.value

enum class RelationType {
    ONE_TO_ONE,
    ONE_TO_MANY,
    MANY_TO_MANY;

    companion object {
        fun fromString(value: String): RelationType =
            values().find { it.name.equals(value, ignoreCase = true) }
                ?: throw IllegalArgumentException("Invalid relationship type: $value")
    }
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/DeleteRule.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.value.DeleteRule

package org.blackerp.domain.table.relationship.value

enum class DeleteRule {
    RESTRICT,
    CASCADE,
    SET_NULL,
    NO_ACTION;
    
    companion object {
        fun fromString(value: String): DeleteRule =
            values().find { it.name.equals(value, ignoreCase = true) }
                ?: throw IllegalArgumentException("Invalid delete rule: $value")
    }
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/value/UpdateRule.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.value.UpdateRule

package org.blackerp.domain.table.relationship.value

enum class UpdateRule {
    RESTRICT,
    CASCADE,
    SET_NULL,
    NO_ACTION;
    
    companion object {
        fun fromString(value: String): UpdateRule =
            values().find { it.name.equals(value, ignoreCase = true) }
                ?: throw IllegalArgumentException("Invalid update rule: $value")
    }
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/RelationshipOperations.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.RelationshipOperations

package org.blackerp.domain.table.relationship

import arrow.core.Either
import org.blackerp.domain.table.TableError
import org.blackerp.domain.values.TableName
import java.util.UUID

interface RelationshipOperations {
    suspend fun save(relationship: TableRelationship): Either<TableError, TableRelationship>
    suspend fun findById(id: UUID): Either<TableError, TableRelationship?>
    suspend fun findByTable(tableName: TableName): Either<TableError, List<TableRelationship>>
    suspend fun delete(id: UUID): Either<TableError, Unit>
}



File: ./src/main/kotlin/org/blackerp/domain/table/relationship/TableRelationshipError.kt
// Classpath: src.main.kotlin.org.blackerp.domain.table.relationship.TableRelationshipError

package org.blackerp.domain.table.relationship

import org.blackerp.shared.ValidationError

sealed interface TableRelationshipError {
    data class ValidationFailed(val errors: List<ValidationError>) : TableRelationshipError
    data class DuplicateRelationship(val name: String) : TableRelationshipError
    data class InvalidRelationType(val message: String) : TableRelationshipError
    data class CircularReference(val tableName: String) : TableRelationshipError
}



File: ./src/main/kotlin/org/blackerp/domain/DomainEvent.kt
// Classpath: src.main.kotlin.org.blackerp.domain.DomainEvent

package org.blackerp.domain

import org.blackerp.domain.values.EventMetadata

interface DomainEvent {
    val metadata: EventMetadata
}



File: ./src/main/kotlin/org/blackerp/domain/EntityMetadata.kt
// Classpath: src.main.kotlin.org.blackerp.domain.EntityMetadata

package org.blackerp.domain

import org.blackerp.shared.TimeBasedId
import java.time.Instant
import java.util.UUID

data class EntityMetadata(
    val id: UUID = TimeBasedId.generate(),
    val created: Instant = Instant.now(),
    val createdBy: String,
    val updated: Instant = Instant.now(),
    val updatedBy: String,
    val version: Int = 0,
    val active: Boolean = true
)



File: ./src/main/kotlin/org/blackerp/domain/security/SecurityContext.kt
// Classpath: src.main.kotlin.org.blackerp.domain.security.SecurityContext

package org.blackerp.domain.security

import arrow.core.Either
import org.blackerp.domain.error.DomainError
import java.util.UUID

interface SecurityContext {
    suspend fun getCurrentUser(): Either<DomainError, User>
    suspend fun hasPermission(permission: Permission): Either<DomainError, Boolean>
    suspend fun authenticate(credentials: Credentials): Either<DomainError, User>
}

data class User(
    val id: UUID,
    val username: String,
    val roles: Set<Role>,
    val tenantId: UUID?
)

data class Role(
    val id: UUID,
    val name: String,
    val permissions: Set<Permission>
)

data class Permission(
    val id: UUID,
    val name: String,
    val resource: String,
    val action: String
)

sealed interface Credentials {
    data class Basic(val username: String, val password: String) : Credentials
    data class Token(val token: String) : Credentials
}



File: ./src/main/kotlin/org/blackerp/api/mappers/TableMapper.kt
// Classpath: src.main.kotlin.org.blackerp.api.mappers.TableMapper

package org.blackerp.api.mappers

import org.springframework.stereotype.Component
import org.blackerp.api.dto.CreateTableRequest
import org.blackerp.api.dto.CreateColumnRequest
import org.blackerp.api.dto.TableResponse
import org.blackerp.application.table.CreateTableCommand
import org.blackerp.application.table.CreateColumnCommand
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.values.AccessLevel
import org.blackerp.domain.values.DataType

@Component
class TableMapper {
    fun toCommand(request: CreateTableRequest): CreateTableCommand =
        CreateTableCommand(
            name = request.name,
            displayName = request.displayName,
            description = request.description,
            accessLevel = AccessLevel.valueOf(request.accessLevel.uppercase()),
            createdBy = "system",
            columns = request.columns.map { toColumnCommand(it) }
        )

    private fun toColumnCommand(request: CreateColumnRequest): CreateColumnCommand =
        CreateColumnCommand(
            name = request.name,
            displayName = request.displayName,
            description = request.description,
            dataType = DataType.valueOf(request.dataType.uppercase()),
            length = request.length,
            precision = request.precision,
            scale = request.scale
        )

    fun toResponse(table: ADTable): TableResponse =
        TableResponse(
            id = table.metadata.id,
            name = table.name.value,
            displayName = table.displayName.value,
            description = table.description?.value,
            accessLevel = table.accessLevel.name
        )
}


File: ./src/main/kotlin/org/blackerp/api/dto/TableResponse.kt
// Classpath: src.main.kotlin.org.blackerp.api.dto.TableResponse

package org.blackerp.api.dto

import java.util.UUID

data class TableResponse(
    val id: UUID,
    val name: String,
    val displayName: String,
    val description: String?,
    val accessLevel: String
)



File: ./src/main/kotlin/org/blackerp/api/dto/CreateTableRequest.kt
// Classpath: src.main.kotlin.org.blackerp.api.dto.CreateTableRequest

package org.blackerp.api.dto

import jakarta.validation.constraints.*
import jakarta.validation.Valid

data class CreateTableRequest(
    @field:NotBlank
    @field:Pattern(regexp = "^[a-z][a-z0-9_]*$")
    @field:Size(min = 1, max = 60)
    val name: String,
    
    @field:NotBlank
    @field:Size(min = 1, max = 60)
    val displayName: String,
    
    val description: String?,
    
    @field:NotBlank
    val accessLevel: String,
    
    @field:Valid
    @field:NotEmpty
    val columns: List<CreateColumnRequest>
)

data class CreateColumnRequest(
    @field:NotBlank
    @field:Pattern(regexp = "^[a-z][a-z0-9_]*$")
    val name: String,
    
    @field:NotBlank
    val displayName: String,
    
    val description: String?,
    
    @field:NotNull
    val dataType: String,
    
    val length: Int?,
    val precision: Int?,
    val scale: Int?
)


File: ./src/main/kotlin/org/blackerp/api/error/ErrorHandler.kt
// Classpath: src.main.kotlin.org.blackerp.api.error.ErrorHandler

package org.blackerp.api.error

import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.blackerp.domain.DomainException
import org.blackerp.domain.table.TableError
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.http.HttpStatus

@ControllerAdvice
class ErrorHandler {
    @ExceptionHandler(DomainException::class)
    fun handleDomainException(ex: DomainException): ResponseEntity<ErrorResponse> =
        when(ex) {
            is TableError.ValidationFailed -> ResponseEntity.badRequest()
                .body(ErrorResponse("Validation failed", ex.errors.map { it.message }))
            is TableError.NotFound -> ResponseEntity.notFound()
                .build()
            else -> ResponseEntity.internalServerError()
                .body(ErrorResponse("Internal error", listOf(ex.message ?: ex.toString())))
        }

    @ExceptionHandler(MethodArgumentNotValidException::class)
    fun handleValidationExceptions(ex: MethodArgumentNotValidException): ResponseEntity<ErrorResponse> =
        ResponseEntity.badRequest().body(
            ErrorResponse(
                message = "Validation failed",
                details = ex.bindingResult.fieldErrors.map { 
                    "${it.field}: ${it.defaultMessage}"
                }
            )
        )
}

data class ErrorResponse(
    val message: String,
    val details: List<String>
)



File: ./src/main/kotlin/org/blackerp/api/controllers/TableController.kt
// Classpath: src.main.kotlin.org.blackerp.api.controllers.TableController

// File: src/main/kotlin/org/blackerp/api/controllers/TableController.kt
package org.blackerp.api.controllers

import org.springframework.web.bind.annotation.*
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.api.dto.CreateTableRequest
import org.blackerp.api.dto.TableResponse
import org.blackerp.api.mappers.TableMapper
import jakarta.validation.Valid
import org.springframework.http.ResponseEntity
import java.util.UUID

@RestController
@RequestMapping("/api/tables")
class TableController(
    private val createTableUseCase: CreateTableUseCase,
    private val tableMapper: TableMapper
) {
    @PostMapping
    suspend fun createTable(
        @Valid @RequestBody request: CreateTableRequest
    ): ResponseEntity<TableResponse> =
        createTableUseCase
            .execute(tableMapper.toCommand(request))
            .fold(
                { throw it },
                { ResponseEntity.ok(tableMapper.toResponse(it)) }
            )
}


File: ./src/main/kotlin/org/blackerp/application/table/CreateTableUseCase.kt
// Classpath: src.main.kotlin.org.blackerp.application.table.CreateTableUseCase

// File: src/main/kotlin/org/blackerp/application/table/CreateTableUseCase.kt
package org.blackerp.application.table

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.CreateTableParams
import org.blackerp.domain.table.CreateColumnParams
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.TableOperations
import org.blackerp.domain.values.*
import org.blackerp.domain.event.DomainEvent
import org.blackerp.domain.event.TableCreated
import org.blackerp.domain.event.EventMetadata
import org.blackerp.infrastructure.event.EventPublisher
import org.blackerp.shared.ValidationError
import java.time.Instant
import java.util.UUID
import org.springframework.stereotype.Service

@Service
class CreateTableUseCase(
    private val operations: TableOperations,
    private val eventPublisher: EventPublisher
) {
    suspend fun execute(command: CreateTableCommand): Either<TableError, ADTable> {
        val errors = mutableListOf<ValidationError>()
        
        val name = TableName.create(command.name).fold(
            { errors.add(it); null },
            { it }
        )
        
        val displayName = DisplayName.create(command.displayName).fold(
            { errors.add(it); null },
            { it }
        )
        
        val description = command.description?.let { desc ->
            Description.create(desc).fold(
                { errors.add(it); null },
                { it }
            )
        }

        // If name or displayName is null, return validation errors immediately
        if (name == null || displayName == null) {
            return TableError.ValidationFailed(errors).left()
        }

        val metadata = EntityMetadata(
            createdBy = command.createdBy,
            updatedBy = command.createdBy
        )

        val columns = command.columns.mapNotNull { columnCommand ->
            ColumnDefinition.create(
                CreateColumnParams(
                    metadata = metadata,
                    name = ColumnName.create(columnCommand.name).getOrNull()!!,
                    displayName = DisplayName.create(columnCommand.displayName).getOrNull()!!, 
                    description = columnCommand.description?.let { Description.create(it).getOrNull() }, 
                    dataType = columnCommand.dataType,
                    length = columnCommand.length?.let { Length.create(it).getOrNull() },
                    precision = columnCommand.precision?.let { Precision.create(it).getOrNull() },
                    scale = columnCommand.scale?.let { Scale.create(it).getOrNull() }
                )
            ).getOrNull()
        }

        if (errors.isNotEmpty()) {
            return TableError.ValidationFailed(errors).left()
        }

        val createResult: Either<TableError, ADTable> = ADTable.create(
            CreateTableParams(
                metadata = metadata,
                name = name,
                displayName = displayName,
                description = description,
                accessLevel = command.accessLevel,
                columns = columns
            )
        )

        return when (createResult) {
            is Either.Left -> createResult
            is Either.Right -> {
                val savedTable: Either<TableError, ADTable> = operations.save(createResult.value)
                
                when (savedTable) {
                    is Either.Right -> {
                        val event: DomainEvent = TableCreated(
                            metadata = EventMetadata(
                                id = UUID.randomUUID(),
                                timestamp = Instant.now(),
                                user = savedTable.value.metadata.createdBy
                            ),
                            tableId = savedTable.value.metadata.id,
                            tableName = savedTable.value.name.value
                        )
                        eventPublisher.publish(event)
                    }
                    is Either.Left -> Unit
                }
                
                savedTable
            }
        }
    }
}


File: ./src/main/kotlin/org/blackerp/application/table/CreateTableCommand.kt
// Classpath: src.main.kotlin.org.blackerp.application.table.CreateTableCommand

package org.blackerp.application.table

import org.blackerp.domain.values.AccessLevel
import org.blackerp.domain.values.DataType

// CreateTableCommand with added columns property

data class CreateTableCommand(
    val name: String,
    val displayName: String,
    val description: String?,
    val accessLevel: AccessLevel,
    val createdBy: String,
    val columns: List<CreateColumnCommand>  
)

data class CreateColumnCommand(
    val name: String,
    val dataType: DataType,
    val length: Int?,
    val precision: Int?,
    val displayName: String,  
    val description: String?,
    val scale: Int?
)



File: ./src/main/kotlin/org/blackerp/shared/ValidationError.kt
// Classpath: src.main.kotlin.org.blackerp.shared.ValidationError

// File: src/main/kotlin/org/blackerp/shared/ValidationError.kt
package org.blackerp.shared

sealed class ValidationError(val message: String) {
    data class InvalidFormat(val details: String) : ValidationError(details)
    data class Required(val field: String) : ValidationError("Field $field is required")
    data class InvalidLength(val field: String, val min: Int, val max: Int) : 
        ValidationError("Field $field must be between $min and $max characters")
    data class InvalidValue(val details: String) : ValidationError(details)
}



File: ./src/main/kotlin/org/blackerp/shared/TimeBasedId.kt
// Classpath: src.main.kotlin.org.blackerp.shared.TimeBasedId

package org.blackerp.shared

import com.fasterxml.uuid.Generators
import java.util.UUID

object TimeBasedId {
    private val timeBasedGenerator = Generators.timeBasedGenerator()
    
    fun generate(): UUID = timeBasedGenerator.generate()
}


File: ./src/main/kotlin/org/blackerp/shared/ReferenceValidation.kt
// Classpath: src.main.kotlin.org.blackerp.shared.ReferenceValidation

package org.blackerp.shared

sealed interface ReferenceValidation {
    data class ColumnNotFound(val columnName: String) : ValidationError("Column not found: $columnName")
    data class ReferenceTableNotFound(val tableName: String) : ValidationError("Reference table not found: $tableName")
    data class ReferenceColumnNotFound(
        val tableName: String,
        val columnName: String
    ) : ValidationError("Column $columnName not found in table $tableName")
    data class IncompatibleTypes(
        val sourceColumn: String,
        val sourceType: String,
        val targetColumn: String,
        val targetType: String
    ) : ValidationError("Incompatible types: $sourceColumn ($sourceType) cannot reference $targetColumn ($targetType)")
}


File: ./src/test/resources/application.yml
// Classpath: src.test.resources.application

spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    username: sa
    password:
    driver-class-name: org.h2.Driver
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  
  flyway:
    enabled: false
    locations: classpath:db/migration
    baseline-on-migrate: true
    
  h2:
    console:
      enabled: true
      path: /h2-console

logging:
  level:
    org.springframework: INFO
    org.blackerp: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE



File: ./src/test/resources/application-test.yml
// Classpath: src.test.resources.application-test

spring:
  datasource:
    url: jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE;DEFAULT_NULL_ORDERING=HIGH
    username: sa
    password:
    driver-class-name: org.h2.Driver
  
  jpa:
    database-platform: org.hibernate.dialect.H2Dialect
    hibernate:
      ddl-auto: none
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  
  flyway:
    enabled: false
    locations: classpath:db/migration
    baseline-on-migrate: true
    
  h2:
    console:
      enabled: true
      path: /h2-console

logging:
  level:
    org.springframework: INFO
    org.blackerp: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.type.descriptor.sql: TRACE



File: ./src/test/resources/db/migration/V4__create_test_tables.sql
// Classpath: src.test.resources.db.migration.V4__create_test_tables

CREATE TABLE IF NOT EXISTS ad_table (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(60) NOT NULL,
    display_name VARCHAR(60) NOT NULL,
    created_by VARCHAR(60) NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT uk_ad_table_name UNIQUE (name)
);


File: ./src/test/resources/db/h2-schema.sql
// Classpath: src.test.resources.db.h2-schema

-- Drop existing tables if they exist
DROP TABLE IF EXISTS ad_tab_order_by;
DROP TABLE IF EXISTS ad_tab_display_column;
DROP TABLE IF EXISTS ad_tab_query_column;
DROP TABLE IF EXISTS ad_tab;
DROP TABLE IF EXISTS ad_table_relationship;
DROP TABLE IF EXISTS ad_table;

-- Create ad_table with H2-compatible syntax
CREATE TABLE ad_table (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    access_level VARCHAR(50) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_table_name UNIQUE (name)
);

-- Use REGEXP_LIKE for H2 name format check
ALTER TABLE ad_table ADD CONSTRAINT chk_table_name 
    CHECK (REGEXP_LIKE(name, '^[a-z][a-z0-9_]*$'));

-- Create relationship table
CREATE TABLE ad_table_relationship (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    source_table VARCHAR(100) NOT NULL,
    target_table VARCHAR(100) NOT NULL,
    type VARCHAR(20) NOT NULL,
    source_column VARCHAR(100) NOT NULL,
    target_column VARCHAR(100) NOT NULL,
    delete_rule VARCHAR(20) NOT NULL,
    update_rule VARCHAR(20) NOT NULL,
    junction_table VARCHAR(100),
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_relationship_name UNIQUE (name),
    CONSTRAINT fk_source_table FOREIGN KEY (source_table) REFERENCES ad_table(name),
    CONSTRAINT fk_target_table FOREIGN KEY (target_table) REFERENCES ad_table(name),
    CONSTRAINT fk_junction_table FOREIGN KEY (junction_table) REFERENCES ad_table(name),
    CONSTRAINT chk_relationship_type CHECK (type IN ('ONE_TO_ONE', 'ONE_TO_MANY', 'MANY_TO_MANY')),
    CONSTRAINT chk_delete_rule CHECK (delete_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION')),
    CONSTRAINT chk_update_rule CHECK (update_rule IN ('RESTRICT', 'CASCADE', 'SET_NULL', 'NO_ACTION'))
);

-- Create tab and related tables
CREATE TABLE ad_tab (
    id UUID PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    display_name VARCHAR(100) NOT NULL,
    description TEXT,
    table_name VARCHAR(100) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(100) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(100) NOT NULL,
    version INTEGER NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT uk_tab_name UNIQUE (name),
    CONSTRAINT fk_tab_table FOREIGN KEY (table_name) REFERENCES ad_table(name)
);

CREATE TABLE ad_tab_query_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE ad_tab_display_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE ad_tab_order_by (
    tab_id UUID NOT NULL,
    column_name VARCHAR(100) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    sequence INTEGER NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) REFERENCES ad_tab(id) ON DELETE CASCADE,
    CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);

-- Create indexes for better performance
CREATE INDEX idx_table_name ON ad_table(name);
CREATE INDEX idx_table_active ON ad_table(active);
CREATE INDEX idx_relationship_source ON ad_table_relationship(source_table);
CREATE INDEX idx_relationship_target ON ad_table_relationship(target_table);
CREATE INDEX idx_relationship_active ON ad_table_relationship(active);
CREATE INDEX idx_tab_name ON ad_tab(name);
CREATE INDEX idx_tab_table ON ad_tab(table_name);


File: ./src/test/resources/db/schema.sql
// Classpath: src.test.resources.db.schema

-- src/test/resources/db/schema.sql
-- Add after existing tables

CREATE TABLE IF NOT EXISTS ad_tab (
    id UUID PRIMARY KEY,
    name VARCHAR(60) NOT NULL CONSTRAINT uk_tab_name UNIQUE,
    display_name VARCHAR(60) NOT NULL,
    description VARCHAR(255),
    table_name VARCHAR(60) NOT NULL,
    created TIMESTAMP NOT NULL,
    created_by VARCHAR(60) NOT NULL,
    updated TIMESTAMP NOT NULL,
    updated_by VARCHAR(60) NOT NULL,
    version INT NOT NULL DEFAULT 0,
    active BOOLEAN NOT NULL DEFAULT true,
    CONSTRAINT fk_tab_table FOREIGN KEY (table_name) 
        REFERENCES ad_table(name)
);

CREATE TABLE IF NOT EXISTS ad_tab_query_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(60) NOT NULL,
    sequence INT NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_query_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS ad_tab_display_column (
    tab_id UUID NOT NULL,
    column_name VARCHAR(60) NOT NULL,
    sequence INT NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_display_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS ad_tab_order_by (
    tab_id UUID NOT NULL,
    column_name VARCHAR(60) NOT NULL,
    direction VARCHAR(4) NOT NULL,
    sequence INT NOT NULL,
    PRIMARY KEY (tab_id, column_name),
    CONSTRAINT fk_order_tab FOREIGN KEY (tab_id) 
        REFERENCES ad_tab(id) ON DELETE CASCADE,
    CONSTRAINT chk_direction CHECK (direction IN ('ASC', 'DESC'))
);


File: ./src/test/kotlin/org/blackerp/infrastructure/cache/InMemoryCacheServiceTest.kt
// Classpath: src.test.kotlin.org.blackerp.infrastructure.cache.InMemoryCacheServiceTest

package org.blackerp.infrastructure.cache

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
import java.time.Duration

class InMemoryCacheServiceTest : DescribeSpec({
    lateinit var cacheService: CacheService

    beforeTest {
        cacheService = InMemoryCacheService()
    }

    describe("InMemoryCacheService") {
        it("should store and retrieve values") {
            runTest {
                cacheService.set("test", "value")
                val result = cacheService.get<String>("test")
                result.getOrNull() shouldBe "value"
            }
        }

        it("should handle TTL") {
            runTest {
                cacheService.set("test", "value", Duration.ofMillis(1))
                Thread.sleep(10)
                val result = cacheService.get<String>("test")
                result.getOrNull() shouldBe null
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/TestDatabaseConfig.kt
// Classpath: src.test.kotlin.org.blackerp.infrastructure.persistence.TestDatabaseConfig

// File: src/test/kotlin/org/blackerp/infrastructure/persistence/TestDatabaseConfig.kt
package org.blackerp.infrastructure.persistence

import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType
import org.springframework.context.annotation.Primary
import javax.sql.DataSource

@TestConfiguration
class TestDatabaseConfig {
    
    @Bean
    @Primary
    fun dataSource(): DataSource =
        EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript("db/h2-schema.sql")
            .build()

    @Bean
    fun jdbcTemplate(dataSource: DataSource): JdbcTemplate = 
        JdbcTemplate(dataSource)
}


File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/SimpleTest.kt
// Classpath: src.test.kotlin.org.blackerp.infrastructure.persistence.SimpleTest

package org.blackerp.infrastructure.persistence

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import org.blackerp.config.TestConfig
import org.springframework.jdbc.core.JdbcTemplate
import java.time.Instant
import java.util.UUID

class SimpleTest : DescribeSpec({
    
    val jdbcTemplate = TestConfig().jdbcTemplate(TestConfig().dataSource())

    beforeSpec {
        // Create test table if it doesn't exist
        jdbcTemplate.execute("""
            CREATE TABLE IF NOT EXISTS ad_table (
                id VARCHAR(36) PRIMARY KEY,
                name VARCHAR(100) NOT NULL,
                display_name VARCHAR(100) NOT NULL,
                description VARCHAR(255),
                access_level VARCHAR(50),
                created TIMESTAMP NOT NULL,
                created_by VARCHAR(100) NOT NULL,
                updated TIMESTAMP,
                updated_by VARCHAR(100),
                version INTEGER DEFAULT 0,
                active BOOLEAN DEFAULT true
            )
        """)
    }

    afterSpec {
        jdbcTemplate.execute("DROP TABLE IF EXISTS ad_table")
    }

    describe("Database Operations") {
        it("should verify database connection") {
            val result = jdbcTemplate.queryForObject("SELECT 1", Int::class.java)
            result shouldBe 1
        }

        it("should insert into ad_table") {
            // given
            val id = UUID.randomUUID()
            val now = Instant.now()

            // when
            val insertCount = jdbcTemplate.update("""
                INSERT INTO ad_table (
                    id, name, display_name, created, created_by
                ) VALUES (?, ?, ?, ?, ?)
                """,
                id,
                "test_table",
                "Test Table",
                now,
                "test-user"
            )

            // then
            insertCount shouldBe 1

            val result = jdbcTemplate.queryForMap(
                "SELECT * FROM ad_table WHERE id = ?",
                id
            )

            result["name"] shouldBe "test_table"
            result["display_name"] shouldBe "Test Table"
        }
    }
})



File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryTabOperations.kt
// Classpath: src.test.kotlin.org.blackerp.infrastructure.persistence.store.InMemoryTabOperations


package org.blackerp.infrastructure.persistence.store

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.ad.tab.*
import org.blackerp.domain.values.TableName
import org.blackerp.shared.ValidationError
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap

class InMemoryTabOperations : TabOperations {
    private val tabs = ConcurrentHashMap<UUID, ADTab>()
    private val tabsByTable = ConcurrentHashMap<String, MutableSet<UUID>>()

    override suspend fun save(tab: ADTab): Either<TabError, ADTab> =
        Either.catch {
            // Check for duplicate name
            val existingTab = tabs.values.find { 
                it.name == tab.name && it.metadata.id != tab.metadata.id 
            }
            if (existingTab != null) {
                return TabError.DuplicateTab(tab.name.value).left()
            }

            tabs[tab.metadata.id] = tab
            tabsByTable.computeIfAbsent(tab.table.name.value) { mutableSetOf() }
                .add(tab.metadata.id)
            tab
        }.mapLeft { e -> 
            TabError.ValidationFailed(
                listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
            )
        }

    override suspend fun findById(id: UUID): Either<TabError, ADTab?> =
        Either.catch {
            tabs[id]
        }.mapLeft { e -> 
            TabError.ValidationFailed(
                listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
            )
        }

    override suspend fun findByTable(tableName: TableName): Either<TabError, List<ADTab>> =
        Either.catch {
            tabsByTable[tableName.value]?.mapNotNull { tabs[it] } ?: emptyList()
        }.mapLeft { e -> 
            TabError.ValidationFailed(
                listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
            )
        }

    override suspend fun delete(id: UUID): Either<TabError, Unit> =
        Either.catch {
            tabs[id]?.let { tab ->
                tabs.remove(id)
                tabsByTable[tab.table.name.value]?.remove(id)
                Unit
            } ?: throw IllegalStateException("Tab not found: $id")
        }.mapLeft { e -> 
            TabError.ValidationFailed(
                listOf(ValidationError.InvalidValue(e.message ?: "Unknown error"))
            )
        }
}



File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryRelationshipOperations.kt
// Classpath: src.test.kotlin.org.blackerp.infrastructure.persistence.store.InMemoryRelationshipOperations

package org.blackerp.infrastructure.persistence.store

import arrow.core.Either
import arrow.core.left
import arrow.core.right
import org.blackerp.domain.table.TableError
import org.blackerp.domain.values.TableName
import org.blackerp.domain.table.relationship.TableRelationship
import org.blackerp.domain.table.relationship.RelationshipOperations
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap

class InMemoryRelationshipOperations : RelationshipOperations {
    private val relationships = ConcurrentHashMap<UUID, TableRelationship>()
    private val relationshipsByTable = ConcurrentHashMap<String, MutableSet<UUID>>()

    override suspend fun save(relationship: TableRelationship): Either<TableError, TableRelationship> =
        Either.catch {
            // Check for duplicate name
            if (relationships.values.any { 
                it.name == relationship.name && it.metadata.id != relationship.metadata.id 
            }) {
                return TableError.DuplicateTable(relationship.name.value).left()
            }

            relationships[relationship.metadata.id] = relationship
            
            // Index by source table
            relationshipsByTable.computeIfAbsent(relationship.sourceTable.value) { 
                mutableSetOf() 
            }.add(relationship.metadata.id)
            
            // Index by target table
            relationshipsByTable.computeIfAbsent(relationship.targetTable.value) { 
                mutableSetOf() 
            }.add(relationship.metadata.id)
            
            relationship
        }.mapLeft { 
            TableError.StorageError(it) 
        }

    override suspend fun findById(id: UUID): Either<TableError, TableRelationship?> =
        Either.catch {
            relationships[id]
        }.mapLeft { 
            TableError.StorageError(it) 
        }

    override suspend fun findByTable(tableName: TableName): Either<TableError, List<TableRelationship>> =
        Either.catch {
            relationshipsByTable[tableName.value]?.mapNotNull { 
                relationships[it] 
            } ?: emptyList()
        }.mapLeft { 
            TableError.StorageError(it) 
        }

    override suspend fun delete(id: UUID): Either<TableError, Unit> =
        Either.catch {
            relationships[id]?.let { relationship ->
                relationships.remove(id)
                relationshipsByTable[relationship.sourceTable.value]?.remove(id)
                relationshipsByTable[relationship.targetTable.value]?.remove(id)
                Unit
            } ?: return TableError.NotFound(id.toString()).left()
        }.mapLeft {
            TableError.StorageError(it)
        }
}



File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/InMemoryTableOperations.kt
// Classpath: src.test.kotlin.org.blackerp.infrastructure.persistence.store.InMemoryTableOperations

package org.blackerp.infrastructure.persistence.store

import arrow.core.left
import arrow.core.Either
import arrow.core.right
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.TableOperations
import java.util.UUID
import java.util.concurrent.ConcurrentHashMap

class InMemoryTableOperations : TableOperations {
    private val tables = ConcurrentHashMap<UUID, ADTable>()
    private val nameIndex = ConcurrentHashMap<String, UUID>()

    override suspend fun save(table: ADTable): Either<TableError, ADTable> =
        findByName(table.name.value).fold(
            { error -> error.left() },
            { existing ->
                if (existing != null && existing.metadata.id != table.metadata.id) {
                    TableError.DuplicateTable(table.name.value).left()
                } else {
                    tables[table.metadata.id] = table
                    nameIndex[table.name.value] = table.metadata.id
                    table.right()
                }
            }
        )

    override suspend fun findById(id: UUID): Either<TableError, ADTable?> =
        Either.catch {
            tables[id]
        }.mapLeft { 
            TableError.StorageError(it) 
        }

    override suspend fun findByName(name: String): Either<TableError, ADTable?> =
        Either.catch {
            nameIndex[name]?.let { tables[it] }
        }.mapLeft { 
            TableError.StorageError(it) 
        }

    override suspend fun delete(id: UUID): Either<TableError, Unit> =
        Either.catch {
            tables[id]?.let { table ->
                nameIndex.remove(table.name.value)
                tables.remove(id)
            }
            Unit
        }.mapLeft {
            TableError.StorageError(it)
        }
}



File: ./src/test/kotlin/org/blackerp/infrastructure/persistence/store/PostgresTabOperationsTest.kt
// Classpath: src.test.kotlin.org.blackerp.infrastructure.persistence.store.PostgresTabOperationsTest

package org.blackerp.infrastructure.persistence.store

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.ad.tab.*
import org.blackerp.domain.ad.tab.value.TabName
import org.blackerp.domain.table.TableOperations
import org.blackerp.domain.values.*
import org.blackerp.shared.TestFactory
import org.blackerp.config.UnifiedTestConfig
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.springframework.jdbc.core.JdbcTemplate
import org.slf4j.LoggerFactory
import java.util.UUID

@SpringBootTest(classes = [UnifiedTestConfig::class])
@ActiveProfiles("test")
class PostgresTabOperationsTest(
    private val jdbcTemplate: JdbcTemplate,
    private val tableOperations: TableOperations
) : DescribeSpec({
    
    val logger = LoggerFactory.getLogger(PostgresTabOperationsTest::class.java)
    lateinit var tabOperations: PostgresTabOperations

    beforeTest {
        tabOperations = PostgresTabOperations(jdbcTemplate, tableOperations)
        
        // Clean up test data
        listOf(
            "DELETE FROM ad_tab_query_column",
            "DELETE FROM ad_tab_display_column",
            "DELETE FROM ad_tab_order_by",
            "DELETE FROM ad_tab",
            "DELETE FROM ad_table"
        ).forEach { sql ->
            try {
                jdbcTemplate.execute(sql)
            } catch (e: Exception) {
                logger.warn("Failed to execute cleanup SQL: $sql", e)
            }
        }
    }

    describe("PostgresTabOperations") {
        context("save") {
            it("should save tab with all related data") {
                runTest {
                    // Create and save the table first
                    val table = TestFactory.createTestTable()
                    logger.debug("Created test table: ${table.name.value}")
                    
                    val savedTableResult = tableOperations.save(table)
                    savedTableResult.shouldBeRight()
                    logger.debug("Saved test table successfully")

                    // Verify the table exists
                    val tableCount = jdbcTemplate.queryForObject(
                        "SELECT COUNT(*) FROM ad_table WHERE name = ?",
                        Int::class.java,
                        table.name.value
                    )
                    tableCount shouldBe 1
                    logger.debug("Verified table exists in database")

                    // Create the tab
                    val columnName = table.columns.first().name
                    val tab = ADTab(
                        metadata = TestFactory.createMetadata(),
                        name = TabName.create("test_tab").getOrNull()!!,
                        displayName = DisplayName.create("Test Tab").getOrNull()!!,
                        description = Description.create("Test Description").getOrNull(),
                        table = table,
                        queryColumns = listOf(columnName),
                        displayColumns = listOf(columnName),
                        orderBy = listOf(
                            OrderBySpec(columnName, SortDirection.ASC)
                        )
                    )
                    logger.debug("Created test tab object")

                    // Save the tab
                    val saveResult = tabOperations.save(tab)
                    logger.debug("Save result: $saveResult")

                    saveResult.shouldBeRight().also { savedTab ->
                        logger.debug("Verifying saved tab...")
                        savedTab.name.value shouldBe "test_tab"
                        savedTab.queryColumns.size shouldBe 1
                        savedTab.queryColumns.first().value shouldBe columnName.value
                        savedTab.displayColumns.size shouldBe 1
                        savedTab.displayColumns.first().value shouldBe columnName.value
                        savedTab.orderBy.size shouldBe 1
                        savedTab.orderBy.first().column.value shouldBe columnName.value
                    }

                    // Verify in database
                    val tabCount = jdbcTemplate.queryForObject(
                        "SELECT COUNT(*) FROM ad_tab WHERE name = ?",
                        Int::class.java,
                        "test_tab"
                    )
                    tabCount shouldBe 1
                    logger.debug("Verified tab exists in database")
                }
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/plugin/TestPlugin.kt
// Classpath: src.test.kotlin.org.blackerp.plugin.TestPlugin

// Classpath: src/test/kotlin/org/blackerp/plugin/TestPlugin.kt
package org.blackerp.plugin

import arrow.core.Either
import arrow.core.right

class TestPlugin(
    override val metadata: PluginMetadata,
    private val extensions: List<Extension> = emptyList()
) : Plugin {
    var initialized = false
    var shutdown = false
    
    override suspend fun initialize(): Either<PluginError, Unit> {
        initialized = true
        return Unit.right()
    }
    
    override suspend fun registerExtensions(registry: ExtensionRegistry): Either<PluginError, Unit> {
        extensions.forEach { extension ->
            registry.register(extension)
        }
        return Unit.right()
    }
    
    override suspend fun shutdown(): Either<PluginError, Unit> {
        shutdown = true
        return Unit.right()
    }
}


File: ./src/test/kotlin/org/blackerp/plugin/discovery/FileSystemPluginDiscoveryTest.kt
// Classpath: src.test.kotlin.org.blackerp.plugin.discovery.FileSystemPluginDiscoveryTest

package org.blackerp.plugin.discovery

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
import java.nio.file.Files
import kotlin.io.path.createTempDirectory
import kotlin.io.path.writeText

class FileSystemPluginDiscoveryTest : DescribeSpec({
    describe("FileSystemPluginDiscovery") {
        val discovery = FileSystemPluginDiscovery()

        it("should discover jar files") {
            runTest {
                val tempDir = createTempDirectory()
                val jarFile = tempDir.resolve("test.jar")
                jarFile.writeText("dummy jar content")

                val result = discovery.discoverPlugins(tempDir)
                result.isRight() shouldBe true

                Files.deleteIfExists(jarFile)
                Files.deleteIfExists(tempDir)
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/plugin/InMemoryExtensionRegistry.kt
// Classpath: src.test.kotlin.org.blackerp.plugin.InMemoryExtensionRegistry

// Classpath: src/test/kotlin/org/blackerp/plugin/InMemoryExtensionRegistry.kt
package org.blackerp.plugin

import arrow.core.Either
import arrow.core.right
import java.util.concurrent.ConcurrentHashMap

class InMemoryExtensionRegistry : ExtensionRegistry {
    private val extensions = ConcurrentHashMap<Class<*>, MutableList<Extension>>()
    
    override suspend fun <T : Extension> register(extension: T): Either<PluginError, Unit> {
        extensions.computeIfAbsent(extension::class.java) { mutableListOf() }
            .add(extension)
        return Unit.right()
    }
    
    @Suppress("UNCHECKED_CAST")
    override fun <T : Extension> getExtensions(type: Class<T>): List<T> =
        extensions[type]?.map { it as T } ?: emptyList()
}


File: ./src/test/kotlin/org/blackerp/plugin/PluginIdTest.kt
// Classpath: src.test.kotlin.org.blackerp.plugin.PluginIdTest

package org.blackerp.plugin

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError

class PluginIdTest : DescribeSpec({
    describe("PluginId") {
        describe("create") {
            it("should create valid plugin id") {
                val result = PluginId.create("valid-plugin")
                result.shouldBeRight().also { id ->
                    id.value shouldBe "valid-plugin"
                }
            }

            it("should reject invalid format") {
                val invalidFormats = listOf(
                    "Invalid Plugin",  // Contains spaces
                    "1invalid",        // Starts with number
                    "INVALID",         // Contains uppercase
                    "invalid!plugin"   // Contains special characters
                )

                invalidFormats.forEach { invalid ->
                    val result = PluginId.create(invalid)
                    result.shouldBeLeft().also { error ->
                        error shouldBe ValidationError.InvalidFormat(
                            "Plugin ID must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"
                        )
                    }
                }
            }

            it("should enforce length constraints") {
                // Too short
                PluginId.create("ab").shouldBeLeft().also { error ->
                    error shouldBe ValidationError.InvalidLength("plugin id", 3, 50)
                }

                // Too long
                PluginId.create("a".repeat(51)).shouldBeLeft().also { error ->
                    error shouldBe ValidationError.InvalidLength("plugin id", 3, 50)
                }
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/plugin/VersionTest.kt
// Classpath: src.test.kotlin.org.blackerp.plugin.VersionTest

package org.blackerp.plugin

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError

class VersionTest : DescribeSpec({
    describe("Version") {
        describe("create") {
            it("should create valid version") {
                val result = Version.create("1.2.3")
                result.shouldBeRight().also { version ->
                    version.major shouldBe 1
                    version.minor shouldBe 2
                    version.patch shouldBe 3
                }
            }

            it("should reject invalid format") {
                val testCases = listOf(
                    "1" to "Version must be in format major.minor.patch",
                    "1.2" to "Version must be in format major.minor.patch",
                    "1.2.3.4" to "Version must be in format major.minor.patch",
                    "a.b.c" to "Version must be in format major.minor.patch",
                    "1.2.x" to "Version must be in format major.minor.patch",
                    ".1.2" to "Version must be in format major.minor.patch"
                )

                testCases.forEach { (input, expectedMessage) ->
                    Version.create(input).shouldBeLeft().also { error ->
                        error shouldBe ValidationError.InvalidFormat(expectedMessage)
                    }
                }
            }
        }

        describe("comparison") {
            it("should compare versions correctly") {
                val v1 = Version.create("1.0.0").getOrNull()!!
                val v2 = Version.create("2.0.0").getOrNull()!!
                val v3 = Version.create("2.1.0").getOrNull()!!
                val v4 = Version.create("2.1.1").getOrNull()!!

                (v1 < v2) shouldBe true
                (v2 < v3) shouldBe true
                (v3 < v4) shouldBe true
                (v4 > v1) shouldBe true
            }

            it("should handle equal versions") {
                val v1 = Version.create("1.0.0").getOrNull()!!
                val v2 = Version.create("1.0.0").getOrNull()!!

                (v1 == v2) shouldBe true
                (v1 >= v2) shouldBe true
                (v1 <= v2) shouldBe true
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/plugin/PluginTest.kt
// Classpath: src.test.kotlin.org.blackerp.plugin.PluginTest

// Classpath: src/test/kotlin/org/blackerp/plugin/PluginTest.kt
package org.blackerp.plugin

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest

class PluginTest : DescribeSpec({
    describe("Plugin") {
        val validId = PluginId.create("test-plugin").getOrNull()!!
        val validVersion = Version.create("1.0.0").getOrNull()!!
        val validMetadata = PluginMetadata.create(
            id = validId,
            version = validVersion,
            name = "Test Plugin",
            description = "A test plugin",
            vendor = "Test Vendor"
        ).getOrNull()!!
        
        lateinit var plugin: TestPlugin
        
        beforeTest {
            plugin = TestPlugin(validMetadata)
        }
        
        describe("lifecycle") {
            it("should handle initialization") {
                runTest {
                    val result = plugin.initialize()
                    result.isRight() shouldBe true
                    plugin.initialized shouldBe true
                }
            }
            
            it("should handle shutdown") {
                runTest {
                    val result = plugin.shutdown()
                    result.isRight() shouldBe true
                    plugin.shutdown shouldBe true
                }
            }
        }
        
        describe("extension registration") {
            it("should register extensions") {
                runTest {
                    val registry = InMemoryExtensionRegistry()
                    val result = plugin.registerExtensions(registry)
                    result.isRight() shouldBe true
                }
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/plugin/PluginMetadataTest.kt
// Classpath: src.test.kotlin.org.blackerp.plugin.PluginMetadataTest

package org.blackerp.plugin

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError

class PluginMetadataTest : DescribeSpec({
    describe("PluginMetadata") {
        describe("create") {
            val validId = PluginId.create("test-plugin").getOrNull()!!
            val validVersion = Version.create("1.0.0").getOrNull()!!

            it("should create valid metadata") {
                val result = PluginMetadata.create(
                    id = validId,
                    version = validVersion,
                    name = "Test Plugin",
                    description = "A test plugin",
                    vendor = "Test Vendor"
                )

                result.shouldBeRight().also { metadata ->
                    metadata.id shouldBe validId
                    metadata.version shouldBe validVersion
                    metadata.name shouldBe "Test Plugin"
                    metadata.description shouldBe "A test plugin"
                    metadata.vendor shouldBe "Test Vendor"
                }
            }

            it("should validate name") {
                val result = PluginMetadata.create(
                    id = validId,
                    version = validVersion,
                    name = "",
                    description = "A test plugin",
                    vendor = "Test Vendor"
                )

                result.shouldBeLeft().also { error ->
                    error shouldBe ValidationError.Required("name")
                }
            }

            it("should validate description length") {
                val result = PluginMetadata.create(
                    id = validId,
                    version = validVersion,
                    name = "Test Plugin",
                    description = "a".repeat(501),
                    vendor = "Test Vendor"
                )

                result.shouldBeLeft().also { error ->
                    error shouldBe ValidationError.InvalidLength("description", 0, 500)
                }
            }

            it("should validate vendor") {
                // Empty vendor
                PluginMetadata.create(
                    id = validId,
                    version = validVersion,
                    name = "Test Plugin",
                    description = "A test plugin",
                    vendor = ""
                ).shouldBeLeft().also { error ->
                    error shouldBe ValidationError.Required("vendor")
                }

                // Too long vendor
                PluginMetadata.create(
                    id = validId,
                    version = validVersion,
                    name = "Test Plugin",
                    description = "A test plugin",
                    vendor = "a".repeat(101)
                ).shouldBeLeft().also { error ->
                    error shouldBe ValidationError.InvalidLength("vendor", 3, 100)
                }
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/plugin/registry/DefaultPluginRegistryTest.kt
// Classpath: src.test.kotlin.org.blackerp.plugin.registry.DefaultPluginRegistryTest

package org.blackerp.plugin.registry

import arrow.core.Either
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
import org.blackerp.plugin.*

class DefaultPluginRegistryTest : DescribeSpec({
    describe("DefaultPluginRegistry") {
        val registry = DefaultPluginRegistry()
        val pluginId = PluginId.create("test-plugin").getOrNull()!!
        val version = Version.create("1.0.0").getOrNull()!!
        val metadata = PluginMetadata.create(
            id = pluginId,
            version = version,
            name = "Test Plugin",
            description = "Test plugin description",
            vendor = "Test Vendor"
        ).getOrNull()!!
        
        val plugin = TestPlugin(metadata)

        it("should register plugin") {
            runTest {
                registry.register(plugin).isRight() shouldBe true
                registry.getPlugins().size shouldBe 1
            }
        }

        it("should prevent duplicate registration") {
            runTest {
                registry.register(plugin)
                registry.register(plugin).isLeft() shouldBe true
            }
        }

        it("should retrieve registered plugin") {
            runTest {
                registry.register(plugin)
                registry.getPlugin(pluginId).isRight() shouldBe true
            }
        }

        it("should unregister plugin") {
            runTest {
                registry.register(plugin)
                registry.unregister(pluginId).isRight() shouldBe true
                registry.getPlugins().isEmpty() shouldBe true
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/ad/window/value/WindowNameTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.ad.window.value.WindowNameTest


package org.blackerp.domain.ad.window.value

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError

class WindowNameTest : DescribeSpec({
    describe("WindowName") {
        describe("create") {
            it("should create valid window name") {
                val result = WindowName.create("valid_window")
                result.shouldBeRight()
            }

            it("should reject invalid format") {
                val result = WindowName.create("Invalid Window")
                result.shouldBeLeft()
            }

            it("should enforce length constraints") {
                WindowName.create("ab").shouldBeLeft()
                WindowName.create("a".repeat(51)).shouldBeLeft()
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/ad/tab/value/TabNameTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.ad.tab.value.TabNameTest


package org.blackerp.domain.ad.tab.value

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError

class TabNameTest : DescribeSpec({
    describe("TabName") {
        describe("create") {
            it("should create valid tab name") {
                val result = TabName.create("valid_tab")
                result.shouldBeRight()
            }

            it("should reject invalid format") {
                val result = TabName.create("Invalid Tab")
                result.shouldBeLeft()
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/ad/tab/ADTabTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.ad.tab.ADTabTest


package org.blackerp.domain.ad.tab

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.domain.values.*
import org.blackerp.domain.ad.tab.value.TabName
import org.blackerp.shared.TestFactory

class ADTabTest : DescribeSpec({
    describe("ADTab") {
        it("should create valid tab") {
            // given
            val table = TestFactory.createTestTable()
            val columnName = table.columns.first().name
            
            val params = CreateTabParams(
                metadata = TestFactory.createMetadata(),
                name = TabName.create("test_tab").getOrNull()!!,
                displayName = DisplayName.create("Test Tab").getOrNull()!!,
                description = null,
                table = table,
                queryColumns = listOf(columnName),
                displayColumns = listOf(columnName),
                orderBy = listOf(
                    OrderBySpec(columnName, SortDirection.ASC)
                )
            )

            // when
            val result = ADTab.create(params)

            // then
            result.shouldBeRight()
        }

        it("should validate column existence") {
            // given
            val table = TestFactory.createTestTable()
            val invalidColumnName = ColumnName.create("invalid_column").getOrNull()!!
            
            val params = CreateTabParams(
                metadata = TestFactory.createMetadata(),
                name = TabName.create("test_tab").getOrNull()!!,
                displayName = DisplayName.create("Test Tab").getOrNull()!!,
                description = null,
                table = table,
                queryColumns = listOf(invalidColumnName),
                displayColumns = emptyList(),
                orderBy = emptyList()
            )

            // when
            val result = ADTab.create(params)

            // then
            result.shouldBeLeft()
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/ad/ADModuleTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.ad.ADModuleTest

package org.blackerp.domain.ad

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import org.blackerp.domain.ad.value.ModuleName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.plugin.Version
import org.blackerp.shared.TestFactory

class ADModuleTest : DescribeSpec({
    describe("ADModule") {
        describe("create") {
            it("should create valid module") {
                // Given
                val name = ModuleName.create("test-module").getOrNull()!!
                val displayName = DisplayName.create("Test Module").getOrNull()!!
                val description = Description.create("Test Description").getOrNull()!!
                val version = Version.create("1.0.0").getOrNull()!!

                val params = CreateModuleParams(
                    metadata = TestFactory.createMetadata(),
                    name = name,
                    displayName = displayName,
                    description = description,
                    version = version
                )

                // When
                val result = ADModule.create(params)

                // Then
                result.shouldBeRight().also { module ->
                    module.name shouldBe name
                    module.displayName shouldBe displayName
                    module.description shouldBe description
                    module.version shouldBe version
                }
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/ad/value/ModuleNameTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.ad.value.ModuleNameTest

package org.blackerp.domain.ad.value

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError

class ModuleNameTest : DescribeSpec({
    describe("ModuleName") {
        describe("create") {
            it("should create valid module name") {
                val result = ModuleName.create("valid-module")
                result.shouldBeRight().also { name ->
                    name.value shouldBe "valid-module"
                }
            }

            it("should reject invalid format") {
                val result = ModuleName.create("Invalid Module")
                result.shouldBeLeft().also { error ->
                    error.message shouldBe "Module name must start with lowercase letter and contain only lowercase letters, numbers, and hyphens"
                }
            }

            it("should enforce length constraints") {
                ModuleName.create("ab").shouldBeLeft().also { error ->
                    error shouldBe ValidationError.InvalidLength("module name", 3, 50)
                }

                ModuleName.create("a".repeat(51)).shouldBeLeft().also { error ->
                    error shouldBe ValidationError.InvalidLength("module name", 3, 50)
                }
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/ad/reference/ADReferenceTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.ad.reference.ADReferenceTest

package org.blackerp.domain.ad.reference

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeTypeOf
import io.kotest.assertions.arrow.core.shouldBeRight
import org.blackerp.domain.ad.reference.value.ReferenceName
import org.blackerp.domain.values.DisplayName
import org.blackerp.domain.values.Description
import org.blackerp.shared.TestFactory

class ADReferenceTest : DescribeSpec({
    describe("ADReference") {
        it("should create list reference") {
            // given
            val name = ReferenceName.create("test_reference").getOrNull()!!
            val displayName = DisplayName.create("Test Reference").getOrNull()!!
            val description = Description.create("Test reference description").getOrNull()
            
            val params = CreateReferenceParams(
                metadata = TestFactory.createMetadata(),
                name = name,
                displayName = displayName,
                description = description,
                type = ReferenceType.List
            )
            
            // when
            val result = ADReference.create(params)
            
            // then
            result.shouldBeRight().also { reference ->
                reference.name shouldBe name
                reference.displayName shouldBe displayName
                reference.description shouldBe description
                reference.type shouldBe ReferenceType.List
            }
        }

        it("should create table reference") {
            // given
            val name = ReferenceName.create("table_reference").getOrNull()!!
            val displayName = DisplayName.create("Table Reference").getOrNull()!!
            
            val params = CreateReferenceParams(
                metadata = TestFactory.createMetadata(),
                name = name,
                displayName = displayName,
                description = null,
                type = ReferenceType.Table(
                    tableName = "test_table",
                    keyColumn = "id",
                    displayColumn = "name"
                )
            )
            
            // when
            val result = ADReference.create(params)
            
            // then
            result.shouldBeRight().also { reference ->
                val tableRef = reference.type as ReferenceType.Table
                tableRef.tableName shouldBe "test_table"
                tableRef.keyColumn shouldBe "id"
                tableRef.displayColumn shouldBe "name"
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/domain/ad/reference/value/ReferenceNameTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.ad.reference.value.ReferenceNameTest


package org.blackerp.domain.ad.reference.value

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import org.blackerp.shared.ValidationError

class ReferenceNameTest : DescribeSpec({
    describe("ReferenceName") {
        describe("create") {
            it("should create valid reference name") {
                val result = ReferenceName.create("valid_reference")
                result.shouldBeRight()
            }

            it("should reject invalid format") {
                val result = ReferenceName.create("Invalid Reference")
                result.shouldBeLeft()
            }

            it("should enforce length constraints") {
                ReferenceName.create("ab").shouldBeLeft()
                ReferenceName.create("a".repeat(51)).shouldBeLeft()
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/error/DomainErrorTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.error.DomainErrorTest

package org.blackerp.domain.error

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeTypeOf

class DomainErrorTest : DescribeSpec({
    describe("DomainError") {
        it("should create validation error") {
            val error = DomainError.ValidationError("Invalid input", "field1")
            error.shouldBeTypeOf<DomainError.ValidationError>()
            error.message shouldBe "Invalid input"
            error.field shouldBe "field1"
        }
        
        it("should create security error") {
            val error = DomainError.SecurityError(
                message = "Access denied",
                reason = "Insufficient permissions"
            )
            error.shouldBeTypeOf<DomainError.SecurityError>()
            error.message shouldBe "Access denied"
            error.reason shouldBe "Insufficient permissions"
        }
        
        it("should create system error with cause") {
            val cause = RuntimeException("Test exception")
            val error = DomainError.SystemError("System failure", cause)
            error.shouldBeTypeOf<DomainError.SystemError>()
            error.message shouldBe "System failure"
            error.cause shouldBe cause
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/tenant/TenantAwareTableTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.tenant.TenantAwareTableTest

package org.blackerp.domain.tenant

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import org.blackerp.shared.TestFactory
import org.blackerp.domain.table.TenantAwareTable
import java.util.UUID 

class TenantAwareTableTest : DescribeSpec({
    describe("TenantAwareTable") {
        it("should wrap ADTable with tenant ID") {
            // given
            val table = TestFactory.createTestTable()
            val tenantId = UUID.randomUUID()
            
            // when
            val tenantAwareTable = TenantAwareTable.from(table, tenantId)
            
            // then
            tenantAwareTable.tenantId shouldBe tenantId
            tenantAwareTable.metadata shouldBe table.metadata
            tenantAwareTable.name.value shouldBe table.name.value
            tenantAwareTable.displayName.value shouldBe table.displayName.value
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/tenant/TenantContextTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.tenant.TenantContextTest

package org.blackerp.domain.tenant

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import java.util.UUID

class TenantContextTest : DescribeSpec({
    afterTest {
        TenantContext.clear()
    }
    
    describe("TenantContext") {
        it("should manage current tenant") {
            // given
            val tenantId = UUID.randomUUID()
            
            // when
            TenantContext.setCurrentTenant(tenantId)
            
            // then
            TenantContext.getCurrentTenant() shouldBe tenantId
        }
        
        it("should clear tenant context") {
            // given
            val tenantId = UUID.randomUUID()
            TenantContext.setCurrentTenant(tenantId)
            
            // when
            TenantContext.clear()
            
            // then
            TenantContext.getCurrentTenant() shouldBe null
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/values/AmountTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.values.AmountTest

package org.blackerp.domain.values

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft
import java.math.BigDecimal

class AmountTest : DescribeSpec({
    describe("Amount") {
        describe("create") {
            it("should create valid amount") {
                val result = Amount.create(BigDecimal("100.00"))
                result.shouldBeRight()
            }

            it("should reject negative amount") {
                val result = Amount.create(BigDecimal("-100.00"))
                result.shouldBeLeft()
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/values/DisplayNameTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.values.DisplayNameTest

package org.blackerp.domain.values

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import arrow.core.Either

class DisplayNameTest : DescribeSpec({
    describe("DisplayName") {
        describe("create") {
            it("should create valid display name") {
                val result = DisplayName.create("Valid Display Name")
                result.isRight() shouldBe true
            }
            
            it("should reject blank name") {
                val result = DisplayName.create("   ")
                result.isLeft() shouldBe true
            }
            
            it("should reject too long name") {
                val result = DisplayName.create("a".repeat(61))
                result.isLeft() shouldBe true
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/domain/values/TableNameTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.values.TableNameTest

package org.blackerp.domain.values

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import arrow.core.Either

class TableNameTest : DescribeSpec({
    describe("TableName") {
        describe("create") {
            it("should create valid table name") {
                val result = TableName.create("valid_table_name")
                result.isRight() shouldBe true
            }
            
            it("should reject invalid format") {
                val result = TableName.create("Invalid Table")
                result.isLeft() shouldBe true
            }
            
            it("should reject name starting with number") {
                val result = TableName.create("1invalid")
                result.isLeft() shouldBe true
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/domain/values/CurrencyTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.values.CurrencyTest

package org.blackerp.domain.values

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft

class CurrencyTest : DescribeSpec({
    describe("Currency") {
        describe("create") {
            it("should create valid currency code") {
                val result = Currency.create("USD")
                result.shouldBeRight()
            }

            it("should reject invalid format") {
                val result = Currency.create("usd")
                result.shouldBeLeft()
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/values/DataTypeTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.values.DataTypeTest


package org.blackerp.domain.values

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.throwables.shouldThrow

class DataTypeTest : DescribeSpec({
    describe("DataType") {
        describe("fromString") {
            it("should create valid data type from string") {
                DataType.fromString("STRING") shouldBe DataType.STRING
                DataType.fromString("string") shouldBe DataType.STRING
            }
            
            it("should throw exception for invalid type") {
                shouldThrow<IllegalArgumentException> {
                    DataType.fromString("INVALID_TYPE")
                }
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/transaction/TransactionTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.transaction.TransactionTest

package org.blackerp.domain.transaction

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import org.blackerp.domain.values.Amount
import org.blackerp.domain.values.Currency
import org.blackerp.shared.TestFactory
import java.math.BigDecimal
import java.time.Instant

class TransactionTest : DescribeSpec({
    describe("Transaction") {
        describe("create") {
            it("should create valid transaction") {
                val amount = Amount.create(BigDecimal("100.00")).getOrNull()!!
                val currency = Currency.create("USD").getOrNull()!!
                
                val params = CreateTransactionParams(
                    metadata = TestFactory.createMetadata(),
                    amount = amount,
                    currency = currency,
                    timestamp = Instant.now(),
                    description = "Test transaction"
                )
                
                val result = Transaction.create(params)
                result.shouldBeRight()
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/query/QueryCriteriaTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.query.QueryCriteriaTest

package org.blackerp.domain.query

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.should
import io.kotest.matchers.types.beInstanceOf

class QueryCriteriaTest : DescribeSpec({
    describe("QueryCriteria") {
        it("should create complex criteria") {
            val criteria = QueryCriteria.And(
                listOf(
                    QueryCriteria.Equals("name", "test"),
                    QueryCriteria.Or(
                        listOf(
                            QueryCriteria.Like("description", "%test%"),
                            QueryCriteria.In("status", listOf("active", "pending"))
                        )
                    )
                )
            )
            
            criteria should beInstanceOf<QueryCriteria.And>()
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/table/extension/TableExtensionPointTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.extension.TableExtensionPointTest

package org.blackerp.domain.table.extension

import arrow.core.Either
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.table.ADTable
import org.blackerp.plugin.PluginId

class TableExtensionPointTest : DescribeSpec({
    describe("TableExtension") {
        val mockTable = mockk<ADTable>()
        val mockPluginId = PluginId.create("test-plugin").getOrNull()!!
        it("should implement extension interface") {
            val extension = object : TableExtension {
                override val pluginId = mockPluginId
                override suspend fun beforeCreate(table: ADTable) = Either.Right(table)
                override suspend fun afterCreate(table: ADTable) {}
                override suspend fun beforeUpdate(table: ADTable) = Either.Right(table)
                override suspend fun afterUpdate(table: ADTable) {}
                override suspend fun beforeDelete(table: ADTable) = Either.Right(Unit)
                override suspend fun afterDelete(table: ADTable) {}
            }

            runTest {
                extension.beforeCreate(mockTable).isRight() shouldBe true
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/table/constraint/ReferenceConstraintTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.constraint.ReferenceConstraintTest

package org.blackerp.domain.table.constraint

import arrow.core.right
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeTypeOf
import io.mockk.coEvery
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.table.*
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.domain.values.*
import org.blackerp.shared.TestFactory
import org.blackerp.shared.ReferenceValidation

class ReferenceConstraintTest : DescribeSpec({
    describe("validate") {
        it("should fail when source column does not exist") {
            runTest {
                // given
                val mockTableOps = mockk<TableOperations>()
                val sourceTableDef = mockk<TableDefinition>()
                val columnName = ColumnName.create("test_column").getOrNull()!!
                val refTableName = TableName.create("ref_table").getOrNull()!!
                val refColumnName = ColumnName.create("ref_column").getOrNull()!!

                every { sourceTableDef.columns } returns emptyList()

                val constraint = ReferenceConstraint(
                    metadata = TestFactory.createMetadata(),
                    column = columnName,
                    referenceTable = refTableName,
                    referenceColumn = refColumnName,
                    tableOperations = mockTableOps
                )

                // when
                val result = constraint.validate(sourceTableDef)

                // then
                result.isLeft() shouldBe true
                result.fold(
                    { error -> error.shouldBeTypeOf<ReferenceValidation.ColumnNotFound>() },
                    { throw AssertionError("Should not succeed") }
                )
            }
        }

        it("should fail when reference table not found") {
            runTest {
                // given
                val mockTableOps = mockk<TableOperations>()
                val sourceTableDef = mockk<TableDefinition>()
                val columnName = ColumnName.create("test_column").getOrNull()!!
                val refTableName = TableName.create("ref_table").getOrNull()!!
                val refColumnName = ColumnName.create("ref_column").getOrNull()!!

                // Set up source column to exist
                val sourceColumn = mockk<ColumnDefinition>()
                every { sourceColumn.name } returns columnName
                every { sourceColumn.dataType } returns DataType.STRING

                every { sourceTableDef.columns } returns listOf(sourceColumn)

                // Set up reference table to not be found
                coEvery { mockTableOps.findByName(refTableName.value) } returns null.right()

                val constraint = ReferenceConstraint(
                    metadata = TestFactory.createMetadata(),
                    column = columnName,
                    referenceTable = refTableName,
                    referenceColumn = refColumnName,
                    tableOperations = mockTableOps
                )

                // when
                val result = constraint.validate(sourceTableDef)

                // then
                result.isLeft() shouldBe true
                result.fold(
                    { error -> error.shouldBeTypeOf<ReferenceValidation.ReferenceTableNotFound>() },
                    { throw AssertionError("Should not succeed") }
                )
            }
        }

        it("should fail when column types are incompatible") {
            runTest {
                // given
                val mockTableOps = mockk<TableOperations>()
                val sourceTableDef = mockk<TableDefinition>()
                val columnName = ColumnName.create("test_column").getOrNull()!!
                val refTableName = TableName.create("ref_table").getOrNull()!!
                val refColumnName = ColumnName.create("ref_column").getOrNull()!!

                // Source column with STRING type
                val sourceColumn = mockk<ColumnDefinition>()
                every { sourceColumn.name } returns columnName
                every { sourceColumn.dataType } returns DataType.STRING

                every { sourceTableDef.columns } returns listOf(sourceColumn)

                // Reference table setup
                val refTable = mockk<ADTable>()
                val refColumn = mockk<ColumnDefinition>()
                every { refColumn.name } returns refColumnName
                every { refColumn.dataType } returns DataType.INTEGER // Intentionally incompatible type

                every { refTable.columns } returns listOf(refColumn)
                every { refTable.metadata } returns TestFactory.createMetadata()
                every { refTable.name } returns refTableName
                every { refTable.displayName } returns DisplayName.create("Reference Table").getOrNull()!!
                every { refTable.description } returns null
                every { refTable.accessLevel } returns AccessLevel.SYSTEM

                // Set up TableOperations to return our mock table
                coEvery { mockTableOps.findByName(refTableName.value) } returns refTable.right()

                val constraint = ReferenceConstraint(
                    metadata = TestFactory.createMetadata(),
                    column = columnName,
                    referenceTable = refTableName,
                    referenceColumn = refColumnName,
                    tableOperations = mockTableOps
                )

                // when
                val result = constraint.validate(sourceTableDef)

                // then
                result.isLeft() shouldBe true
                result.fold(
                    { error -> error.shouldBeTypeOf<ReferenceValidation.IncompatibleTypes>() },
                    { throw AssertionError("Should not succeed") }
                )
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/table/constraint/UniqueConstraintTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.constraint.UniqueConstraintTest


package org.blackerp.domain.table.constraint

import arrow.core.right
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.domain.values.ColumnName
import org.blackerp.shared.TestFactory
import java.time.Instant  // Required by EntityMetadata
import java.util.UUID    // Required by EntityMetadata

class UniqueConstraintTest : DescribeSpec({
    describe("UniqueConstraint") { 
        
        it("should validate when all columns exist") {
            // given
            val columnName = ColumnName.create("test_column").getOrNull()!!
            val mockColumn = mockk<ColumnDefinition>()
            every { mockColumn.name } returns columnName
            
            val mockTable = mockk<TableDefinition>()
            every { mockTable.columns } returns listOf(mockColumn)
            
            val constraint = UniqueConstraint(
                metadata = TestFactory.createMetadata(),
                columns = listOf(columnName)
            )
            
            // when
            val result = constraint.validate(mockTable)
            
            // then
            result.isRight() shouldBe true
        }
        
        it("should fail when columns dont exist") {
            // given
            val columnName = ColumnName.create("test_column").getOrNull()!!
            val mockTable = mockk<TableDefinition>()
            every { mockTable.columns } returns emptyList()
            
            val constraint = UniqueConstraint(
                metadata = TestFactory.createMetadata(),
                columns = listOf(columnName)
            )
            
            // when
            val result = constraint.validate(mockTable)
            
            // then
            result.isLeft() shouldBe true
        }
    }
})




File: ./src/test/kotlin/org/blackerp/domain/table/constraint/NotNullConstraintTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.constraint.NotNullConstraintTest


package org.blackerp.domain.table.constraint

import arrow.core.right
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.table.definition.TableDefinition
import org.blackerp.domain.values.ColumnName
import org.blackerp.shared.TestFactory
import java.time.Instant  // Required by EntityMetadata
import java.util.UUID    // Required by EntityMetadata

class NotNullConstraintTest : DescribeSpec({
    describe("NotNullConstraint") {
        
        it("should validate when column exists") {
            // given
            val columnName = ColumnName.create("test_column").getOrNull()!!
            val mockColumn = mockk<ColumnDefinition>()
            every { mockColumn.name } returns columnName
            
            val mockTable = mockk<TableDefinition>()
            every { mockTable.columns } returns listOf(mockColumn)
            
            val constraint = NotNullConstraint(
                metadata = TestFactory.createMetadata(),
                column = columnName
            )
            
            // when
            val result = constraint.validate(mockTable)
            
            // then
            result.isRight() shouldBe true
        }
        
        it("should fail when column doesnt exist") {
            // given
            val columnName = ColumnName.create("test_column").getOrNull()!!
            val mockTable = mockk<TableDefinition>()
            every { mockTable.columns } returns emptyList()
            
            val constraint = NotNullConstraint(
                metadata = TestFactory.createMetadata(),
                column = columnName
            )
            
            // when
            val result = constraint.validate(mockTable)
            
            // then
            result.isLeft() shouldBe true
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/table/definition/TableDefinitionTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.definition.TableDefinitionTest

package org.blackerp.domain.table.definition

import arrow.core.right
import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.mockk.mockk
import io.mockk.every
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.values.*
import org.blackerp.shared.TestFactory
import java.time.Instant  
import java.util.UUID     

class TableDefinitionTest : DescribeSpec({
    describe("TableDefinition") { 

        describe("create") {
            it("should create valid table definition") {
                // given
                val columnName = ColumnName.create("test_column").getOrNull()!!
                val mockColumn = mockk<ColumnDefinition> {
                    // Configure the mock to return values when accessed
                    every { name } returns columnName
                    every { metadata } returns TestFactory.createMetadata()
                    // Add any other necessary properties that might be accessed
                }
                
                val params = CreateTableParams(
                    metadata = TestFactory.createMetadata(),
                    name = TestFactory.createValidTableName(),
                    displayName = TestFactory.createValidDisplayName(),
                    description = null,
                    accessLevel = AccessLevel.SYSTEM,
                    columns = listOf(mockColumn)
                )

                // when
                val result = TableDefinition.create(params)

                // then
                result.isRight() shouldBe true
                result.map { table ->
                    table.columns.size shouldBe 1
                    table.columns.first().name shouldBe columnName
                }
            }

            it("should fail with no columns") {
                // given
                val params = CreateTableParams(
                    metadata = TestFactory.createMetadata(),
                    name = TestFactory.createValidTableName(),
                    displayName = TestFactory.createValidDisplayName(),
                    description = null,
                    accessLevel = AccessLevel.SYSTEM,
                    columns = emptyList()
                )

                // when
                val result = TableDefinition.create(params)

                // then
                result.isLeft() shouldBe true
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/table/TableOperationsTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.TableOperationsTest

// File: src/test/kotlin/org/blackerp/domain/table/TableOperationsTest.kt
package org.blackerp.domain.table

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.*
import org.blackerp.shared.TestFactory
import org.blackerp.infrastructure.persistence.store.InMemoryTableOperations

class TableOperationsTest : DescribeSpec({
    lateinit var operations: InMemoryTableOperations

    beforeTest {
        operations = InMemoryTableOperations()
    }

    describe("TableOperations") {
        context("saving and retrieving tables") {
            it("should save and retrieve table") {
                runTest {
                    // Create test table
                    val table = TestFactory.createTestTable()

                    // Save table
                    val savedResult = operations.save(table)
                    savedResult.isRight() shouldBe true

                    // Retrieve table
                    val retrievedResult = operations.findById(table.metadata.id)
                    retrievedResult.isRight() shouldBe true

                    val retrievedTable = retrievedResult.getOrNull()!!
                    retrievedTable.name.value shouldBe table.name.value
                    retrievedTable.displayName.value shouldBe table.displayName.value
                    retrievedTable.description?.value shouldBe table.description?.value
                }
            }
        }

        context("finding by name") {
            it("should find table by name") {
                runTest {
                    // Create and save test table
                    val table = TestFactory.createTestTable()
                    operations.save(table)

                    // Find by name
                    val foundResult = operations.findByName(table.name.value)
                    foundResult.isRight() shouldBe true

                    val foundTable = foundResult.getOrNull()!!
                    foundTable.metadata.id shouldBe table.metadata.id
                }
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/domain/table/relationship/TableRelationshipTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.relationship.TableRelationshipTest

package org.blackerp.domain.table.relationship

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.value.RelationType
import org.blackerp.domain.table.relationship.value.RelationshipName
import org.blackerp.shared.TestFactory

class TableRelationshipTest : DescribeSpec({
    describe("TableRelationship") {
        context("creation") {
            it("should create valid relationship") {
                // Create test parameters
                val params = CreateRelationshipParams(
                    metadata = TestFactory.createMetadata(),
                    name = RelationshipName.create("test_relation").getOrNull()!!,
                    sourceTable = TableName.create("source_table").getOrNull()!!,
                    targetTable = TableName.create("target_table").getOrNull()!!,
                    type = RelationType.ONE_TO_MANY,
                    sourceColumn = ColumnName.create("source_id").getOrNull()!!,
                    targetColumn = ColumnName.create("target_id").getOrNull()!!
                )

                // Create relationship
                val result = TableRelationship.create(params)

                // Verify
                result.isRight() shouldBe true
                result.map { relationship ->
                    relationship.name.value shouldBe "test_relation"
                    relationship.type shouldBe RelationType.ONE_TO_MANY
                }
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipOperationsTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.relationship.RelationshipOperationsTest

package org.blackerp.domain.table.relationship

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import io.kotest.matchers.collections.shouldNotBeEmpty
import io.kotest.matchers.types.shouldBeTypeOf
import io.kotest.assertions.arrow.core.shouldBeRight
import io.kotest.assertions.arrow.core.shouldBeLeft

import kotlinx.coroutines.test.runTest
import org.blackerp.domain.table.TableError
import org.blackerp.infrastructure.persistence.store.InMemoryRelationshipOperations
import org.slf4j.LoggerFactory

class RelationshipOperationsTest : DescribeSpec({
    val logger = LoggerFactory.getLogger(RelationshipOperationsTest::class.java)
    
    lateinit var operations: RelationshipOperations

    beforeTest {
        operations = InMemoryRelationshipOperations()
    }

    describe("RelationshipOperations") {
        it("should save and retrieve relationship") {
            runTest {
                val relationship = RelationshipTestFactory.createValidRelationship()
                logger.debug("Created test relationship: ${relationship.name.value}")

                val saveResult = operations.save(relationship)
                val findResult = operations.findById(relationship.metadata.id)

                saveResult.shouldBeRight().also { saved ->
                    saved.metadata.id shouldBe relationship.metadata.id
                    saved.name shouldBe relationship.name
                }
                
                findResult.shouldBeRight().also { found ->
                    found shouldNotBe null
                    found?.metadata?.id shouldBe relationship.metadata.id
                    found?.name shouldBe relationship.name
                }
            }
        }

        it("should find relationships by table") {
            runTest {
                val relationship = RelationshipTestFactory.createValidRelationship()
                
                operations.save(relationship).shouldBeRight()

                val result = operations.findByTable(relationship.sourceTable)
                
                result.shouldBeRight().also { relationships ->
                    relationships.shouldNotBeEmpty()
                    relationships.size shouldBe 1
                    val foundRelationship = relationships[0]
                    foundRelationship.shouldBeTypeOf<TableRelationship>()
                    foundRelationship.sourceTable.value shouldBe relationship.sourceTable.value
                    foundRelationship.metadata.id shouldBe relationship.metadata.id
                }
            }
        }

        it("should prevent duplicate relationship names") {
            runTest {
                val first = RelationshipTestFactory.createValidRelationship()
                val second = RelationshipTestFactory.createValidRelationship()

                operations.save(first).shouldBeRight()
                operations.save(second).shouldBeLeft().also { error ->
                    error shouldBe TableError.DuplicateTable(second.name.value)
                }
            }
        }

        it("should delete relationship") {
            runTest {
                val relationship = RelationshipTestFactory.createValidRelationship()
                
                operations.save(relationship).shouldBeRight()
                
                operations.delete(relationship.metadata.id).shouldBeRight()
                operations.findById(relationship.metadata.id).shouldBeRight() shouldBe null
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipTestFactory.kt
// Classpath: src.test.kotlin.org.blackerp.domain.table.relationship.RelationshipTestFactory

// File: src/test/kotlin/org/blackerp/domain/table/relationship/RelationshipTestFactory.kt
package org.blackerp.domain.table.relationship

import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.values.TableName
import org.blackerp.domain.values.ColumnName
import org.blackerp.domain.table.relationship.value.*
import org.blackerp.domain.table.relationship.constraint.IndexConstraint
import org.blackerp.shared.TestFactory
import org.blackerp.domain.table.relationship.value.DeleteRule
import org.blackerp.domain.table.relationship.value.UpdateRule

object RelationshipTestFactory {
    fun createValidRelationship(): TableRelationship {
        val metadata = TestFactory.createMetadata()
        return TableRelationship(
            metadata = metadata,
            name = createValidRelationshipName(),
            sourceTable = createValidTableName("source_table"),
            targetTable = createValidTableName("target_table"),
            type = RelationType.ONE_TO_MANY,
            sourceColumn = createValidColumnName("source_id"),
            targetColumn = createValidColumnName("target_id"),
            constraints = listOf(createValidIndexConstraint("target_id")),
            deleteRule = DeleteRule.RESTRICT,
            updateRule = UpdateRule.RESTRICT
        )
    }

    fun createValidRelationshipParams(): CreateRelationshipParams {
        return CreateRelationshipParams(
            metadata = TestFactory.createMetadata(),
            name = createValidRelationshipName(),
            sourceTable = createValidTableName("source_table"),
            targetTable = createValidTableName("target_table"),
            type = RelationType.ONE_TO_MANY,
            sourceColumn = createValidColumnName("source_id"),
            targetColumn = createValidColumnName("target_id"),
            constraints = listOf(createValidIndexConstraint("target_id")),
            deleteRule = DeleteRule.RESTRICT,
            updateRule = UpdateRule.RESTRICT
        )
    }

    private fun createValidRelationshipName(): RelationshipName =
        RelationshipName.create("test_relation").getOrNull()
            ?: throw IllegalStateException("Failed to create valid relationship name")

    private fun createValidTableName(name: String): TableName =
        TableName.create(name).getOrNull()
            ?: throw IllegalStateException("Failed to create valid table name: $name")

    private fun createValidColumnName(name: String): ColumnName =
        ColumnName.create(name).getOrNull()
            ?: throw IllegalStateException("Failed to create valid column name: $name")

    private fun createValidIndexConstraint(columnName: String): IndexConstraint {
        val column = createValidColumnName(columnName)
        return IndexConstraint(
            metadata = TestFactory.createMetadata(),
            columns = listOf(column)
        )
    }

    fun createManyToManyParams(): CreateRelationshipParams {
        return CreateRelationshipParams(
            metadata = TestFactory.createMetadata(),
            name = createValidRelationshipName(),
            sourceTable = createValidTableName("table_a"),
            targetTable = createValidTableName("table_b"),
            type = RelationType.MANY_TO_MANY,
            sourceColumn = createValidColumnName("a_id"),
            targetColumn = createValidColumnName("b_id"),
            junctionTable = createValidTableName("junction_table")
        )
    }

    fun createSelfReferenceParams(): CreateRelationshipParams {
        val tableName = createValidTableName("self_ref_table")
        return CreateRelationshipParams(
            metadata = TestFactory.createMetadata(),
            name = createValidRelationshipName(),
            sourceTable = tableName,
            targetTable = tableName,
            type = RelationType.ONE_TO_MANY,
            sourceColumn = createValidColumnName("parent_id"),
            targetColumn = createValidColumnName("child_id"),
            constraints = listOf(createValidIndexConstraint("child_id"))
        )
    }
}


File: ./src/test/kotlin/org/blackerp/domain/EntityMetadataTest.kt
// Classpath: src.test.kotlin.org.blackerp.domain.EntityMetadataTest

package org.blackerp.domain

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe

class EntityMetadataTest : DescribeSpec({
    describe("EntityMetadata") {
        it("should create with default values") {
            val metadata = EntityMetadata(
                createdBy = "test-user",
                updatedBy = "test-user"
            )
            
            metadata.createdBy shouldBe "test-user"
            metadata.updatedBy shouldBe "test-user"
            metadata.version shouldBe 0
            metadata.active shouldBe true
            metadata.id shouldNotBe null
        }

        it("should create with custom values") {
            val metadata = EntityMetadata(
                createdBy = "test-user",
                updatedBy = "test-user",
                version = 1,
                active = false
            )
            
            metadata.version shouldBe 1
            metadata.active shouldBe false
        }
    }
})



File: ./src/test/kotlin/org/blackerp/config/UnifiedTestConfig.kt
// Classpath: src.test.kotlin.org.blackerp.config.UnifiedTestConfig

package org.blackerp.config

import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType
import javax.sql.DataSource
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.domain.table.TableOperations
import org.blackerp.infrastructure.event.EventPublisher
import org.blackerp.infrastructure.persistence.store.*
import org.springframework.boot.test.web.client.TestRestTemplate
import io.mockk.mockk
import org.springframework.boot.autoconfigure.flyway.FlywayMigrationStrategy

@TestConfiguration
class UnifiedTestConfig {
    
    @Bean
    @Primary
    fun dataSource(): DataSource {
        return EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript("db/h2-schema.sql")
            .build()
    }

    @Bean
    fun jdbcTemplate(dataSource: DataSource): JdbcTemplate = 
        JdbcTemplate(dataSource)

    @Bean
    fun testRestTemplate(): TestRestTemplate = 
        TestRestTemplate()

    @Bean
    fun eventPublisher(): EventPublisher = 
        mockk(relaxed = true)

    @Bean
    @Primary
    fun tableOperations(jdbcTemplate: JdbcTemplate): TableOperations =
        PostgresTableOperations(jdbcTemplate)

    @Bean
    fun postgresTabOperations(
        jdbcTemplate: JdbcTemplate,
        tableOperations: TableOperations
    ): PostgresTabOperations =
        PostgresTabOperations(jdbcTemplate, tableOperations)

    @Bean
    fun createTableUseCase(
        tableOperations: TableOperations,
        eventPublisher: EventPublisher
    ): CreateTableUseCase =
        CreateTableUseCase(tableOperations, eventPublisher)

    @Bean
    fun flywayMigrationStrategy(): FlywayMigrationStrategy =
        FlywayMigrationStrategy { _ -> /* disable automatic migrations */ }
}


File: ./src/test/kotlin/org/blackerp/config/TestConfig.kt
// Classpath: src.test.kotlin.org.blackerp.config.TestConfig

// File: src/test/kotlin/org/blackerp/config/TestConfig.kt
package org.blackerp.config

import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import org.springframework.jdbc.core.JdbcTemplate
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType
import javax.sql.DataSource
import com.fasterxml.jackson.databind.ObjectMapper
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.api.mappers.TableMapper
import org.blackerp.infrastructure.event.EventPublisher
import org.blackerp.infrastructure.persistence.store.InMemoryTableOperations
import io.mockk.mockk

@TestConfiguration
class TestConfig {
    
    @Bean
    @Primary
    fun dataSource(): DataSource =
        EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build()

    @Bean
    fun jdbcTemplate(dataSource: DataSource): JdbcTemplate =
        JdbcTemplate(dataSource)
    
    @Bean
    fun objectMapper(): ObjectMapper = ObjectMapper()
    
    @Bean
    fun tableMapper(): TableMapper = TableMapper()
    
    @Bean
    fun eventPublisher(): EventPublisher = mockk(relaxed = true)
    
    @Bean
    fun createTableUseCase(
        eventPublisher: EventPublisher
    ): CreateTableUseCase = CreateTableUseCase(
        operations = InMemoryTableOperations(),
        eventPublisher = eventPublisher
    )
}



File: ./src/test/kotlin/org/blackerp/config/KotestProjectConfig.kt
// Classpath: src.test.kotlin.org.blackerp.config.KotestProjectConfig

// File: src/test/kotlin/org/blackerp/config/KotestProjectConfig.kt
package org.blackerp.config

import io.kotest.core.config.AbstractProjectConfig
import io.kotest.core.spec.IsolationMode
import io.kotest.extensions.spring.SpringExtension

class KotestProjectConfig : AbstractProjectConfig() {
    override val isolationMode = IsolationMode.InstancePerLeaf
    override fun extensions() = listOf(SpringExtension)
}


File: ./src/test/kotlin/org/blackerp/api/controllers/TableControllerTest.kt
// Classpath: src.test.kotlin.org.blackerp.api.controllers.TableControllerTest

package org.blackerp.api.controllers

import com.ninjasquad.springmockk.MockkBean
import io.kotest.core.spec.style.DescribeSpec
import io.mockk.coEvery
import kotlinx.coroutines.test.runTest
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.api.mappers.TableMapper
import org.blackerp.shared.TestFactory
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc
import org.springframework.test.web.servlet.MockMvc
import org.springframework.beans.factory.annotation.Autowired
import org.springframework.http.MediaType
import org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
import org.springframework.test.web.servlet.result.MockMvcResultMatchers.status
import com.fasterxml.jackson.databind.ObjectMapper
import arrow.core.right

@WebMvcTest(TableController::class)
@AutoConfigureMockMvc(addFilters = false)
class TableControllerTest : DescribeSpec() {

    @Autowired
    private lateinit var mockMvc: MockMvc

    @MockkBean
    private lateinit var createTableUseCase: CreateTableUseCase

    @MockkBean
    private lateinit var tableMapper: TableMapper

    private val objectMapper = ObjectMapper()

    init {
        describe("TableController") {
            context("POST /api/tables") {
                it("should create table successfully") {
                    runTest {
                        // given
                        val request = TestFactory.createTableRequest()
                        val command = TestFactory.createTableCommand()
                        val table = TestFactory.createTestTable()
                        val response = TestFactory.createTableResponse()

                        // Configure mocks
                        coEvery { tableMapper.toCommand(request) } returns command
                        coEvery { createTableUseCase.execute(command) } returns table.right()
                        coEvery { tableMapper.toResponse(table) } returns response

                        // when/then
                        mockMvc.perform(
                            post("/api/tables")
                                .contentType(MediaType.APPLICATION_JSON)
                                .content(objectMapper.writeValueAsString(request))
                        ).andExpect(status().isOk)
                    }
                }
            }
        }
    }
}


File: ./src/test/kotlin/org/blackerp/application/table/CreateTableUseCaseTest.kt
// Classpath: src.test.kotlin.org.blackerp.application.table.CreateTableUseCaseTest

package org.blackerp.application.table

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.types.shouldBeTypeOf
import io.mockk.coEvery
import io.mockk.mockk
import io.mockk.slot
import arrow.core.Either
import arrow.core.right
import kotlinx.coroutines.test.runTest
import org.blackerp.domain.values.AccessLevel
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.values.DataType
import org.blackerp.domain.table.TableError
import org.blackerp.domain.table.TableOperations
import org.blackerp.infrastructure.event.EventPublisher

class CreateTableUseCaseTest : DescribeSpec({
    lateinit var operations: TableOperations
    lateinit var eventPublisher: EventPublisher
    lateinit var useCase: CreateTableUseCase

    beforeTest {
        operations = mockk(relaxed = true) {
            coEvery { save(any()) } returns mockk<ADTable>().right()
        }
        eventPublisher = mockk(relaxed = true)
        useCase = CreateTableUseCase(operations, eventPublisher)
    }

    describe("execute") {
        context("with valid command") {
            val columns = listOf(
                CreateColumnCommand(
                    name = "column_name",
                    displayName = "Column Name",
                    description = "A test column",
                    dataType = DataType.STRING,
                    length = 50,
                    precision = null,
                    scale = null
                )
            )

            val command = CreateTableCommand(
                name = "test_table",
                displayName = "Test Table",
                description = "A test table",
                accessLevel = AccessLevel.SYSTEM,
                createdBy = "test-user",
                columns = columns
            )

            it("should create and store table") {
                runTest {
                    // given
                    val tableSlot = slot<ADTable>()
                    coEvery { operations.save(capture(tableSlot)) } answers { 
                        tableSlot.captured.right() 
                    }

                    // when
                    val result = useCase.execute(command)

                    // then
                    result.fold(
                        { error -> throw AssertionError("Should not fail: $error") },
                        { table ->
                            table.name.value shouldBe "test_table"
                            table.displayName.value shouldBe "Test Table"
                            table.description?.value shouldBe "A test table"
                            table.accessLevel shouldBe AccessLevel.SYSTEM
                            table.metadata.createdBy shouldBe "test-user"
                        }
                    )
                }
            }
        }

        context("with invalid command") {
            val columns = listOf(
                CreateColumnCommand(
                    name = "column_name",
                    displayName = "",
                    description = "A test column with an invalid name",
                    dataType = DataType.STRING,
                    length = 50,
                    precision = null,
                    scale = null
                )
            )

            val command = CreateTableCommand(
                name = "Invalid Name!",
                displayName = "",
                description = "A".repeat(300),
                accessLevel = AccessLevel.SYSTEM,
                createdBy = "test-user",
                columns = columns
            )

            it("should return validation errors") {
                runTest {
                    // when
                    val result = useCase.execute(command)

                    // then
                    result.fold(
                        { error ->
                            error.shouldBeTypeOf<TableError.ValidationFailed>()
                            error.errors.size shouldBe 3
                        },
                        { throw AssertionError("Should not succeed") }
                    )
                }
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/shared/TimeBasedIdTest.kt
// Classpath: src.test.kotlin.org.blackerp.shared.TimeBasedIdTest

package org.blackerp.shared

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.matchers.shouldNotBe
import java.util.UUID

class TimeBasedIdTest : DescribeSpec({
    describe("TimeBasedId") {
        describe("generate") {
            it("should generate time-based UUIDs") {
                // Generate two IDs with a small delay
                val id1 = TimeBasedId.generate()
                Thread.sleep(1) // Minimal delay
                val id2 = TimeBasedId.generate()

                // Verify they are different
                id1 shouldNotBe id2

                // Verify version 1 (time-based) UUID
                (id1.version() == 1) shouldBe true
                (id2.version() == 1) shouldBe true
            }
        }
    }
})


File: ./src/test/kotlin/org/blackerp/shared/TestFactory.kt
// Classpath: src.test.kotlin.org.blackerp.shared.TestFactory

package org.blackerp.shared

import org.blackerp.api.dto.CreateTableRequest
import org.blackerp.api.dto.CreateColumnRequest
import org.blackerp.api.dto.TableResponse
import org.blackerp.application.table.CreateTableCommand
import org.blackerp.application.table.CreateColumnCommand
import org.blackerp.domain.EntityMetadata
import org.blackerp.domain.table.ADTable
import org.blackerp.domain.table.ColumnDefinition
import org.blackerp.domain.values.*
import java.time.Instant
import java.util.UUID

object TestFactory {
    fun createMetadata(
        id: UUID = TimeBasedId.generate(),
        createdBy: String = "test-user",
        updatedBy: String = createdBy,
        version: Int = 0,
        active: Boolean = true
    ) = EntityMetadata(
        id = id,
        created = Instant.now(),
        createdBy = createdBy,
        updated = Instant.now(),
        updatedBy = updatedBy,
        version = version,
        active = active
    )

    fun createValidTableName(name: String = "test_table") = 
        TableName.create(name).getOrNull()
            ?: throw IllegalStateException("Failed to create valid table name: $name")

    fun createValidDisplayName(name: String = "Test Table") = 
        DisplayName.create(name).getOrNull()
            ?: throw IllegalStateException("Failed to create valid display name: $name")

    fun createValidDescription(text: String = "Test description") = 
        Description.create(text).getOrNull()

    fun createTestColumn(): ColumnDefinition {
        val metadata = createMetadata()
        val name = ColumnName.create("test_column").getOrNull()!!
        val displayName = DisplayName.create("Test Column").getOrNull()!!
        val description = Description.create("Test column description").getOrNull()
        val length = Length.create(50).getOrNull()!!

        return ColumnDefinition(
            metadata = metadata,
            name = name,
            displayName = displayName,
            description = description,
            dataType = DataType.STRING,
            length = length,
            precision = null,
            scale = null,
            mandatory = false,
            defaultValue = null
        )
    }

    // Add inside TestFactory object
    fun createTableRequest() = CreateTableRequest(
        name = "test_table",
        displayName = "Test Table",
        description = "Test Description",
        accessLevel = "SYSTEM",
        columns = listOf(
            CreateColumnRequest(
                name = "test_column",
                displayName = "Test Column",
                description = "Test column description",
                dataType = "STRING",
                length = 50,
                precision = null,
                scale = null
            )
        )
    )

    fun createTableCommand() = CreateTableCommand(
        name = "test_table",
        displayName = "Test Table",
        description = "Test Description",
        accessLevel = AccessLevel.SYSTEM,
        createdBy = "test-user",
        columns = listOf(
            CreateColumnCommand(
                name = "test_column",
                displayName = "Test Column",
                description = "Test column description", 
                dataType = DataType.STRING,
                length = 50,
                precision = null,
                scale = null
            )
        )
    )

    fun createTableResponse() = TableResponse(
        id = UUID.randomUUID(),
        name = "test_table",
        displayName = "Test Table",
        description = "Test Description",
        accessLevel = "SYSTEM"
    )

    fun createTestTable(
        id: UUID = TimeBasedId.generate(),
        name: String = "test_table",
        displayName: String = "Test Table",
        description: String? = "Test Description",
        accessLevel: AccessLevel = AccessLevel.SYSTEM,
        createdBy: String = "test-user",
        updatedBy: String = createdBy
    ): ADTable {
        val metadata = createMetadata(
            id = id,
            createdBy = createdBy,
            updatedBy = updatedBy
        )

        return ADTable(
            metadata = metadata,
            name = createValidTableName(name),
            displayName = createValidDisplayName(displayName),
            description = description?.let { createValidDescription(it) },
            accessLevel = accessLevel,
            columns = listOf(createTestColumn())
        )
    }
}



File: ./src/test/kotlin/org/blackerp/integration/plugin/PluginLifecycleIntegrationTest.kt
// Classpath: src.test.kotlin.org.blackerp.integration.plugin.PluginLifecycleIntegrationTest

package org.blackerp.integration.plugin

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.assertions.arrow.core.shouldBeRight
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.blackerp.integration.IntegrationTestConfig
import org.springframework.context.annotation.Import
import org.blackerp.plugin.*
import org.blackerp.plugin.registry.DefaultPluginRegistry
import org.blackerp.plugin.registry.PluginRegistry

@SpringBootTest
@ActiveProfiles("test")
@Import(IntegrationTestConfig::class)
class PluginLifecycleIntegrationTest : DescribeSpec({
    
    val pluginRegistry: PluginRegistry = DefaultPluginRegistry()
    
    describe("Plugin Lifecycle") {
        it("should load and initialize plugin") {
            // given
            val pluginId = PluginId.create("test-plugin").getOrNull()!!
            val version = Version.create("1.0.0").getOrNull()!!
            val metadata = PluginMetadata.create(
                id = pluginId,
                version = version,
                name = "Test Plugin",
                description = "Test plugin",
                vendor = "Test Vendor"
            ).getOrNull()!!
            
            val plugin = TestPlugin(metadata)
            
            // when
            val registerResult = pluginRegistry.register(plugin)
            
            // then
            registerResult.shouldBeRight()
        }
    }
})



File: ./src/test/kotlin/org/blackerp/integration/api/TableApiIntegrationTest.kt
// Classpath: src.test.kotlin.org.blackerp.integration.api.TableApiIntegrationTest

package org.blackerp.integration.api

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.boot.test.web.client.TestRestTemplate
import org.springframework.boot.test.web.server.LocalServerPort
import org.springframework.http.HttpStatus
import org.springframework.test.context.ActiveProfiles
import org.blackerp.integration.IntegrationTestConfig
import org.springframework.context.annotation.Import
import org.blackerp.api.dto.CreateTableRequest
import org.blackerp.shared.TestFactory

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("test")
@Import(IntegrationTestConfig::class)
class TableApiIntegrationTest(
    private val restTemplate: TestRestTemplate,
    @LocalServerPort private val port: Int
) : DescribeSpec({
    
    describe("Table API") {
        context("POST /api/tables") {
            it("should create table successfully") {
                // given
                val request = TestFactory.createTableRequest()
                
                // when
                val response = restTemplate.postForEntity(
                    "http://localhost:$port/api/tables",
                    request,
                    Any::class.java
                )
                
                // then
                response.statusCode shouldBe HttpStatus.OK
            }
        }
    }
})



File: ./src/test/kotlin/org/blackerp/integration/db/TableRepositoryIntegrationTest.kt
// Classpath: src.test.kotlin.org.blackerp.integration.db.TableRepositoryIntegrationTest

package org.blackerp.integration.db

import io.kotest.core.spec.style.DescribeSpec
import io.kotest.matchers.shouldBe
import io.kotest.assertions.arrow.core.shouldBeRight
import org.springframework.boot.test.context.SpringBootTest
import org.springframework.test.context.ActiveProfiles
import org.blackerp.integration.IntegrationTestConfig
import org.springframework.context.annotation.Import
import org.blackerp.infrastructure.persistence.store.PostgresTableOperations
import org.blackerp.shared.TestFactory
import org.springframework.jdbc.core.JdbcTemplate

@SpringBootTest
@ActiveProfiles("test")
@Import(IntegrationTestConfig::class)
class TableRepositoryIntegrationTest(
    private val jdbcTemplate: JdbcTemplate
) : DescribeSpec({
    
    lateinit var tableOperations: PostgresTableOperations
    
    beforeTest {
        tableOperations = PostgresTableOperations(jdbcTemplate)
    }
    
    describe("TableRepository") {
        it("should save and retrieve table") {
            // given
            val table = TestFactory.createTestTable()
            
            // when
            val saveResult = tableOperations.save(table)
            val findResult = tableOperations.findById(table.metadata.id)
            
            // then
            saveResult.shouldBeRight()
            findResult.shouldBeRight()
        }
    }
})



File: ./src/test/kotlin/org/blackerp/integration/IntegrationTestConfig.kt
// Classpath: src.test.kotlin.org.blackerp.integration.IntegrationTestConfig

package org.blackerp.integration

import org.springframework.boot.test.context.TestConfiguration
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Primary
import javax.sql.DataSource
import org.springframework.boot.test.web.client.TestRestTemplate
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder
import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType
import org.springframework.jdbc.core.JdbcTemplate
import org.blackerp.application.table.CreateTableUseCase
import org.blackerp.infrastructure.event.EventPublisher
import org.blackerp.infrastructure.persistence.store.PostgresTableOperations
import io.mockk.mockk

@TestConfiguration
class IntegrationTestConfig {
    @Bean
    @Primary
    fun dataSource(): DataSource =
        EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .addScript("db/h2-schema.sql")
            .build()

    @Bean
    fun jdbcTemplate(dataSource: DataSource): JdbcTemplate = 
        JdbcTemplate(dataSource)

    @Bean
    fun testRestTemplate() = TestRestTemplate()

    @Bean
    fun eventPublisher(): EventPublisher = mockk(relaxed = true)

    @Bean
    fun tableOperations(jdbcTemplate: JdbcTemplate): PostgresTableOperations =
        PostgresTableOperations(jdbcTemplate)

    @Bean
    fun createTableUseCase(
        tableOperations: PostgresTableOperations,
        eventPublisher: EventPublisher
    ): CreateTableUseCase = CreateTableUseCase(tableOperations, eventPublisher)
}


