Generating folder structure...
-------------------------------------------
.
├── application
│   ├── api
│   │   ├── advice
│   │   │   └── ErrorHandler.kt
│   │   ├── common
│   │   │   ├── ApiImports.kt
│   │   │   ├── BaseService.kt
│   │   │   ├── DomainImports.kt
│   │   │   ├── Imports.kt
│   │   │   ├── ServiceImports.kt
│   │   │   ├── SharedImports.kt
│   │   │   └── WebImports.kt
│   │   ├── controllers
│   │   │   ├── DocumentController.kt
│   │   │   ├── DocumentLifecycleController.kt
│   │   │   ├── Imports.kt
│   │   │   ├── ProcessController.kt
│   │   │   ├── ReferenceController.kt
│   │   │   ├── TableController.kt
│   │   │   └── WorkflowController.kt
│   │   ├── dto
│   │   │   ├── ParameterMapping.kt
│   │   │   ├── requests
│   │   │   │   ├── CreateDocumentRequest.kt
│   │   │   │   ├── CreateProcessRequest.kt
│   │   │   │   └── TableRequests.kt
│   │   │   ├── responses
│   │   │   │   └── TableResponses.kt
│   │   │   └── TableDTO.kt
│   │   ├── extensions
│   │   │   ├── DomainExtensions.kt
│   │   │   └── ProcessExtensions.kt
│   │   ├── mappers
│   │   │   └── TableMapper.kt
│   │   └── process
│   │   ├── ApiCreateProcessCommand.kt
│   │   ├── commands.kt
│   │   ├── CreateProcessCommand.kt
│   │   ├── DomainProcessParameter.kt
│   │   ├── ProcessExtensions.kt
│   │   ├── types.kt
│   │   └── WorkflowCommands.kt
│   ├── Application.kt
│   ├── build.gradle.kts
│   ├── .env
│   ├── services
│   │   ├── ADMetadataService.kt
│   │   ├── base
│   │   │   └── CoroutineBaseService.kt
│   │   ├── cache
│   │   │   └── CacheStrategy.kt
│   │   ├── common
│   │   │   ├── ServiceBase.kt
│   │   │   └── ServiceImports.kt
│   │   ├── config
│   │   │   └── SecurityConfig.kt
│   │   ├── core
│   │   │   ├── ServiceBase.kt
│   │   │   └── ServiceImports.kt
│   │   ├── CoroutineConfig.kt
│   │   ├── docaction
│   │   │   └── DocActionService.kt
│   │   ├── docstatus
│   │   │   └── DocStatusService.kt
│   │   ├── DocumentLifecycleService.kt
│   │   ├── DocumentProcessService.kt
│   │   ├── DocumentService.kt
│   │   ├── error
│   │   │   └── DomainProcessError.kt
│   │   ├── impl
│   │   ├── ImportTransactional.kt
│   │   ├── interfaces
│   │   │   └── ProcessInterfaces.kt
│   │   ├── JwtProperties.kt
│   │   ├── process
│   │   │   └── ProcessServiceImpl.kt
│   │   ├── ProcessService.kt
│   │   ├── ReferenceService.kt
│   │   ├── SecurityFilter.kt
│   │   ├── SecurityService.kt
│   │   ├── table
│   │   │   └── TableManagementService.kt
│   │   ├── TableMetrics.kt
│   │   ├── TableService.kt
│   │   ├── TransactionalImports.kt
│   │   ├── workflow
│   │   │   ├── WorkflowExecutionEngine.kt
│   │   │   ├── WorkflowExecutionTracker.kt
│   │   │   ├── WorkflowExtensions.kt
│   │   │   └── WorkflowServiceImpl.kt
│   │   └── WorkflowService.kt
│   └── usecases
│   ├── document
│   │   ├── CreateDocumentCommand.kt
│   │   └── CreateDocumentUseCase.kt
│   ├── process
│   │   ├── CreateProcessUseCase.kt
│   │   └── ProcessExtensions.kt
│   ├── table
│   ├── window
│   └── workflow
│   ├── CreateWorkflowUseCase.kt
│   └── WorkflowExtensions.kt
├── build_errors.txt
├── build.gradle.kts
├── check_imports.sh
├── compile_output.txt
├── compile.sh
├── correct_importlist.txt
├── diff.patch
├── domain
│   ├── build.gradle.kts
│   ├── core
│   │   ├── ad
│   │   │   ├── base
│   │   │   │   ├── ADModule.kt
│   │   │   │   ├── ADObject.kt
│   │   │   │   ├── ModuleName.kt
│   │   │   │   └── ModuleService.kt
│   │   │   ├── docaction
│   │   │   │   ├── DocActionError.kt
│   │   │   │   ├── DocAction.kt
│   │   │   │   ├── DocActionOperations.kt
│   │   │   │   └── DocActionRegistry.kt
│   │   │   ├── docstatus
│   │   │   │   ├── AD_DocStatus.kt
│   │   │   │   ├── DocStatusError.kt
│   │   │   │   └── DocStatus.kt
│   │   │   ├── document
│   │   │   │   ├── DocumentCommands.kt
│   │   │   │   ├── DocumentError.kt
│   │   │   │   ├── DocumentEvents.kt
│   │   │   │   ├── Document.kt
│   │   │   │   ├── DocumentOperations.kt
│   │   │   │   ├── DocumentProcessHandler.kt
│   │   │   │   ├── DocumentService.kt
│   │   │   │   ├── DocumentStatus.kt
│   │   │   │   └── DocumentType.kt
│   │   │   ├── extension
│   │   │   ├── process
│   │   │   │   ├── ADParameter.kt
│   │   │   │   ├── ADProcess.kt
│   │   │   │   ├── ProcessError.kt
│   │   │   │   ├── ProcessOperations.kt
│   │   │   │   ├── ProcessRepository.kt
│   │   │   │   └── ProcessTypes.kt
│   │   │   ├── reference
│   │   │   │   ├── ADReference.kt
│   │   │   │   ├── ReferenceOperations.kt
│   │   │   │   ├── ReferenceTypes.kt
│   │   │   │   └── value
│   │   │   │   └── ReferenceName.kt
│   │   │   ├── shared
│   │   │   │   └── values
│   │   │   │   └── ProcessName.kt
│   │   │   ├── tab
│   │   │   │   ├── ADTab.kt
│   │   │   │   ├── OrderBySpec.kt
│   │   │   │   ├── TabError.kt
│   │   │   │   ├── TabOperations.kt
│   │   │   │   └── value
│   │   │   │   └── TabName.kt
│   │   │   ├── table
│   │   │   │   ├── ADTable.kt
│   │   │   │   ├── ColumnDefinition.kt
│   │   │   │   ├── commands.kt
│   │   │   │   ├── ConstraintOperations.kt
│   │   │   │   ├── RelationshipOperations.kt
│   │   │   │   ├── TableConstraint.kt
│   │   │   │   ├── TableOperations.kt
│   │   │   │   └── TableRelationship.kt
│   │   │   ├── window
│   │   │   │   └── WindowName.kt
│   │   │   └── workflow
│   │   │   ├── commands.kt
│   │   │   ├── NodeAction.kt
│   │   │   ├── NodeType.kt
│   │   │   ├── WorkflowError.kt
│   │   │   ├── WorkflowNode.kt
│   │   │   ├── WorkflowOperations.kt
│   │   │   ├── WorkflowService.kt
│   │   │   └── WorkflowTransition.kt
│   │   ├── client
│   │   ├── DomainEntity.kt
│   │   ├── DomainException.kt
│   │   ├── error
│   │   │   ├── DomainError.kt
│   │   │   ├── PluginError.kt
│   │   │   ├── ProcessError.kt
│   │   │   ├── TableErrors.kt
│   │   │   ├── UnexpectedError.kt
│   │   │   └── WorkflowErrors.kt
│   │   ├── metadata
│   │   │   ├── ChangeTracking.kt
│   │   │   └── EntityMetadata.kt
│   │   ├── reference
│   │   │   └── ReferenceError.kt
│   │   ├── repository
│   │   │   └── ColumnOperations.kt
│   │   ├── rules
│   │   ├── security
│   │   │   ├── SecurityModel.kt
│   │   │   └── SecurityOperations.kt
│   │   ├── service
│   │   │   └── TableManagementService.kt
│   │   ├── shared
│   │   │   ├── ChangePair.kt
│   │   │   └── ValidationError.kt
│   │   ├── tenant
│   │   │   └── TenantAware.kt
│   │   ├── values
│   │   │   ├── AccessLevel.kt
│   │   │   ├── Amount.kt
│   │   │   ├── ColumnName.kt
│   │   │   ├── Currency.kt
│   │   │   ├── DataType.kt
│   │   │   ├── Description.kt
│   │   │   ├── DisplayName.kt
│   │   │   ├── Length.kt
│   │   │   ├── Precision.kt
│   │   │   ├── Scale.kt
│   │   │   └── TableName.kt
│   │   └── Version.kt
│   ├── events
│   │   ├── ConstraintEvents.kt
│   │   ├── DocumentEvents.kt
│   │   ├── DomainEvent.kt
│   │   ├── EventMetadata.kt
│   │   ├── handlers
│   │   ├── publishers
│   │   ├── RelationshipEvents.kt
│   │   └── WorkflowEvents.kt
│   ├── .gradle
│   │   ├── 4.4.1
│   │   │   ├── fileChanges
│   │   │   │   └── last-build.bin
│   │   │   ├── fileHashes
│   │   │   │   ├── fileHashes.bin
│   │   │   │   └── fileHashes.lock
│   │   │   └── taskHistory
│   │   │   ├── taskHistory.bin
│   │   │   └── taskHistory.lock
│   │   └── buildOutputCleanup
│   │   ├── buildOutputCleanup.lock
│   │   ├── cache.properties
│   │   └── outputFiles.bin
│   ├── gradle
│   │   └── wrapper
│   │   ├── gradle-wrapper.jar
│   │   └── gradle-wrapper.properties
│   ├── gradlew
│   ├── gradlew.bat
│   ├── services
│   │   ├── implementations
│   │   └── interfaces
│   └── validation
│   ├── BaseValidator.kt
│   ├── rules
│   ├── Validator.kt
│   ├── ValidatorRegistry.kt
│   └── validators
│   ├── model
│   └── module
│   └── ModuleValidator.kt
├── fix_application.sh
├── fix_coroutines.sh
├── generate_project_listing.sh
├── .gitattributes
├── .gitignore
├── .gradle
│   ├── 7.5
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   ├── dependencies-accessors.lock
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── 8.5
│   │   ├── checksums
│   │   │   ├── checksums.lock
│   │   │   ├── md5-checksums.bin
│   │   │   └── sha1-checksums.bin
│   │   ├── dependencies-accessors
│   │   │   ├── dependencies-accessors.lock
│   │   │   └── gc.properties
│   │   ├── executionHistory
│   │   │   ├── executionHistory.bin
│   │   │   └── executionHistory.lock
│   │   ├── fileChanges
│   │   │   └── last-build.bin
│   │   ├── fileHashes
│   │   │   ├── fileHashes.bin
│   │   │   ├── fileHashes.lock
│   │   │   └── resourceHashesCache.bin
│   │   ├── gc.properties
│   │   └── vcsMetadata
│   ├── buildOutputCleanup
│   │   ├── buildOutputCleanup.lock
│   │   ├── cache.properties
│   │   └── outputFiles.bin
│   ├── file-system.probe
│   ├── kotlin
│   │   ├── errors
│   │   └── sessions
│   └── vcs-1
│   └── gc.properties
├── gradle
│   └── wrapper
│   ├── gradle-wrapper.jar
│   └── gradle-wrapper.properties
├── gradle_files.txt
├── gradlew
├── gradlew.bat
├── infrastructure
│   ├── build.gradle.kts
│   ├── cache
│   │   ├── configs
│   │   └── providers
│   ├── events
│   │   ├── handlers
│   │   │   ├── ConstraintEventHandler.kt
│   │   │   ├── RelationshipEventHandler.kt
│   │   │   └── WorkflowEventHandler.kt
│   │   └── publishers
│   │   └── DomainEventPublisher.kt
│   ├── integration
│   │   ├── adapters
│   │   │   ├── SystemHealthAdapter.kt
│   │   │   └── TableHealthIndicator.kt
│   │   └── clients
│   ├── messaging
│   │   ├── consumers
│   │   └── publishers
│   ├── persistence
│   │   ├── mappings
│   │   └── repositories
│   │   ├── ConstraintRepository.kt
│   │   ├── DocumentHistoryRepository.kt
│   │   ├── DocumentRepository.kt
│   │   ├── ProcessRepositoryImpl.kt
│   │   ├── ProcessRepository.kt
│   │   ├── RelationshipRepository.kt
│   │   └── WorkflowRepository.kt
│   ├── plugin
│   │   ├── loaders
│   │   └── registry
│   ├── process
│   │   ├── executor
│   │   │   └── ProcessExecutorImpl.kt
│   │   ├── implementation
│   │   ├── tracking
│   │   │   └── ProcessExecutionTracker.kt
│   │   └── validation
│   │   └── ParameterValidator.kt
│   ├── scheduler
│   │   ├── jobs
│   │   └── triggers
│   └── validation
│   └── validators
│   ├── CircularReferenceValidator.kt
│   ├── ColumnValidator.kt
│   ├── CompositeValidator.kt
│   ├── ConstraintValidator.kt
│   ├── RelationshipValidator.kt
│   └── TableValidator.kt
├── KotlinCoreApp2.txt
├── KotlinCoreApp.txt
├── KotlinPOC.txt
├── KotlinProjectCode.txt
├── LICENSE
├── README.md
├── refactor.sh
├── settings.gradle.kts
├── test-import
│   ├── build.gradle.kts
│   ├── create.sh
│   ├── domain
│   │   ├── build.gradle.kts
│   │   └── core
│   │   ├── DomainEntity.kt
│   │   ├── metadata
│   │   │   └── EntityMetadata.kt
│   │   ├── shared
│   │   │   └── ValidationError.kt
│   │   └── values
│   │   └── TableName.kt
│   ├── .gradle
│   │   ├── 4.4.1
│   │   │   ├── fileChanges
│   │   │   │   └── last-build.bin
│   │   │   ├── fileHashes
│   │   │   │   ├── fileHashes.bin
│   │   │   │   └── fileHashes.lock
│   │   │   └── taskHistory
│   │   │   ├── taskHistory.bin
│   │   │   └── taskHistory.lock
│   │   ├── 8.4
│   │   │   ├── checksums
│   │   │   │   ├── checksums.lock
│   │   │   │   ├── md5-checksums.bin
│   │   │   │   └── sha1-checksums.bin
│   │   │   ├── dependencies-accessors
│   │   │   │   ├── dependencies-accessors.lock
│   │   │   │   └── gc.properties
│   │   │   ├── executionHistory
│   │   │   │   ├── executionHistory.bin
│   │   │   │   └── executionHistory.lock
│   │   │   ├── fileChanges
│   │   │   │   └── last-build.bin
│   │   │   ├── fileHashes
│   │   │   │   ├── fileHashes.bin
│   │   │   │   ├── fileHashes.lock
│   │   │   │   └── resourceHashesCache.bin
│   │   │   ├── gc.properties
│   │   │   └── vcsMetadata
│   │   ├── buildOutputCleanup
│   │   │   ├── buildOutputCleanup.lock
│   │   │   ├── cache.properties
│   │   │   └── outputFiles.bin
│   │   ├── file-system.probe
│   │   ├── kotlin
│   │   │   ├── errors
│   │   │   └── sessions
│   │   └── vcs-1
│   │   └── gc.properties
│   ├── gradle
│   │   └── wrapper
│   │   ├── gradle-wrapper.jar
│   │   └── gradle-wrapper.properties
│   ├── gradlew
│   ├── gradlew.bat
│   └── settings.gradle.kts
└── uncategorized_errors.txt

156 directories, 290 files


Generating file details...
-------------------------------------------

File: ./infrastructure/persistence/repositories/ProcessRepositoryImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.error.ProcessError import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flow import java.util.UUID import org.slf4j.LoggerFactory import org.springframework.transaction.annotation.Transactional @Repository class ProcessRepositoryImpl(private val jdbcTemplate:JdbcTemplate) :ProcessOperations {private val logger=LoggerFactory.getLogger(ProcessRepositoryImpl::class.java) @Transactional override suspend fun save(process:ADProcess):Either<ProcessError,ADProcess>=try {logger.debug("Saving process:${process.id}") jdbcTemplate.update(""" INSERT INTO ad_process (id,name,display_name,description,process_type,implementation_type,implementation_value) VALUES (?,?,?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET display_name=EXCLUDED.display_name,description=EXCLUDED.description,process_type=EXCLUDED.process_type,implementation_type=EXCLUDED.implementation_type,implementation_value=EXCLUDED.implementation_value """,process.id,process.displayName.value,process.displayName.value,process.description?.value,process.type.name,getImplementationType(process.implementation),getImplementationValue(process.implementation)) // Handle parameters saveParameters(process.id,process.parameters) process.right()} catch (e:Exception) {logger.error("Failed to save process:${process.id}",e) ProcessError.ValidationFailed(e.message ?:"Save failed").left()} override suspend fun findById(id:UUID):Either<ProcessError,ADProcess?>=try {val process=jdbcTemplate.query(""" SELECT p.*,pp.id as param_id,pp.name as param_name,pp.display_name as param_display_name,pp.description as param_description,pp.parameter_type,pp.is_mandatory,pp.validation_rule FROM ad_process p LEFT JOIN ad_process_parameter pp ON p.id=pp.process_id WHERE p.id=? """,{rs,_->// Map result set to ADProcess val parameters=mutableListOf<ProcessParameter>() ADProcess(metadata=EntityMetadata(id=rs.getString("id"),audit=AuditInfo(createdBy=rs.getString("created_by"),updatedBy=rs.getString("updated_by"))),displayName=DisplayName.create(rs.getString("display_name")) .getOrNull() ?:throw IllegalStateException("Invalid display name"),description=rs.getString("description")?.let {desc->Description.create(desc).getOrNull()},type=ProcessType.valueOf(rs.getString("process_type")),parameters=parameters,implementation=mapImplementation(rs.getString("implementation_type"),rs.getString("implementation_value")),schedule=null // TODO:Add schedule mapping)},id).firstOrNull() process.right()} catch (e:Exception) {logger.error("Failed to find process:$id",e) ProcessError.ValidationFailed(e.message ?:"Find failed").left()} private fun saveParameters(processId:String,parameters:List<ProcessParameter>) {// First delete existing parameters jdbcTemplate.update("DELETE FROM ad_process_parameter WHERE process_id=?",processId) // Then insertnew parameters parameters.forEach {param->jdbcTemplate.update(""" INSERT INTO ad_process_parameter (id,process_id,name,display_name,description,parameter_type,is_mandatory,validation_rule) VALUES (?,?,?,?,?,?,?,?) """,param.id,processId,param.name,param.displayName,param.description,param.parameterType.name,param.isMandatory,param.validationRule)}} private fun getImplementationType(implementation:ProcessImplementation):String=when (implementation) {is ProcessImplementation.JavaClass->"JAVA" is ProcessImplementation.DatabaseFunction->"DB_FUNCTION" is ProcessImplementation.Script->"SCRIPT"} private fun getImplementationValue(implementation:ProcessImplementation):String=when (implementation) {is ProcessImplementation.JavaClass->implementation.className is ProcessImplementation.DatabaseFunction->implementation.functionName is ProcessImplementation.Script->implementation.code} private fun mapImplementation(type:String,value:String):ProcessImplementation=when (type) {"JAVA"->ProcessImplementation.JavaClass(value) "DB_FUNCTION"->ProcessImplementation.DatabaseFunction(value) "SCRIPT"->ProcessImplementation.Script("kotlin",value) else->throw IllegalArgumentException("Unknown implementation type:$type")}} 
File: ./infrastructure/persistence/repositories/DocumentHistoryRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.shared.ChangePair import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Repository class DocumentHistoryRepository(private val jdbcTemplate:JdbcTemplate) {private val logger=LoggerFactory.getLogger(DocumentHistoryRepository::class.java) // In-memory storage for POC private val historyRecords=mutableListOf<DocumentChange>() fun trackChange(change:DocumentChange) {historyRecords.add(change) logger.debug("Tracked change for document:${change.documentId}")} fun getHistory(documentId:UUID):List<DocumentChange>=historyRecords .filter {it.documentId == documentId} .sortedByDescending {it.changedAt} fun getHistoryBetween(documentId:UUID,fromDate:Instant,toDate:Instant):List<DocumentChange>=historyRecords .filter {it.documentId == documentId && it.changedAt in fromDate..toDate} .sortedByDescending {it.changedAt}} 
File: ./infrastructure/persistence/repositories/WorkflowRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.blackerp.domain.core.ad.workflow.* import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.springframework.dao.DataIntegrityViolationException import org.springframework.transaction.annotation.Transactional import org.slf4j.LoggerFactory @Repository class WorkflowRepository(private val jdbcTemplate:JdbcTemplate) :WorkflowOperations {private val logger=LoggerFactory.getLogger(WorkflowRepository::class.java) @Transactional override suspend fun save(node:WorkflowNode):Either<WorkflowError,WorkflowNode>=try {logger.debug("Saving workflow node:${node.id}") jdbcTemplate.update(""" INSERT INTO workflow_node (id,type,display_name,description,action_type,action_data) VALUES (?,?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET type=EXCLUDED.type,display_name=EXCLUDED.display_name,description=EXCLUDED.description,action_type=EXCLUDED.action_type,action_data=EXCLUDED.action_data """,node.id,node.type.name,node.displayName.value,node.description?.value,node.action?.javaClass?.simpleName,node.action?.toString()) // Handle transitions in same transaction handleTransitions(node) node.right()} catch (e:DataIntegrityViolationException) {logger.error("Constraint violation while saving node:${node.id}",e) WorkflowError.InvalidNode("Constraint violation:${e.message}").left()} catch (e:Exception) {logger.error("Failed to save node:${node.id}",e) WorkflowError.InvalidNode("Save failed:${e.message}").left()} private fun handleTransitions(node:WorkflowNode) {// First delete existing transitions jdbcTemplate.update("DELETE FROM workflow_transition WHERE source_node_id=?",node.id) // Then insertnew transitions node.transitions.forEach {transition->jdbcTemplate.update(""" INSERT INTO workflow_transition (id,source_node_id,target_node_id,condition_expression) VALUES (?,?,?,?) """,transition.id,node.id,transition.targetNode,transition.condition?.expression)}}} 
File: ./infrastructure/persistence/repositories/DocumentRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.blackerp.domain.core.ad.document.* import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID @Repository class DocumentRepository(private val jdbcTemplate:JdbcTemplate) :DocumentOperations {override suspend fun save(document:Document):Either<DocumentError,Document>=try {// TODO:Implement save logic document.right()} catch (e:Exception) {DocumentError.ValidationFailed(e.message ?:"Save failed").left()} override suspend fun findById(id:UUID):Either<DocumentError,Document?>=try {// TODO:Implement find logic null.right()} catch (e:Exception) {DocumentError.ValidationFailed(e.message ?:"Find failed").left()} override suspend fun delete(id:UUID):Either<DocumentError,Unit>=try {// TODO:Implement delete logic Unit.right()} catch (e:Exception) {DocumentError.ValidationFailed(e.message ?:"Delete failed").left()} override suspend fun update(id:UUID,document:Document):Either<DocumentError,Document>=try {// TODO:Implement update logic document.right()} catch (e:Exception) {DocumentError.ValidationFailed(e.message ?:"Update failed").left()} override suspend fun changeStatus(id:UUID,status:DocumentStatus):Either<DocumentError,Document>=try {// TODO:Implement status update logic findById(id).fold({error->error.left()},{document->document?.copy(status=status)?.right() ?:DocumentError.NotFound(id).left()})} catch (e:Exception) {DocumentError.ValidationFailed(e.message ?:"Status update failed").left()} override suspend fun search(criteria:SearchCriteria):kotlinx.coroutines.flow.Flow<Document>=kotlinx.coroutines.flow.flowOf() // TODO:Implement search} 
File: ./infrastructure/persistence/repositories/ConstraintRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.slf4j.LoggerFactory import org.springframework.dao.DataIntegrityViolationException @Repository class ConstraintRepository(private val jdbcTemplate:JdbcTemplate) :ConstraintOperations {private val logger=LoggerFactory.getLogger(ConstraintRepository::class.java) @Transactional override suspend fun save(constraint:TableConstraint):Either<TableError,TableConstraint>=try {logger.debug("Saving constraint:${constraint.id}") // Save main constraint jdbcTemplate.update(""" INSERT INTO table_constraint (id,table_id,name,constraint_type,expression) VALUES (?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET name=EXCLUDED.name,constraint_type=EXCLUDED.constraint_type,expression=EXCLUDED.expression """,constraint.id,constraint.tableId,constraint.name,constraint.type.name,constraint.expression) // Save constraint columns saveConstraintColumns(constraint) constraint.right()} catch (e:DataIntegrityViolationException) {logger.error("Constraint violation while saving constraint:${constraint.id}",e) TableError.ValidationError(message="Constraint violation:${e.message}",violations=listOf(TableError.Violation("constraint","Database constraint violation",null))).left()} catch (e:Exception) {logger.error("Failed to save constraint:${constraint.id}",e) TableError.DatabaseError(message="Failed to save constraint:${e.message}",sqlState=null,errorCode=null).left()} private fun saveConstraintColumns(constraint:TableConstraint) {// First delete existing columns jdbcTemplate.update("DELETE FROM table_constraint_column WHERE constraint_id=?",constraint.id) // Then insertnew columns constraint.columns.forEach {column->jdbcTemplate.update(""" INSERT INTO table_constraint_column (constraint_id,column_name) VALUES (?,?) """,constraint.id,column)}} override suspend fun findByTable(tableId:UUID):Either<TableError,List<TableConstraint>>=try {val constraints=jdbcTemplate.query(""" SELECT c.id,c.table_id,c.name,c.constraint_type,c.expression,array_agg(cc.column_name) as columns FROM table_constraint c LEFT JOIN table_constraint_column cc ON c.id=cc.constraint_id WHERE c.table_id=? GROUP BY c.id,c.table_id,c.name,c.constraint_type,c.expression """,{rs,_->TableConstraint(id=UUID.fromString(rs.getString("id")),tableId=UUID.fromString(rs.getString("table_id")),name=rs.getString("name"),type=ConstraintType.valueOf(rs.getString("constraint_type")),columns=(rs.getArray("columns")?.array as Array<String>?)?.toList() ?:emptyList(),expression=rs.getString("expression"))},tableId) constraints.right()} catch (e:Exception) {logger.error("Failed to find constraints for table:$tableId",e) TableError.DatabaseError(message="Failed to find constraints:${e.message}",sqlState=null,errorCode=null).left()} @Transactional override suspend fun delete(id:UUID):Either<TableError,Unit>=try {// First delete constraint columns jdbcTemplate.update("DELETE FROM table_constraint_column WHERE constraint_id=?",id) // Then delete the constraint val deleted=jdbcTemplate.update("DELETE FROM table_constraint WHERE id=?",id) if (deleted> 0) Unit.right() else TableError.ValidationError(message="Constraint not found",violations=listOf(TableError.Violation("id","No constraint found with this ID",id))).left()} catch (e:Exception) {logger.error("Failed to delete constraint:$id",e) TableError.DatabaseError(message="Failed to delete constraint:${e.message}",sqlState=null,errorCode=null).left()} override suspend fun validateConstraint(constraint:TableConstraint):Either<TableError,Unit>=when (constraint.type) {ConstraintType.UNIQUE->validateUniqueConstraint(constraint) ConstraintType.CHECK->validateCheckConstraint(constraint) ConstraintType.FOREIGN_KEY->validateForeignKeyConstraint(constraint)} private suspend fun validateUniqueConstraint(constraint:TableConstraint):Either<TableError,Unit>=try {val count=jdbcTemplate.queryForObject(""" SELECT COUNT(*) FROM (SELECT ${constraint.columns.joinToString(",")} FROM ${getTableName(constraint.tableId)} GROUP BY ${constraint.columns.joinToString(",")} HAVING COUNT(*)> 1) t """,Int::class.java) if (count == 0) Unit.right() else TableError.ValidationError(message="Unique constraint violation",violations=listOf(TableError.Violation("constraint","Duplicate values found",constraint.name))).left()} catch (e:Exception) {logger.error("Failed to validate unique constraint:${constraint.id}",e) TableError.DatabaseError(message="Failed to validate constraint:${e.message}",sqlState=null,errorCode=null).left()} private suspend fun validateCheckConstraint(constraint:TableConstraint):Either<TableError,Unit>=try {// Validate the check constraint expression jdbcTemplate.queryForObject(""" SELECT COUNT(*) FROM ${getTableName(constraint.tableId)} WHERE NOT (${constraint.expression}) """,Int::class.java)?.let {violations->if (violations == 0) Unit.right() else TableError.ValidationError(message="Check constraint violation",violations=listOf(TableError.Violation("constraint","$violations rows violate the check condition",constraint.name))).left()} ?:Unit.right()} catch (e:Exception) {logger.error("Failed to validate check constraint:${constraint.id}",e) TableError.DatabaseError(message="Failed to validate constraint:${e.message}",sqlState=null,errorCode=null).left()} private suspend fun validateForeignKeyConstraint(constraint:TableConstraint):Either<TableError,Unit>=try {// Implementation depends on your specific foreign key validation requirements Unit.right()} catch (e:Exception) {logger.error("Failed to validate foreign key constraint:${constraint.id}",e) TableError.DatabaseError(message="Failed to validate constraint:${e.message}",sqlState=null,errorCode=null).left()} private fun getTableName(tableId:UUID):String=jdbcTemplate.queryForObject("SELECT name FROM ad_table WHERE id=?",String::class.java,tableId) ?:throw IllegalStateException("Table not found:$tableId")} 
File: ./infrastructure/persistence/repositories/ProcessRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.blackerp.domain.core.ad.process.* import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID @Repository class ProcessRepository(private val jdbcTemplate:JdbcTemplate) :ProcessOperations {override suspend fun save(process:ADProcess):Either<ProcessError,ADProcess>=try {// TODO:Implement save logic process.right()} catch (e:Exception) {ProcessError.ValidationFailed(e.message ?:"Save failed").left()} override suspend fun findById(id:UUID):Either<ProcessError,ADProcess?>=try {// TODO:Implement find logic null.right()} catch (e:Exception) {ProcessError.ValidationFailed(e.message ?:"Find failed").left()} override suspend fun delete(id:UUID):Either<ProcessError,Unit>=try {// TODO:Implement delete logic Unit.right()} catch (e:Exception) {ProcessError.ValidationFailed(e.message ?:"Delete failed").left()} override suspend fun execute(id:UUID,parameters:Map<String,Any>):Either<ProcessError,ProcessResult>=try {// TODO:Implement process execution ProcessResult(success=true,message="Process executed successfully",data=emptyMap()).right()} catch (e:Exception) {ProcessError.ExecutionFailed(e.message ?:"Execution failed").left()} override suspend fun schedule(id:UUID,schedule:ProcessSchedule):Either<ProcessError,ADProcess>=try {// TODO:Implement process scheduling findById(id).fold({error->error.left()},{process->process?.copy(schedule=schedule)?.right() ?:ProcessError.NotFound(id).left()})} catch (e:Exception) {ProcessError.ValidationFailed(e.message ?:"Scheduling failed").left()}} 
File: ./infrastructure/persistence/repositories/RelationshipRepository.kt
-------------------------------------------
package org.blackerp.infrastructure.persistence.repositories import org.springframework.stereotype.Repository import org.springframework.jdbc.core.JdbcTemplate import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.slf4j.LoggerFactory import org.springframework.dao.DataIntegrityViolationException @Repository class RelationshipRepository(private val jdbcTemplate:JdbcTemplate) :RelationshipOperations {private val logger=LoggerFactory.getLogger(RelationshipRepository::class.java) @Transactional override suspend fun save(relationship:TableRelationship):Either<TableError,TableRelationship>=try {logger.debug("Saving relationship:${relationship.id}") jdbcTemplate.update(""" INSERT INTO table_relationship (id,source_table_id,target_table_id,relationship_type,source_column,target_column,on_delete,on_update) VALUES (?,?,?,?,?,?,?,?) ON CONFLICT (id) DO UPDATE SET relationship_type=EXCLUDED.relationship_type,source_column=EXCLUDED.source_column,target_column=EXCLUDED.target_column,on_delete=EXCLUDED.on_delete,on_update=EXCLUDED.on_update """,relationship.id,relationship.sourceTable,relationship.targetTable,relationship.type.name,relationship.sourceColumn,relationship.targetColumn,relationship.onDelete.name,relationship.onUpdate.name) relationship.right()} catch (e:DataIntegrityViolationException) {logger.error("Constraint violation while saving relationship:${relationship.id}",e) TableError.ValidationError(message="Constraint violation:${e.message}",violations=listOf(TableError.Violation("relationship","Database constraint violation",null))).left()} catch (e:Exception) {logger.error("Failed to save relationship:${relationship.id}",e) TableError.DatabaseError(message="Failed to save relationship:${e.message}",sqlState=null,errorCode=null).left()} override suspend fun findBySourceTable(tableId:UUID):Either<TableError,List<TableRelationship>>=try {val relationships=jdbcTemplate.query(""" SELECT id,source_table_id,target_table_id,relationship_type,source_column,target_column,on_delete,on_update FROM table_relationship WHERE source_table_id=? """,{rs,_->TableRelationship(id=UUID.fromString(rs.getString("id")),sourceTable=UUID.fromString(rs.getString("source_table_id")),targetTable=UUID.fromString(rs.getString("target_table_id")),type=RelationshipType.valueOf(rs.getString("relationship_type")),sourceColumn=rs.getString("source_column"),targetColumn=rs.getString("target_column"),onDelete=CascadeType.valueOf(rs.getString("on_delete")),onUpdate=CascadeType.valueOf(rs.getString("on_update")))},tableId) relationships.right()} catch (e:Exception) {logger.error("Failed to find relationships for table:$tableId",e) TableError.DatabaseError(message="Failed to find relationships:${e.message}",sqlState=null,errorCode=null).left()} override suspend fun findByTargetTable(tableId:UUID):Either<TableError,List<TableRelationship>>=try {val relationships=jdbcTemplate.query(""" SELECT id,source_table_id,target_table_id,relationship_type,source_column,target_column,on_delete,on_update FROM table_relationship WHERE target_table_id=? """,{rs,_->TableRelationship(id=UUID.fromString(rs.getString("id")),sourceTable=UUID.fromString(rs.getString("source_table_id")),targetTable=UUID.fromString(rs.getString("target_table_id")),type=RelationshipType.valueOf(rs.getString("relationship_type")),sourceColumn=rs.getString("source_column"),targetColumn=rs.getString("target_column"),onDelete=CascadeType.valueOf(rs.getString("on_delete")),onUpdate=CascadeType.valueOf(rs.getString("on_update")))},tableId) relationships.right()} catch (e:Exception) {logger.error("Failed to find relationships for target table:$tableId",e) TableError.DatabaseError(message="Failed to find relationships:${e.message}",sqlState=null,errorCode=null).left()} @Transactional override suspend fun delete(id:UUID):Either<TableError,Unit>=try {val deleted=jdbcTemplate.update("DELETE FROM table_relationship WHERE id=?",id) if (deleted> 0) Unit.right() else TableError.ValidationError(message="Relationship not found",violations=listOf(TableError.Violation("id","No relationship found with this ID",id))).left()} catch (e:Exception) {logger.error("Failed to delete relationship:$id",e) TableError.DatabaseError(message="Failed to delete relationship:${e.message}",sqlState=null,errorCode=null).left()}} 
File: ./infrastructure/process/executor/ProcessExecutorImpl.kt
-------------------------------------------
package org.blackerp.infrastructure.process.executor import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.error.ProcessError import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import java.util.UUID import kotlinx.coroutines.withContext import kotlinx.coroutines.Dispatchers @Component class ProcessExecutorImpl :ProcessExecutor {private val logger=LoggerFactory.getLogger(ProcessExecutorImpl::class.java) override suspend fun execute(processId:UUID,parameters:Map<String,Any>,async:Boolean):Either<ProcessError,ProcessResult>=withContext(Dispatchers.IO) {try {logger.info("Executing process:$processId with parameters:$parameters") // Get process definition first // TODO:Inject process repository // Validate parameters validateParameters(parameters).fold({error->return@withContext error.left()},{/* continue execution */}) // Execute based on implementation type val result=executeProcess(processId,parameters) // Track execution trackExecution(processId,parameters,result) result.right()} catch (e:Exception) {logger.error("Process execution failed",e) ProcessError.ExecutionFailed(e.message ?:"Unknown error").left()}} private suspend fun validateParameters(parameters:Map<String,Any>):Either<ProcessError,Unit> {// TODO:Implement parameter validation return Unit.right()} private suspend fun executeProcess(processId:UUID,parameters:Map<String,Any>):ProcessResult {// Mock execution for now return ProcessResult(success=true,message="Process executed successfully",data=mapOf("result" to "Executed process $processId"))} private suspend fun trackExecution(processId:UUID,parameters:Map<String,Any>,result:ProcessResult) {// TODO:Track execution history}} 
File: ./infrastructure/process/validation/ParameterValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.process.validation import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.error.ProcessError import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory @Component class ParameterValidator {private val logger=LoggerFactory.getLogger(ParameterValidator::class.java) fun validate(parameters:Map<String,Any>,expectedParameters:List<ProcessParameter>):Either<ProcessError,Map<String,Any>> {val errors=mutableListOf<String>() // Check required parameters expectedParameters.filter {it.isMandatory} .forEach {param->if (!parameters.containsKey(param.name)) {errors.add("Missing required parameter:${param.name}")}} // Validate parameter types parameters.forEach {(name,value)->expectedParameters.find {it.name == name}?.let {param->if (!isValidType(value,param.parameterType)) {errors.add("Invalid type for parameter $name:expected ${param.parameterType}")}} ?:errors.add("Unexpected parameter:$name")} return if (errors.isEmpty()) {parameters.right()} else {ProcessError.ValidationFailed(errors.joinToString(",")).left()}} private fun isValidType(value:Any,type:ParameterType):Boolean=when(type) {ParameterType.STRING->value is String ParameterType.NUMBER->value is Number ParameterType.DATE->value is java.time.temporal.Temporal ParameterType.BOOLEAN->value is Boolean ParameterType.REFERENCE->true // TODO:Implement reference validation ParameterType.FILE->true // TODO:Implement file validation}} 
File: ./infrastructure/process/tracking/ProcessExecutionTracker.kt
-------------------------------------------
package org.blackerp.infrastructure.process.tracking import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.process.* import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Component class ProcessExecutionTracker {private val logger=LoggerFactory.getLogger(ProcessExecutionTracker::class.java) // In-memory tracking for POC - replace with persistence private val executionHistory=mutableMapOf<UUID,ProcessExecution>() fun trackExecution(processId:UUID,execution:ProcessExecution) {executionHistory[execution.id]=execution logger.info("Tracked execution:${execution.id} for process:$processId")} fun getExecutionHistory(processId:UUID):List<ProcessExecution>=executionHistory.values.filter {it.processId == processId} .sortedByDescending {it.startTime}} 
File: ./infrastructure/build.gradle.kts
-------------------------------------------
sourceSets {main {kotlin {srcDirs("persistence/repositories","cache/providers","integration/adapters","messaging/consumers","plugin/loaders")}}} dependencies {implementation(project(":domain")) implementation(project(":application")) implementation("org.springframework.boot:spring-boot-starter-data-jpa") implementation("com.h2database:h2") implementation("org.flywaydb:flyway-core")} tasks.bootJar {enabled=true} tasks.jar {enabled=true}
File: ./infrastructure/validation/validators/CircularReferenceValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.table.TableRelationship import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID @Component class CircularReferenceValidator {fun validate(relationship:TableRelationship,existingRelationships:List<TableRelationship>):Either<TableError,TableRelationship> {val visited=mutableSetOf<UUID>() val path=mutableListOf<UUID>() fun hasCircularReference(currentTable:UUID):Boolean {if (path.contains(currentTable)) {return true} if (!visited.add(currentTable)) {return false} path.add(currentTable) val relatedTables=existingRelationships .filter {it.sourceTable == currentTable} .map {it.targetTable} relatedTables.forEach {targetTable->if (hasCircularReference(targetTable)) {return true}} path.removeAt(path.size - 1) return false} return if (hasCircularReference(relationship.sourceTable)) {TableError.ValidationError(message="Circular reference detected",violations=listOf(TableError.Violation(field="relationship",message="Creating this relationship would create a circular reference",value="${relationship.sourceTable}->${relationship.targetTable}"))).left()} else {relationship.right()}}} 
File: ./infrastructure/validation/validators/ConstraintValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.table.TableConstraint import org.blackerp.domain.core.ad.table.ConstraintType import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.left import arrow.core.right @Component class ConstraintValidator {fun validate(constraint:TableConstraint):Either<TableError,TableConstraint> {val violations=mutableListOf<TableError.Violation>() when (constraint.type) {ConstraintType.UNIQUE->validateUniqueConstraint(constraint,violations) ConstraintType.CHECK->validateCheckConstraint(constraint,violations) ConstraintType.FOREIGN_KEY->validateForeignKeyConstraint(constraint,violations)} // Common validations if (!isValidConstraintName(constraint.name)) {violations.add(TableError.Violation(field="name",message="Constraint name must start with lowercase letter and contain only letters,numbers,and underscores",value=constraint.name))} return if (violations.isEmpty()) {constraint.right()} else {TableError.ValidationError(message="Constraint validation failed",violations=violations).left()}} private fun validateUniqueConstraint(constraint:TableConstraint,violations:MutableList<TableError.Violation>) {if (constraint.columns.isEmpty()) {violations.add(TableError.Violation(field="columns",message="Unique constraint must specify at least one column",value=constraint.name))} if (constraint.expression != null) {violations.add(TableError.Violation(field="expression",message="Unique constraint cannot have an expression",value=constraint.name))}} private fun validateCheckConstraint(constraint:TableConstraint,violations:MutableList<TableError.Violation>) {if (constraint.expression == null) {violations.add(TableError.Violation(field="expression",message="Check constraint must have an expression",value=constraint.name))} if (constraint.columns.isNotEmpty()) {violations.add(TableError.Violation(field="columns",message="Check constraint cannot specify columns directly",value=constraint.name))}} private fun validateForeignKeyConstraint(constraint:TableConstraint,violations:MutableList<TableError.Violation>) {if (constraint.columns.isEmpty()) {violations.add(TableError.Violation(field="columns",message="Foreign key constraint must specify at least one column",value=constraint.name))} if (constraint.expression != null) {violations.add(TableError.Violation(field="expression",message="Foreign key constraint cannot have an expression",value=constraint.name))}} private fun isValidConstraintName(name:String):Boolean=name.matches(Regex("^[a-z][a-z0-9_]*$"))} 
File: ./infrastructure/validation/validators/TableValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.error.TableError import org.blackerp.domain.core.error.TableError.Violation import org.blackerp.domain.core.values.DataType import arrow.core.Either import arrow.core.left import arrow.core.right @Component class TableValidator {fun validateCreate(table:ADTable):Either<TableError,ADTable> {val violations=mutableListOf<Violation>() // Name validation if (!table.name.value.matches(Regex("^[a-z][a-z0-9_]*$"))) {violations.add(Violation(field="name",message="Table name must start with lowercase letter and contain only lowercase letters,numbers,and underscores",value=table.name.value))} // Column validation table.columns.forEachIndexed {index,column->validateColumn(column,index,violations)} // Duplicate column check val duplicateColumns=table.columns .groupBy {it.name} .filter {it.value.size> 1} .keys duplicateColumns.forEach {name->violations.add(Violation(field="columns",message="Duplicate column name found",value=name))} // Primary key validation if (!table.columns.any {it.isPrimaryKey}) {violations.add(Violation(field="columns",message="Table must have at least one primary key column"))} return if (violations.isEmpty()) {table.right()} else {TableError.ValidationError(message="Table validation failed",violations=violations).left()}} private fun validateColumn(column:ColumnDefinition,index:Int,violations:MutableList<Violation>) {val prefix="columns[$index]" when (column.dataType) {DataType.STRING->{if (column.length == null) {violations.add(Violation(field="$prefix.length",message="String column must specify length",value=column.name))} if (column.precision != null || column.scale != null) {violations.add(Violation(field="$prefix",message="String column cannot have precision or scale",value=column.name))}} DataType.DECIMAL->{if (column.precision == null) {violations.add(Violation(field="$prefix.precision",message="Decimal column must specify precision",value=column.name))} if (column.scale == null) {violations.add(Violation(field="$prefix.scale",message="Decimal column must specify scale",value=column.name))} if (column.length != null) {violations.add(Violation(field="$prefix",message="Decimal column cannot have length",value=column.name))}} else->{if (column.length != null || column.precision != null || column.scale != null) {violations.add(Violation(field="$prefix",message="Column of type ${column.dataType} cannot have length,precision,or scale",value=column.name))}}} // Reference validation for foreign keys column.reference?.let {ref->if (column.dataType != DataType.UUID) {violations.add(Violation(field="$prefix.reference",message="Reference columns must be of type UUID",value=column.name))}}}} 
File: ./infrastructure/validation/validators/CompositeValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.left import arrow.core.right @Component class CompositeValidator<T>(private val validators:List<Validator<T>>) {fun validate(target:T):Either<TableError,T> {val violations=mutableListOf<TableError.Violation>() validators.forEach {validator->validator.validate(target).fold({error->when (error) {is TableError.ValidationError->violations.addAll(error.violations) else->return error.left()}},{/* continue validation */})} return if (violations.isEmpty()) {target.right()} else {TableError.ValidationError(message="Validation failed",violations=violations).left()}}} 
File: ./infrastructure/validation/validators/ColumnValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.ad.table.ColumnDefinition import org.blackerp.domain.core.values.DataType import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.validation.Validator class ColumnValidator :Validator<ColumnDefinition> {override suspend fun validate(entity:ColumnDefinition):Either<ValidationError,ColumnDefinition> {val errors=mutableListOf<ValidationError>() // Validate name format if (!entity.name.value.matches(Regex("^[a-z][a-z0-9_]*$"))) {errors.add(ValidationError.InvalidFormat("Column name must start with lowercase letter and contain only lowercase letters,numbers,and underscores"))} // Validate type-specific constraints when (entity.dataType) {DataType.STRING->{if (entity.length == null) {errors.add(ValidationError.Required("length for string type"))} if (entity.precision != null || entity.scale != null) {errors.add(ValidationError.InvalidValue("string type cannot have precision or scale"))}} DataType.DECIMAL->{if (entity.precision == null) {errors.add(ValidationError.Required("precision for decimal type"))} if (entity.length != null) {errors.add(ValidationError.InvalidValue("decimal type cannot have length"))}} else->{if (entity.length != null || entity.precision != null || entity.scale != null) {errors.add(ValidationError.InvalidValue("type ${entity.dataType} cannot have length,precision,or scale"))}}} return if (errors.isEmpty()) {entity.right()} else {errors.first().left()}}} 
File: ./infrastructure/validation/validators/RelationshipValidator.kt
-------------------------------------------
package org.blackerp.infrastructure.validation.validators import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.table.TableRelationship import org.blackerp.domain.core.error.TableError import arrow.core.Either import arrow.core.left import arrow.core.right @Component class RelationshipValidator {fun validate(relationship:TableRelationship):Either<TableError,TableRelationship> {val violations=mutableListOf<TableError.Violation>() // Validate source and target are different if (relationship.sourceTable == relationship.targetTable) {violations.add(TableError.Violation(field="targetTable",message="Self-referential relationships not supported",value=relationship.targetTable))} // Validate column names if (!isValidColumnName(relationship.sourceColumn)) {violations.add(TableError.Violation(field="sourceColumn",message="Invalid column name format",value=relationship.sourceColumn))} if (!isValidColumnName(relationship.targetColumn)) {violations.add(TableError.Violation(field="targetColumn",message="Invalid column name format",value=relationship.targetColumn))} return if (violations.isEmpty()) {relationship.right()} else {TableError.ValidationError(message="Relationship validation failed",violations=violations).left()}} private fun isValidColumnName(name:String):Boolean=name.matches(Regex("^[a-z][a-z0-9_]*$"))} 
File: ./infrastructure/events/publishers/DomainEventPublisher.kt
-------------------------------------------
package org.blackerp.infrastructure.events.publishers import org.springframework.stereotype.Component import org.springframework.context.ApplicationEventPublisher import org.blackerp.domain.events.DomainEvent import org.slf4j.LoggerFactory import org.slf4j.MDC import java.util.UUID @Component class DomainEventPublisher(private val applicationEventPublisher:ApplicationEventPublisher) {private val logger=LoggerFactory.getLogger(DomainEventPublisher::class.java) fun publish(event:DomainEvent) {val correlationId=MDC.get("correlationId") ?:UUID.randomUUID().toString() MDC.put("correlationId",correlationId) try {logger.debug("Publishing event:{} with correlationId:{}",event.javaClass.simpleName,correlationId) applicationEventPublisher.publishEvent(event) logger.debug("Successfully published event:{} with correlationId:{}",event.javaClass.simpleName,correlationId)} catch (e:Exception) {logger.error("Failed to publish event:{} with correlationId:{}",event.javaClass.simpleName,correlationId,e) throw e} finally {MDC.remove("correlationId")}}} 
File: ./infrastructure/events/handlers/RelationshipEventHandler.kt
-------------------------------------------
package org.blackerp.infrastructure.events.handlers import org.springframework.stereotype.Component import org.springframework.context.event.EventListener import org.blackerp.domain.events.RelationshipEvent import org.slf4j.LoggerFactory @Component class RelationshipEventHandler {private val logger=LoggerFactory.getLogger(RelationshipEventHandler::class.java) @EventListener fun handleRelationshipCreated(event:RelationshipEvent.RelationshipCreated) {logger.info("Relationship created:{}->{} (type:{})",event.sourceTableId,event.targetTableId,event.type)} @EventListener fun handleRelationshipModified(event:RelationshipEvent.RelationshipModified) {logger.info("Relationship modified:{} (type changed:{}->{})",event.relationshipId,event.previousType,event.newType)} @EventListener fun handleRelationshipDeleted(event:RelationshipEvent.RelationshipDeleted) {logger.info("Relationship deleted:{} (source:{},target:{})",event.relationshipId,event.sourceTableId,event.targetTableId)}} 
File: ./infrastructure/events/handlers/ConstraintEventHandler.kt
-------------------------------------------
package org.blackerp.infrastructure.events.handlers import org.springframework.stereotype.Component import org.springframework.context.event.EventListener import org.blackerp.domain.events.ConstraintEvent import org.slf4j.LoggerFactory @Component class ConstraintEventHandler {private val logger=LoggerFactory.getLogger(ConstraintEventHandler::class.java) @EventListener fun handleConstraintCreated(event:ConstraintEvent.ConstraintCreated) {logger.info("Constraint created:{} on table {} (type:{})",event.name,event.tableId,event.type)} @EventListener fun handleConstraintModified(event:ConstraintEvent.ConstraintModified) {logger.info("Constraint modified:{} (name changed:{}->{})",event.constraintId,event.previousName,event.newName)} @EventListener fun handleConstraintDeleted(event:ConstraintEvent.ConstraintDeleted) {logger.info("Constraint deleted:{} from table {}",event.name,event.tableId)} @EventListener fun handleConstraintViolated(event:ConstraintEvent.ConstraintViolated) {logger.warn("Constraint violation:{} on table {} (type:{}):{}",event.constraintId,event.tableId,event.violationType,event.violationDetails)}} 
File: ./infrastructure/events/handlers/WorkflowEventHandler.kt
-------------------------------------------
package org.blackerp.infrastructure.events.handlers import org.springframework.stereotype.Component import org.springframework.context.event.EventListener import org.blackerp.domain.events.WorkflowEvent import org.slf4j.LoggerFactory @Component class WorkflowEventHandler {private val logger=LoggerFactory.getLogger(WorkflowEventHandler::class.java) @EventListener fun handleNodeCreated(event:WorkflowEvent.NodeCreated) {logger.info("Node created:{} (type:{})",event.node.displayName,event.node.type)} @EventListener fun handleNodeUpdated(event:WorkflowEvent.NodeUpdated) {logger.info("Node updated:{} with changes:{}",event.nodeId,event.changes)} @EventListener fun handleNodeDeleted(event:WorkflowEvent.NodeDeleted) {logger.info("Node deleted:{} ({})",event.nodeId,event.nodeName)}} 
File: ./infrastructure/integration/adapters/SystemHealthAdapter.kt
-------------------------------------------
package org.blackerp.infrastructure.integration.adapters import org.springframework.boot.actuate.health.Health import org.springframework.boot.actuate.health.HealthIndicator import org.springframework.stereotype.Component import org.springframework.jdbc.core.JdbcTemplate @Component class SystemHealthAdapter(private val jdbcTemplate:JdbcTemplate) :HealthIndicator {override fun health():Health {return try {val dbStatus=checkDatabase() if (dbStatus) {Health.up() .withDetail("database","UP") .build()} else {Health.down() .withDetail("database","DOWN") .build()}} catch (ex:Exception) {Health.down() .withException(ex) .build()}} private fun checkDatabase():Boolean=try {jdbcTemplate.queryForObject("SELECT 1",Int::class.java) true} catch (e:Exception) {false}} 
File: ./infrastructure/integration/adapters/TableHealthIndicator.kt
-------------------------------------------
package org.blackerp.infrastructure.integration.adapters import org.springframework.boot.actuate.health.Health import org.springframework.boot.actuate.health.HealthIndicator import org.springframework.stereotype.Component import org.springframework.jdbc.core.JdbcTemplate import org.slf4j.LoggerFactory @Component class TableHealthIndicator(private val jdbcTemplate:JdbcTemplate) :HealthIndicator {private val logger=LoggerFactory.getLogger(TableHealthIndicator::class.java) override fun health():Health {return try {val tableCount=jdbcTemplate.queryForObject("SELECT COUNT(*) FROM ad_table",Int::class.java) ?:0 val recentTablesCount=jdbcTemplate.queryForObject(""" SELECT COUNT(*) FROM ad_table WHERE created> now() - interval '24 hours' """,Int::class.java) ?:0 Health.up() .withDetail("totalTables",tableCount) .withDetail("tablesCreatedLast24h",recentTablesCount) .build()} catch (e:Exception) {logger.error("Health check failed",e) Health.down() .withException(e) .build()}}} 
File: ./settings.gradle.kts
-------------------------------------------
rootProject.name="blackerp" include(":domain",":application",":infrastructure")
File: ./domain/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm")} tasks.bootJar {enabled=false} tasks.jar {enabled=true} sourceSets {main {kotlin.srcDirs("core","events","validation")}} dependencies {api("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3") api("io.arrow-kt:arrow-core:1.1.3")} 
File: ./domain/core/ad/docstatus/DocStatusError.kt
-------------------------------------------
// domain/core/ad/docstatus/DocStatusError.kt package org.blackerp.domain.core.ad.docstatus import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class DocStatusError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class NotFound(val id:UUID) :DocStatusError("Document not found:$id","DOC_NOT_FOUND") data class ValidationFailed(val details:String) :DocStatusError("Validation failed:$details","DOC_VALIDATION_FAILED") data class StatusTransitionInvalid(val currentStatus:String,val targetStatus:String) :DocStatusError("Invalid status transition from $currentStatus to $targetStatus","DOC_STATUS_INVALID")} 
File: ./domain/core/ad/docstatus/DocStatus.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docstatus import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import java.util.UUID data class DocStatus(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val code:String,val allowedTransitions:List<String>) :ADObject {override val id:String get()=uuid.toString() companion object {fun create(metadata:EntityMetadata,displayName:DisplayName,description:Description?,code:String,transitions:List<String>):Either<DocStatusError,DocStatus>=DocStatus(metadata=metadata,displayName=displayName,description=description,code=code,allowedTransitions=transitions).right()}} 
File: ./domain/core/ad/docstatus/AD_DocStatus.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docstatus import org.slf4j.LoggerFactory import arrow.core.Either import arrow.core.right import arrow.core.left /** * In-memory document status registry for POC * Handles static document status definitions and transition rules */ object AD_DocStatus {private val logger=LoggerFactory.getLogger(AD_DocStatus::class.java) // Standard document statuses const val DRAFT="DR" const val IN_PROGRESS="IP" const val COMPLETED="CO" const val VOIDED="VO" const val CLOSED="CL" // Status display names private val displayNames=mapOf(DRAFT to "Draft",IN_PROGRESS to "In Progress",COMPLETED to "Completed",VOIDED to "Voided",CLOSED to "Closed") // Allowed transitions per status private val transitions=mapOf(DRAFT to listOf(IN_PROGRESS,VOIDED),IN_PROGRESS to listOf(COMPLETED,VOIDED),COMPLETED to listOf(CLOSED,VOIDED),VOIDED to emptyList<String>(),CLOSED to emptyList<String>()) // Required actions for transitions private val requiredActions=mapOf("$DRAFT->$IN_PROGRESS" to "START","$IN_PROGRESS->$COMPLETED" to "COMPLETE","$COMPLETED->$CLOSED" to "CLOSE","*->$VOIDED" to "VOID") fun getDisplayName(status:String):String=displayNames[status] ?:status fun validateTransition(fromStatus:String,toStatus:String):Either<DocStatusError,Unit> {logger.debug("Validating transition from $fromStatus to $toStatus") if (!transitions.containsKey(fromStatus)) {return DocStatusError.InvalidStatus(fromStatus).left()} if (!transitions.containsKey(toStatus)) {return DocStatusError.InvalidStatus(toStatus).left()} return if (canTransition(fromStatus,toStatus)) {Unit.right()} else {DocStatusError.StatusTransitionInvalid(fromStatus,toStatus).left()}} fun getRequiredAction(fromStatus:String,toStatus:String):String? {val specificKey="$fromStatus->$toStatus" val wildcardKey="*->$toStatus" return requiredActions[specificKey] ?:requiredActions[wildcardKey]} fun getAllowedNextStatuses(currentStatus:String):List<String>=transitions[currentStatus] ?:emptyList() private fun canTransition(fromStatus:String,toStatus:String):Boolean=transitions[fromStatus]?.contains(toStatus) ?:false} 
File: ./domain/core/ad/docaction/DocActionError.kt
-------------------------------------------
// domain/core/ad/docaction/DocActionError.kt package org.blackerp.domain.core.ad.docaction import org.blackerp.domain.core.error.DomainError sealed class DocActionError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class ExecutionFailed(val details:String) :DocActionError("Action execution failed:$details","DOC_EXEC_FAILED") data class ValidationFailed(val details:String) :DocActionError("Action validation failed:$details","DOC_VAL_FAILED") data class NotFound(override val code:String) :DocActionError("Action not found:$code","DOC_ACTION_NOT_FOUND")} 
File: ./domain/core/ad/docaction/DocAction.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docaction import arrow.core.Either import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import java.util.UUID interface DocAction {val metadata:EntityMetadata val id:String val code:String val displayName:DisplayName val description:Description? suspend fun execute(context:DocActionContext):Either<DocActionError,DocActionResult>} data class DocActionContext(val documentId:UUID,val userId:String,val fromStatus:String,val toStatus:String,val parameters:Map<String,Any>=emptyMap()) data class DocActionResult(val success:Boolean,val message:String,val data:Map<String,Any>=emptyMap()) 
File: ./domain/core/ad/docaction/DocActionRegistry.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docaction import org.springframework.stereotype.Component import arrow.core.Either import arrow.core.right import arrow.core.left import org.slf4j.LoggerFactory import java.util.concurrent.ConcurrentHashMap /** * In-memory document action registry for POC * Manages document action definitions and execution */ @Component class DocActionRegistry {private val logger=LoggerFactory.getLogger(DocActionRegistry::class.java) private val actions=ConcurrentHashMap<String,DocAction>() fun register(action:DocAction):Either<DocActionError,DocAction> {logger.debug("Registering action:${action.code}") actions[action.code]=action return action.right()} fun unregister(code:String) {actions.remove(code) logger.debug("Unregistered action:$code")} suspend fun execute(code:String,context:DocActionContext):Either<DocActionError,DocActionResult> {logger.debug("Executing action:$code") return actions[code]?.execute(context) ?:DocActionError.NotFound(code).left()} fun getAction(code:String):Either<DocActionError,DocAction>=actions[code]?.right() ?:DocActionError.NotFound(code).left() // Standard document actions object StandardActions {const val START="START" const val COMPLETE="COMPLETE" const val VOID="VOID" const val CLOSE="CLOSE" fun registerStandardActions(registry:DocActionRegistry) {registry.register(createStartAction()) registry.register(createCompleteAction()) registry.register(createVoidAction()) registry.register(createCloseAction())} private fun createStartAction()=object :DocAction {override val code=START override val displayName="Start" override val description="Start processing the document" override suspend fun execute(context:DocActionContext):Either<DocActionError,DocActionResult>=DocActionResult(true,"Document processing started").right()} private fun createCompleteAction()=object :DocAction {override val code=COMPLETE override val displayName="Complete" override val description="Complete the document" override suspend fun execute(context:DocActionContext):Either<DocActionError,DocActionResult>=DocActionResult(true,"Document completed").right()} private fun createVoidAction()=object :DocAction {override val code=VOID override val displayName="Void" override val description="Void the document" override suspend fun execute(context:DocActionContext):Either<DocActionError,DocActionResult>=DocActionResult(true,"Document voided").right()} private fun createCloseAction()=object :DocAction {override val code=CLOSE override val displayName="Close" override val description="Close the document" override suspend fun execute(context:DocActionContext):Either<DocActionError,DocActionResult>=DocActionResult(true,"Document closed").right()}}} 
File: ./domain/core/ad/docaction/DocActionOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.docaction import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface DocActionOperations {suspend fun register(action:DocAction):Either<DocActionError,DocAction> suspend fun findByCode(code:String):Either<DocActionError,DocAction?> suspend fun execute(code:String,context:DocActionContext):Either<DocActionError,DocActionResult> suspend fun listActions():Flow<DocAction>} 
File: ./domain/core/ad/window/WindowName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.window import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class WindowName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,WindowName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Window name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("window name",3,50).left() else->WindowName(value).right()}}} 
File: ./domain/core/ad/process/ADProcess.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import arrow.core.Either import arrow.core.right import java.util.UUID data class ADProcess(override val metadata:EntityMetadata,override val id:String=UUID.randomUUID().toString(),override val displayName:DisplayName,override val description:Description?,val type:ProcessType,val parameters:List<ProcessParameter>,val implementation:ProcessImplementation,val schedule:ProcessSchedule?) :ADObject {companion object {fun create(params:CreateProcessParams):Either<ProcessError,ADProcess>=ADProcess(metadata=params.metadata,displayName=params.displayName,description=params.description,type=params.type,parameters=params.parameters,implementation=params.implementation,schedule=params.schedule).right()}} data class CreateProcessParams(val metadata:EntityMetadata,val displayName:DisplayName,val description:Description?,val type:ProcessType,val parameters:List<ProcessParameter>,val implementation:ProcessImplementation,val schedule:ProcessSchedule?) sealed interface ProcessImplementation {data class JavaClass(val className:String) :ProcessImplementation data class DatabaseFunction(val functionName:String) :ProcessImplementation data class Script(val language:String,val code:String) :ProcessImplementation} data class ProcessSchedule(val cronExpression:String,val enabled:Boolean=true) 
File: ./domain/core/ad/process/ADParameter.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import org.blackerp.domain.core.values.DataType import java.util.UUID data class ADParameter(val id:UUID,val name:String,val displayName:String,val description:String?,val dataType:DataType,val mandatory:Boolean=false,val defaultValue:String?=null,val validation:ParameterValidation?=null) data class ParameterValidation(val expression:String,val errorMessage:String) 
File: ./domain/core/ad/process/ProcessOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface ProcessOperations {suspend fun save(process:ADProcess):Either<ProcessError,ADProcess> suspend fun findById(id:UUID):Either<ProcessError,ADProcess?> suspend fun search(query:String,pageSize:Int=20,page:Int=0):Flow<ADProcess> suspend fun delete(id:UUID):Either<ProcessError,Unit> suspend fun execute(id:UUID,parameters:Map<String,Any>,async:Boolean=false):Either<ProcessError,ProcessResult> suspend fun schedule(id:UUID,schedule:ProcessSchedule):Either<ProcessError,ADProcess> suspend fun getExecutionHistory(id:UUID,pageSize:Int=20,page:Int=0):Flow<ProcessExecution> suspend fun validateParameters(id:UUID,parameters:Map<String,Any>):Either<ProcessError,Map<String,List<String>>>} data class ProcessExecution(val id:UUID=UUID.randomUUID(),val processId:UUID,val startTime:java.time.Instant,val endTime:java.time.Instant?,val status:ExecutionStatus,val parameters:Map<String,Any>,val result:ProcessResult?,val user:String) enum class ExecutionStatus {QUEUED,RUNNING,COMPLETED,FAILED,CANCELLED} 
File: ./domain/core/ad/process/ProcessTypes.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process enum class ProcessType {REPORT,CALCULATION,SYNCHRONIZATION,WORKFLOW,DATA_IMPORT,DATA_EXPORT,CUSTOM} data class ProcessParameter(val id:java.util.UUID=java.util.UUID.randomUUID(),val name:String,val displayName:String,val description:String?,val parameterType:ParameterType,val isMandatory:Boolean=false,val validationRule:String?) enum class ParameterType {STRING,NUMBER,DATE,BOOLEAN,REFERENCE,FILE} data class ProcessResult(val success:Boolean,val message:String,val data:Map<String,Any>?=null,val logs:List<String>=emptyList()) 
File: ./domain/core/ad/process/ProcessRepository.kt
-------------------------------------------
// domain/core/process/ProcessRepository.kt package org.blackerp.domain.core.ad.process import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.ProcessError import java.util.UUID interface ProcessRepository {suspend fun save(process:ADProcess):Either<ProcessError,ADProcess> suspend fun findById(id:UUID):Either<ProcessError,ADProcess?> suspend fun delete(id:UUID):Either<ProcessError,Unit> suspend fun search(query:String,pageSize:Int=20,page:Int=0):Flow<ADProcess> suspend fun getExecutionHistory(id:UUID,pageSize:Int=20,page:Int=0):Flow<ProcessExecution>} interface ProcessExecutor {suspend fun execute(processId:UUID,parameters:Map<String,Any>,async:Boolean=false):Either<ProcessError,ProcessResult>} 
File: ./domain/core/ad/process/ProcessError.kt
-------------------------------------------
package org.blackerp.domain.core.ad.process import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class ProcessError(message:String) :DomainError(message) {data class ValidationFailed(val details:String) :ProcessError("Process validation failed:$details") data class ExecutionFailed(val details:String) :ProcessError("Process execution failed:$details") data class NotFound(val id:UUID) :ProcessError("Process not found:$id") data class UnexpectedError(override val message:String) :ProcessError(message)} 
File: ./domain/core/ad/document/DocumentError.kt
-------------------------------------------
// domain/core/ad/document/DocumentError.kt package org.blackerp.domain.core.ad.document import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class DocumentError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class NotFound(val id:UUID) :DocumentError("Document not found:$id","DOC_NOT_FOUND") data class ValidationFailed(val details:String) :DocumentError("Validation failed:$details","DOC_VALIDATION_FAILED") data class StatusTransitionInvalid(val currentStatus:DocumentStatus,val targetStatus:DocumentStatus) :DocumentError("Invalid status transition from $currentStatus to $targetStatus","DOC_STATUS_INVALID")} 
File: ./domain/core/ad/document/Document.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.ad.base.ADObject import java.time.Instant import java.util.UUID data class Document(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val type:DocumentType,val status:DocumentStatus=DocumentStatus.DRAFT,val created:Instant=Instant.now(),val lastModified:Instant=Instant.now()) :ADObject {override val id:String get()=uuid.toString()} 
File: ./domain/core/ad/document/DocumentService.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.shared.ChangePair import java.util.UUID import java.time.Instant interface DocumentService {suspend fun createDocument(command:CreateDocumentCommand):Either<DocumentError,Document> suspend fun updateDocument(id:UUID,command:UpdateDocumentCommand):Either<DocumentError,Document> suspend fun changeStatus(id:UUID,command:ChangeStatusCommand):Either<DocumentError,Document> suspend fun findDocuments(criteria:DocumentSearchCriteria):Flow<Document> suspend fun getDocumentHistory(id:UUID):Flow<DocumentChange>} data class DocumentChange(val id:UUID,val documentId:UUID,val changedAt:Instant,val changedBy:String,val changes:Map<String,ChangePair<*>>) 
File: ./domain/core/ad/document/DocumentOperations.kt
-------------------------------------------
// domain/core/ad/document/DocumentOperations.kt package org.blackerp.domain.core.ad.document import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.shared.ChangePair import java.util.UUID import java.time.Instant interface DocumentOperations {suspend fun create(document:Document):Either<DocumentError,Document> suspend fun update(id:UUID,document:Document):Either<DocumentError,Document> suspend fun findById(id:UUID):Either<DocumentError,Document?> suspend fun search(criteria:SearchCriteria):Flow<Document> suspend fun delete(id:UUID):Either<DocumentError,Unit> suspend fun changeStatus(id:UUID,status:DocumentStatus):Either<DocumentError,Document>} data class SearchCriteria(val types:List<UUID>?=null,val statuses:List<DocumentStatus>?=null,val dateRange:DateRange?=null,val attributes:Map<String,Any>?=null,val pageSize:Int=20,val page:Int=0) data class DateRange(val from:Instant,val to:Instant) 
File: ./domain/core/ad/document/DocumentStatus.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document enum class DocumentStatus {DRAFT,IN_PROGRESS,COMPLETED,VOIDED} 
File: ./domain/core/ad/document/DocumentProcessHandler.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import org.blackerp.domain.core.ad.process.* import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import java.util.UUID interface DocumentProcessHandler {suspend fun executeDocumentProcess(document:Document,processId:UUID,parameters:Map<String,Any>):Either<DocumentError,ProcessResult>} class DocumentProcessHandlerImpl(private val processOperations:ProcessOperations) :DocumentProcessHandler {private val logger=LoggerFactory.getLogger(DocumentProcessHandlerImpl::class.java) override suspend fun executeDocumentProcess(document:Document,processId:UUID,parameters:Map<String,Any>):Either<DocumentError,ProcessResult> {logger.debug("Executing process $processId for document ${document.id}") val documentParameters=createDocumentParameters(document) val mergedParameters=parameters + documentParameters return processOperations.execute(processId,mergedParameters) .mapLeft {error->DocumentError.ValidationFailed("Process execution failed:${error.message}")}} private fun createDocumentParameters(document:Document):Map<String,Any>=mapOf("DocumentId" to document.id,"DocumentType" to document.type.id,"DocumentStatus" to document.status.name)} 
File: ./domain/core/ad/document/DocumentType.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import java.util.UUID data class DocumentType(val id:UUID,val name:String,val baseTableId:UUID,val linesTableId:UUID?,val workflow:UUID?) data class DocumentLine(val id:UUID,val documentId:UUID,val lineNo:Int,val attributes:Map<String,Any>) 
File: ./domain/core/ad/document/DocumentEvents.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import org.blackerp.domain.events.DomainEvent import org.blackerp.domain.events.EventMetadata import java.util.UUID sealed class DocumentEvent :DomainEvent {data class ProcessExecuted(override val metadata:EventMetadata,val documentId:UUID,val processId:UUID,val success:Boolean,val message:String) :DocumentEvent() // ... existing event classes ...} 
File: ./domain/core/ad/document/DocumentCommands.kt
-------------------------------------------
package org.blackerp.domain.core.ad.document import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import java.time.Instant data class CreateDocumentCommand(val type:DocumentType,val displayName:DisplayName,val description:Description?=null,val attributes:Map<String,Any>=emptyMap()) data class UpdateDocumentCommand(val displayName:DisplayName?=null,val description:Description?=null,val attributes:Map<String,Any>?=null) data class ChangeStatusCommand(val targetStatus:DocumentStatus,val reason:String?=null,val attributes:Map<String,Any>=emptyMap()) data class DocumentSearchCriteria(val types:Set<DocumentType>?=null,val statuses:Set<DocumentStatus>?=null,val fromDate:Instant?=null,val toDate:Instant?=null,val pageSize:Int=20,val page:Int=0) 
File: ./domain/core/ad/shared/values/ProcessName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.shared.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class ProcessName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ProcessName>=when {value.isBlank()->ValidationError.InvalidFormat("Process name cannot be blank").left() value.length> 50->ValidationError.InvalidLength("Process name",1,50).left() else->ProcessName(value).right()}}} 
File: ./domain/core/ad/base/ADModule.kt
-------------------------------------------
package org.blackerp.domain.core.ad.base import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.Version import java.util.UUID data class ADModule(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),val name:ModuleName,override val displayName:DisplayName,override val description:Description?,val version:Version) :ADObject {override val id:String get()=uuid.toString()} 
File: ./domain/core/ad/base/ModuleName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.base import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class ModuleName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ModuleName>=when {!value.matches(Regex("^[a-z][a-z0-9-]*$"))->ValidationError.InvalidFormat("Module name must start with lowercase letter and contain only lowercase letters,numbers,and hyphens").left() value.length !in 3..50->ValidationError.InvalidLength("module name",3,50).left() else->ModuleName(value).right()}}} 
File: ./domain/core/ad/base/ADObject.kt
-------------------------------------------
package org.blackerp.domain.core.ad.base import org.blackerp.domain.core.DomainEntity import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description interface ADObject :DomainEntity {override val id:String val metadata:EntityMetadata val displayName:DisplayName val description:Description?} 
File: ./domain/core/ad/base/ModuleService.kt
-------------------------------------------
package org.blackerp.domain.core.ad.base import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.Version import java.util.UUID interface ModuleService {suspend fun createModule(command:CreateModuleCommand):Either<DomainError,ADModule> suspend fun updateModule(id:UUID,command:UpdateModuleCommand):Either<DomainError,ADModule> suspend fun getModules(active:Boolean?=null):Flow<ADModule>} data class CreateModuleCommand(val name:ModuleName,val displayName:DisplayName,val description:Description?=null,val version:Version,val dependencies:Set<ModuleDependency>=emptySet()) data class UpdateModuleCommand(val displayName:DisplayName?=null,val description:Description?=null,val version:Version?=null) data class ModuleDependency(val moduleName:ModuleName,val version:Version) 
File: ./domain/core/ad/tab/TabOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import arrow.core.Either import org.blackerp.domain.core.values.TableName import java.util.UUID interface TabOperations {suspend fun save(tab:ADTab):Either<TabError,ADTab> suspend fun findById(id:UUID):Either<TabError,ADTab?> suspend fun findByTable(tableName:TableName):Either<TabError,List<ADTab>> suspend fun delete(id:UUID):Either<TabError,Unit>}
File: ./domain/core/ad/tab/OrderBySpec.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import org.blackerp.domain.core.values.ColumnName data class OrderBySpec(val column:ColumnName,val direction:SortDirection) enum class SortDirection {ASC,DESC;companion object {fun fromString(value:String):SortDirection=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid sort direction:$value")}} 
File: ./domain/core/ad/tab/value/TabName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class TabName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TabName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Tab name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("tab name",3,50).left() else->TabName(value).right()}}} 
File: ./domain/core/ad/tab/TabError.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import org.blackerp.domain.core.DomainException import org.blackerp.domain.core.shared.ValidationError sealed class TabError(message:String) :DomainException(message) {data class ValidationFailed(val errors:List<ValidationError>) :TabError("Validation failed:${errors.joinToString {it.message?.toString() ?:"Unknown error"}}") data class NotFound(val id:String) :TabError("Tab not found:$id") data class DuplicateTab(val name:String) :TabError("Tab already exists:$name")} 
File: ./domain/core/ad/tab/ADTab.kt
-------------------------------------------
package org.blackerp.domain.core.ad.tab import arrow.core.Either import arrow.core.right import arrow.core.left import org.blackerp.domain.core.DomainEntity import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.values.ColumnName import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.ad.table.ColumnDefinition import java.util.UUID data class CreateTabParams(val metadata:EntityMetadata,val displayName:DisplayName,val description:Description?,val table:ADTable,val queryColumns:List<ColumnName>,val displayColumns:List<ColumnName>,val orderBy:List<OrderBySpec>) data class ADTab(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val table:ADTable,val queryColumns:List<ColumnName>,val displayColumns:List<ColumnName>,val orderBy:List<OrderBySpec>) :ADObject {override val id:String get()=uuid.toString() companion object {fun create(params:CreateTabParams):Either<TabError,ADTab> {val errors=mutableListOf<ValidationError>() // Validate query columns exist in table val invalidQueryColumns=params.queryColumns.filter {queryColumn:ColumnName->params.table.columns.none {column:ColumnDefinition->column.name == queryColumn.value}} if (invalidQueryColumns.isNotEmpty()) {errors.add(ValidationError.InvalidValue("Query columns not found in table:${invalidQueryColumns.joinToString {column->column.value}}"))} // Validate display columns exist in table val invalidDisplayColumns=params.displayColumns.filter {displayColumn:ColumnName->params.table.columns.none {column:ColumnDefinition->column.name == displayColumn.value}} if (invalidDisplayColumns.isNotEmpty()) {errors.add(ValidationError.InvalidValue("Display columns not found in table:${invalidDisplayColumns.joinToString {column->column.value}}"))} // Validate order by columns exist in table val invalidOrderColumns=params.orderBy.filter {orderSpec:OrderBySpec->params.table.columns.none {column:ColumnDefinition->column.name == orderSpec.column.value}} if (invalidOrderColumns.isNotEmpty()) {errors.add(ValidationError.InvalidValue("Order by columns not found in table:${invalidOrderColumns.joinToString {spec->spec.column.value}}"))} return if (errors.isEmpty()) {ADTab(metadata=params.metadata,displayName=params.displayName,description=params.description,table=params.table,queryColumns=params.queryColumns,displayColumns=params.displayColumns,orderBy=params.orderBy).right()} else {TabError.ValidationFailed(errors).left()}}}} 
File: ./domain/core/ad/table/TableOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.TableError import java.util.UUID interface TableOperations {suspend fun findAll():Either<TableError,List<ADTable>> suspend fun findById(id:UUID):Either<TableError,ADTable?> suspend fun save(table:ADTable):Either<TableError,ADTable> suspend fun delete(id:UUID):Either<TableError,Unit>} interface TableValidator {suspend fun validateCreate(command:org.blackerp.domain.core.ad.table.CreateTableCommand):Either<TableError,org.blackerp.domain.core.ad.table.CreateTableCommand> suspend fun validateUpdate(id:UUID,command:org.blackerp.domain.core.ad.table.UpdateTableCommand):Either<TableError,org.blackerp.domain.core.ad.table.UpdateTableCommand>}
File: ./domain/core/ad/table/ADTable.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.error.TableError import java.util.UUID data class ADTable(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val name:TableName,val accessLevel:AccessLevel,val columns:List<ColumnDefinition>=emptyList(),val constraints:List<TableConstraint>=emptyList()) :ADObject {override val id:String get()=uuid.toString()} 
File: ./domain/core/ad/table/TableConstraint.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.blackerp.domain.core.error.TableError data class TableConstraint(val id:UUID,val tableId:UUID,val name:String,val type:ConstraintType,val columns:List<String>,val expression:String?) {companion object {fun create(params:CreateConstraintParams):Either<TableError,TableConstraint> {if (params.columns.isEmpty() && params.expression == null) {return TableError.ValidationError(message="Constraint must specify either columns or expression",violations=listOf(TableError.Violation("constraint","No columns or expression specified",params.name))).left()} return TableConstraint(id=UUID.randomUUID(),tableId=params.tableId,name=params.name,type=params.type,columns=params.columns,expression=params.expression).right()}}} enum class ConstraintType {UNIQUE,CHECK,FOREIGN_KEY} data class CreateConstraintParams(val tableId:UUID,val name:String,val type:ConstraintType,val columns:List<String>=emptyList(),val expression:String?=null) 
File: ./domain/core/ad/table/TableRelationship.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import org.blackerp.domain.core.error.TableError data class TableRelationship(val id:UUID,val sourceTable:UUID,val targetTable:UUID,val type:RelationshipType,val sourceColumn:String,val targetColumn:String,val onDelete:CascadeType,val onUpdate:CascadeType) {companion object {fun create(params:CreateRelationshipParams):Either<TableError,TableRelationship> {if (params.sourceTable == params.targetTable) {return TableError.ValidationError(message="Self-referential relationships not supported",violations=listOf(TableError.Violation("targetTable","Cannot reference same table",params.targetTable))).left()} return TableRelationship(id=UUID.randomUUID(),sourceTable=params.sourceTable,targetTable=params.targetTable,type=params.type,sourceColumn=params.sourceColumn,targetColumn=params.targetColumn,onDelete=params.onDelete,onUpdate=params.onUpdate).right()}}} enum class RelationshipType {ONE_TO_ONE,ONE_TO_MANY,MANY_TO_ONE} enum class CascadeType {NO_ACTION,CASCADE,SET_NULL,RESTRICT} data class CreateRelationshipParams(val sourceTable:UUID,val targetTable:UUID,val type:RelationshipType,val sourceColumn:String,val targetColumn:String,val onDelete:CascadeType=CascadeType.NO_ACTION,val onUpdate:CascadeType=CascadeType.NO_ACTION) 
File: ./domain/core/ad/table/commands.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import org.blackerp.domain.core.values.* data class CreateTableCommand(val name:TableName,val displayName:DisplayName,val description:Description?=null,val accessLevel:AccessLevel,val columns:List<CreateColumnCommand>) data class UpdateTableCommand(val displayName:DisplayName?=null,val description:Description?=null,val columns:List<UpdateColumnCommand>?=null) data class CreateColumnCommand(val name:String,val displayName:String,val description:String?,val dataType:String,val mandatory:Boolean=false,val length:Int?=null,val precision:Int?=null,val scale:Int?=null) data class UpdateColumnCommand(val name:String?,val displayName:String?,val description:String?,val mandatory:Boolean?)
File: ./domain/core/ad/table/ColumnDefinition.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table data class ColumnDefinition(val name:String,val dataType:String,val length:Int?=null) 
File: ./domain/core/ad/table/ConstraintOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import org.blackerp.domain.core.error.TableError import java.util.UUID interface ConstraintOperations {suspend fun save(constraint:TableConstraint):Either<TableError,TableConstraint> suspend fun findByTable(tableId:UUID):Either<TableError,List<TableConstraint>> suspend fun delete(id:UUID):Either<TableError,Unit> suspend fun validateConstraint(constraint:TableConstraint):Either<TableError,Unit>} 
File: ./domain/core/ad/table/RelationshipOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.table import arrow.core.Either import org.blackerp.domain.core.error.TableError import java.util.UUID interface RelationshipOperations {suspend fun save(relationship:TableRelationship):Either<TableError,TableRelationship> suspend fun findBySourceTable(tableId:UUID):Either<TableError,List<TableRelationship>> suspend fun findByTargetTable(tableId:UUID):Either<TableError,List<TableRelationship>> suspend fun delete(id:UUID):Either<TableError,Unit>} 
File: ./domain/core/ad/workflow/WorkflowNode.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.metadata.EntityMetadata import arrow.core.Either import arrow.core.right import java.util.UUID data class WorkflowNode(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val type:NodeType,val action:NodeAction?,val transitions:List<WorkflowTransition>) :ADObject {override val id:String get()=uuid.toString()} data class CreateNodeParams(val metadata:EntityMetadata,val displayName:DisplayName,val description:Description?,val type:NodeType,val action:NodeAction?,val transitions:List<WorkflowTransition>) 
File: ./domain/core/ad/workflow/NodeType.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow enum class NodeType {START,ACTIVITY,DECISION,END} 
File: ./domain/core/ad/workflow/WorkflowError.kt
-------------------------------------------
// domain/core/ad/workflow/WorkflowError.kt package org.blackerp.domain.core.ad.workflow import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class WorkflowError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class NotFound(val id:UUID) :WorkflowError("Workflow node not found:$id","WF_NOT_FOUND") data class ValidationFailed(val details:String) :WorkflowError("Workflow validation failed:$details","WF_VALIDATION_FAILED") data class CyclicDependency(val nodeIds:List<UUID>) :WorkflowError("Cyclic dependency detected in workflow:${nodeIds.joinToString()}","WF_CYCLIC_DEPENDENCY")} 
File: ./domain/core/ad/workflow/WorkflowOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import arrow.core.Either import java.util.UUID interface WorkflowOperations {suspend fun save(node:WorkflowNode):Either<WorkflowError,WorkflowNode> suspend fun findById(id:UUID):Either<WorkflowError,WorkflowNode?> suspend fun delete(id:UUID):Either<WorkflowError,Unit> suspend fun validateWorkflow(nodes:List<WorkflowNode>):Either<WorkflowError,Unit>} 
File: ./domain/core/ad/workflow/WorkflowService.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.ad.document.Document import java.util.UUID interface WorkflowService {suspend fun createWorkflow(command:CreateWorkflowCommand):Either<WorkflowError,WorkflowNode> suspend fun updateWorkflow(id:UUID,command:UpdateWorkflowCommand):Either<WorkflowError,WorkflowNode> suspend fun validateWorkflow(id:UUID):Either<WorkflowError,ValidationResult> suspend fun executeWorkflow(id:UUID,context:WorkflowContext):Either<WorkflowError,WorkflowResult>} data class CreateWorkflowCommand(val displayName:DisplayName,val description:Description?=null,val nodes:List<CreateNodeCommand>,val transitions:List<CreateTransitionCommand>) data class UpdateWorkflowCommand(val displayName:DisplayName?=null,val description:Description?=null,val nodes:List<UpdateNodeCommand>?=null,val transitions:List<UpdateTransitionCommand>?=null) data class ValidationResult(val valid:Boolean,val errors:List<ValidationError>=emptyList()) data class WorkflowContext(val document:Document,val attributes:Map<String,Any>=emptyMap(),val user:String) data class WorkflowResult(val completed:Boolean,val currentNode:UUID,val nextNodes:List<UUID>,val attributes:Map<String,Any>) 
File: ./domain/core/ad/workflow/commands.kt
-------------------------------------------
// domain/core/ad/workflow/commands.kt package org.blackerp.domain.core.ad.workflow import java.util.UUID data class CreateNodeCommand(val type:NodeType,val displayName:String,val description:String?,val action:NodeAction?) data class UpdateNodeCommand(val displayName:String?,val description:String?,val action:NodeAction?) data class CreateTransitionCommand(val fromNode:UUID,val toNode:UUID,val condition:String?) data class UpdateTransitionCommand(val condition:String?) 
File: ./domain/core/ad/workflow/WorkflowTransition.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import java.util.UUID data class WorkflowTransition(val id:UUID,val sourceNode:UUID,val targetNode:UUID,val condition:TransitionCondition?) data class TransitionCondition(val expression:String,val description:String) 
File: ./domain/core/ad/workflow/NodeAction.kt
-------------------------------------------
package org.blackerp.domain.core.ad.workflow import java.util.UUID sealed interface NodeAction {data class Process(val processId:UUID) :NodeAction data class UserTask(val roleId:UUID) :NodeAction data class Notification(val template:String) :NodeAction} 
File: ./domain/core/ad/reference/ReferenceTypes.kt
-------------------------------------------
package org.blackerp.domain.core.ad.reference sealed interface ReferenceType {object List :ReferenceType data class Table(val tableName:String,val keyColumn:String,val displayColumn:String,val whereClause:String?=null,val orderBy:String?=null) :ReferenceType object Search :ReferenceType data class Custom(val validatorClass:String,val config:Map<String,String>=emptyMap()) :ReferenceType} sealed class ReferenceError(message:String) {data class ValidationFailed(val message:String) :ReferenceError(message) data class NotFound(val id:String) :ReferenceError("Reference not found:$id") data class DuplicateReference(val name:String) :ReferenceError("Reference already exists:$name")} data class ReferenceValue<T>(val key:T,val display:String,val additionalData:Map<String,Any>=emptyMap()) 
File: ./domain/core/ad/reference/ReferenceOperations.kt
-------------------------------------------
package org.blackerp.domain.core.ad.reference import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface ReferenceOperations {suspend fun save(reference:ADReference):Either<ReferenceError,ADReference> suspend fun findById(id:UUID):Either<ReferenceError,ADReference?> suspend fun findByName(name:String):Either<ReferenceError,ADReference?> suspend fun search(query:String,pageSize:Int=20,page:Int=0):Flow<ADReference> suspend fun getValues(referenceId:UUID,searchText:String?=null,pageSize:Int=20,page:Int=0):Either<ReferenceError,List<ReferenceValue<*>>> suspend fun validateValue(referenceId:UUID,value:Any):Either<ReferenceError,Boolean> suspend fun getHierarchy(rootId:UUID?=null):Either<ReferenceError,List<ADReference>> suspend fun delete(id:UUID):Either<ReferenceError,Unit>} interface ReferenceRepository {suspend fun save(reference:ADReference):Either<ReferenceError,ADReference> suspend fun findById(id:UUID):Either<ReferenceError,ADReference?> suspend fun findByName(name:String):Either<ReferenceError,ADReference?> suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADReference> suspend fun delete(id:UUID):Either<ReferenceError,Unit>} interface ReferenceCache {suspend fun get(key:String):Any? suspend fun put(key:String,value:Any,ttlSeconds:Long?=null) suspend fun remove(key:String) suspend fun clear()} 
File: ./domain/core/ad/reference/value/ReferenceName.kt
-------------------------------------------
package org.blackerp.domain.core.ad.reference.value import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class ReferenceName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ReferenceName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Reference name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..50->ValidationError.InvalidLength("reference name",3,50).left() else->ReferenceName(value).right()}}} 
File: ./domain/core/ad/reference/ADReference.kt
-------------------------------------------
package org.blackerp.domain.core.ad.reference import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.ad.base.ADObject import org.blackerp.domain.core.values.DisplayName import org.blackerp.domain.core.values.Description import org.blackerp.domain.core.shared.ValidationError import arrow.core.Either import arrow.core.right import java.util.UUID data class ADReference(override val metadata:EntityMetadata,private val uuid:UUID=UUID.randomUUID(),override val displayName:DisplayName,override val description:Description?,val type:ReferenceType,val validationRule:ValidationRule?,val isActive:Boolean=true,val parentId:UUID?=null,val sortOrder:Int=0) :ADObject {override val id:String get()=uuid.toString()} data class CreateReferenceParams(val metadata:EntityMetadata,val displayName:DisplayName,val description:Description?,val type:ReferenceType,val validationRule:ValidationRule?=null,val parentId:UUID?=null,val sortOrder:Int=0) data class ValidationRule(val expression:String,val errorMessage:String,val parameters:Map<String,String>=emptyMap()) 
File: ./domain/core/DomainException.kt
-------------------------------------------
package org.blackerp.domain.core abstract class DomainException(message:String) :Exception(message) 
File: ./domain/core/error/PluginError.kt
-------------------------------------------
// domain-entities/src/main/kotlin/org/blackerp/plugin/PluginError.kt package org.blackerp.domain.core.error import org.blackerp.domain.core.shared.ValidationError sealed interface PluginError {data class NotFound(val id:String) :PluginError data class ValidationFailed(val errors:List<ValidationError>) :PluginError data class DuplicatePlugin(val id:String) :PluginError data class IncompatibleVersion(val required:String,val actual:String) :PluginError data class InitializationFailed(val id:String,val cause:Throwable) :PluginError data class DiscoveryFailed(val message:String,val cause:Throwable?=null) :PluginError data class LoadFailed(val message:String) :PluginError}
File: ./domain/core/error/TableErrors.kt
-------------------------------------------
package org.blackerp.domain.core.error sealed class TableError :DomainError("Table operation failed") {data class ValidationError(override val message:String,val violations:List<Violation>) :TableError() data class ConstraintViolation(override val message:String,val constraintName:String,val details:String) :TableError() data class DatabaseError(override val message:String,val sqlState:String?,val errorCode:Int?) :TableError() data class InvalidMetadata(override val message:String,val field:String) :TableError() data class Violation(val field:String,val message:String,val value:Any?=null)} 
File: ./domain/core/error/DomainError.kt
-------------------------------------------
// domain/core/error/DomainError.kt package org.blackerp.domain.core.error abstract class DomainError(open val message:String,open val code:String?=null,open val cause:Throwable?=null) 
File: ./domain/core/error/WorkflowErrors.kt
-------------------------------------------
package org.blackerp.domain.core.error import org.blackerp.domain.core.DomainException sealed class WorkflowError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class ValidationError(override val message:String,val field:String?=null) :WorkflowError(message) data class NotFoundError(override val message:String,val id:String) :WorkflowError(message) data class ProcessingError(override val message:String,override val cause:Throwable?=null) :WorkflowError(message) data class ConcurrencyError(override val message:String,val entityId:String,val expectedVersion:Int,val actualVersion:Int) :WorkflowError(message)} 
File: ./domain/core/error/UnexpectedError.kt
-------------------------------------------
package org.blackerp.domain.core.error class UnexpectedError(message:String) :DomainError(message) 
File: ./domain/core/error/ProcessError.kt
-------------------------------------------
package org.blackerp.domain.core.error sealed class ProcessError(message:String) :DomainError(message) {data class ValidationFailed(val details:String) :ProcessError("Process validation failed:$details") data class ExecutionFailed(val details:String) :ProcessError("Process execution failed:$details") data class NotFound(val id:String) :ProcessError("Process not found:$id")} 
File: ./domain/core/tenant/TenantAware.kt
-------------------------------------------
// domain-entities/src/main/kotlin/org/blackerp/domain/tenant/TenantAware.kt package org.blackerp.domain.core.tenant import java.util.UUID interface TenantAware {val tenantId:UUID}
File: ./domain/core/values/DataType.kt
-------------------------------------------
package org.blackerp.domain.core.values enum class DataType {STRING,INTEGER,DECIMAL,BOOLEAN,DATE,TIMESTAMP,BINARY;companion object {fun fromString(value:String):DataType=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid data type:$value")}} 
File: ./domain/core/values/Precision.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class Precision private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Precision>=when {value <0->ValidationError.InvalidValue("Precision cannot be negative").left() value> 20->ValidationError.InvalidValue("Precision cannot exceed 20").left() else->Precision(value).right()}}} 
File: ./domain/core/values/AccessLevel.kt
-------------------------------------------
package org.blackerp.domain.core.values enum class AccessLevel {SYSTEM,CLIENT,ORGANIZATION,CLIENT_ORGANIZATION;companion object {fun fromString(value:String):AccessLevel=values().find {it.name.equals(value,ignoreCase=true)} ?:throw IllegalArgumentException("Invalid access level:$value")}} 
File: ./domain/core/values/Description.kt
-------------------------------------------
// domain/core/values/Description.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class Description private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,Description>=when {value.length> 255->ValidationError.InvalidLength("description",0,255).left() else->Description(value).right()}}} 
File: ./domain/core/values/Amount.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError import java.math.BigDecimal @JvmInline value class Amount private constructor(val value:BigDecimal) {companion object {fun create(value:BigDecimal):Either<ValidationError,Amount>=when {value <BigDecimal.ZERO->ValidationError.InvalidValue("Amount cannot be negative").left() else->Amount(value).right()}}} 
File: ./domain/core/values/ColumnName.kt
-------------------------------------------
// domain/core/values/ColumnName.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class ColumnName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,ColumnName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Column name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length> 30->ValidationError.InvalidLength("column name",1,30).left() else->ColumnName(value).right()}}} 
File: ./domain/core/values/Scale.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.shared.ValidationError.InvalidValue @JvmInline value class Scale private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Scale>=when {value <0->ValidationError.InvalidValue("Scale cannot be negative").left() value> 10->ValidationError.InvalidValue("Scale cannot exceed 10").left() else->Scale(value).right()}}} 
File: ./domain/core/values/Length.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class Length private constructor(val value:Int) {companion object {fun create(value:Int):Either<ValidationError,Length>=when {value <= 0->ValidationError.InvalidValue("Length must be positive").left() else->Length(value).right()}}} 
File: ./domain/core/values/TableName.kt
-------------------------------------------
// domain/core/values/TableName.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class TableName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TableName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Table name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() value.length !in 3..60->ValidationError.InvalidLength("table name",3,60).left() else->TableName(value).right()}}} 
File: ./domain/core/values/Currency.kt
-------------------------------------------
package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class Currency private constructor(val code:String) {companion object {fun create(code:String):Either<ValidationError,Currency>=when {!code.matches(Regex("^[A-Z]{3}$"))->ValidationError.InvalidFormat("Currency code must be 3 uppercase letters").left() else->Currency(code).right()}}} 
File: ./domain/core/values/DisplayName.kt
-------------------------------------------
// domain/core/values/DisplayName.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.shared.ValidationError @JvmInline value class DisplayName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,DisplayName>=when {value.isBlank()->ValidationError.Required("display name").left() value.length !in 1..60->ValidationError.InvalidLength("display name",1,60).left() else->DisplayName(value).right()}}} 
File: ./domain/core/DomainEntity.kt
-------------------------------------------
// domain/core/DomainEntity.kt package org.blackerp.domain.core interface DomainEntity {val id:String} 
File: ./domain/core/shared/ValidationError.kt
-------------------------------------------
package org.blackerp.domain.core.shared sealed class ValidationError(val message:String) {data class InvalidFormat(val details:String) :ValidationError(details) data class InvalidLength(val field:String,val min:Int,val max:Int) :ValidationError("Field '$field' must be between $min and $max characters") data class Required(val field:String) :ValidationError("Field '$field' is required") data class InvalidValue(val details:String) :ValidationError(details)} 
File: ./domain/core/shared/ChangePair.kt
-------------------------------------------
package org.blackerp.domain.core.shared data class ChangePair<T>(val oldValue:T,val newValue:T) {val hasChanged:Boolean=oldValue != newValue} 
File: ./domain/core/metadata/ChangeTracking.kt
-------------------------------------------
// domain/core/metadata/ChangeTracking.kt package org.blackerp.domain.core.metadata import java.time.Instant interface ChangeTrackable {val metadata:EntityMetadata fun withUpdatedBy(user:String):ChangeTrackable} fun EntityMetadata.update(user:String):EntityMetadata {return copy(audit=audit.copy(updatedAt=Instant.now(),updatedBy=user),version=version.copy(version=version.version + 1))} 
File: ./domain/core/metadata/EntityMetadata.kt
-------------------------------------------
// domain/core/metadata/EntityMetadata.kt package org.blackerp.domain.core.metadata import java.time.Instant import java.util.UUID import org.blackerp.domain.core.DomainEntity data class AuditInfo(val createdAt:Instant=Instant.now(),val createdBy:String,val updatedAt:Instant=Instant.now(),val updatedBy:String) data class VersionInfo(val version:Int=1,val active:Boolean=true) data class EntityMetadata(override val id:String=UUID.randomUUID().toString(),val audit:AuditInfo,val version:VersionInfo=VersionInfo()) :DomainEntity 
File: ./domain/core/service/TableManagementService.kt
-------------------------------------------
package org.blackerp.domain.core.service import arrow.core.Either import kotlinx.coroutines.flow.Flow import org.blackerp.domain.core.error.TableError import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.values.* import java.util.UUID interface TableManagementService {suspend fun createTable(command:org.blackerp.domain.core.ad.table.CreateTableCommand):Either<TableError,ADTable> suspend fun updateTable(id:UUID,command:org.blackerp.domain.core.ad.table.UpdateTableCommand):Either<TableError,ADTable> suspend fun deleteTable(id:UUID):Either<TableError,Unit> suspend fun getTable(id:UUID):Either<TableError,ADTable?> suspend fun findTables(criteria:TableSearchCriteria):Flow<ADTable>} data class TableSearchCriteria(val namePattern:String?=null,val accessLevel:AccessLevel?=null,val modifiedSince:java.time.Instant?=null,val pageSize:Int=20,val page:Int=0)
File: ./domain/core/repository/ColumnOperations.kt
-------------------------------------------
package org.blackerp.domain.core.repository import arrow.core.Either import org.blackerp.domain.core.ad.table.ColumnDefinition import org.blackerp.domain.core.error.TableError import java.util.UUID interface ColumnOperations {suspend fun save(tableId:UUID,column:ColumnDefinition):Either<TableError,ColumnDefinition> suspend fun findByTable(tableId:UUID):Either<TableError,List<ColumnDefinition>> suspend fun delete(tableId:UUID,columnName:String):Either<TableError,Unit>} 
File: ./domain/core/security/SecurityModel.kt
-------------------------------------------
package org.blackerp.domain.core.security import java.util.UUID import java.time.Instant data class User(val id:UUID=UUID.randomUUID(),val username:String,val email:String,val isActive:Boolean=true,val roles:Set<Role>,val clientId:UUID,val organizationId:UUID?,val lastLogin:Instant?=null) data class Role(val id:UUID=UUID.randomUUID(),val name:String,val permissions:Set<Permission>,val scope:SecurityScope) data class Permission(val id:UUID=UUID.randomUUID(),val code:String,val description:String,val type:PermissionType) enum class PermissionType {READ,WRITE,DELETE,EXECUTE,ADMIN} enum class SecurityScope {SYSTEM,CLIENT,ORGANIZATION} data class SecurityContext(val user:User,val clientId:UUID,val organizationId:UUID?,val roles:Set<Role>) {fun hasPermission(permission:String):Boolean=roles.any {role->role.permissions.any {it.code == permission}}} 
File: ./domain/core/security/SecurityOperations.kt
-------------------------------------------
package org.blackerp.domain.core.security import arrow.core.Either import kotlinx.coroutines.flow.Flow import java.util.UUID interface SecurityOperations {suspend fun authenticate(credentials:Credentials):Either<SecurityError,AuthToken> suspend fun validateToken(token:String):Either<SecurityError,SecurityContext> suspend fun hasPermission(context:SecurityContext,permission:String):Boolean suspend fun getUserRoles(userId:UUID):Flow<Role> suspend fun getRolePermissions(roleId:UUID):Flow<Permission>} data class Credentials(val username:String,val password:String,val clientId:UUID) data class AuthToken(val token:String,val expiresAt:java.time.Instant,val refreshToken:String) sealed class SecurityError {data class InvalidCredentials(val message:String) :SecurityError() data class InvalidToken(val message:String) :SecurityError() data class InsufficientPermissions(val message:String) :SecurityError() data class UserNotFound(val message:String) :SecurityError()} 
File: ./domain/core/Version.kt
-------------------------------------------
package org.blackerp.domain.core data class Version(val major:Int,val minor:Int,val patch:Int) {override fun toString()="$major.$minor.$patch"} 
File: ./domain/core/reference/ReferenceError.kt
-------------------------------------------
// domain/core/reference/ReferenceError.kt package org.blackerp.domain.core.reference import org.blackerp.domain.core.error.DomainError import java.util.UUID sealed class ReferenceError(override val message:String,override val code:String?=null,override val cause:Throwable?=null) :DomainError(message,code,cause) {data class NotFound(val id:UUID) :ReferenceError(message="Reference not found:$id",code="REF_NOT_FOUND") data class ValidationFailed(val details:String) :ReferenceError(message="Reference validation failed:$details",code="REF_VALIDATION_FAILED") data class CacheError(val operation:String,val details:String) :ReferenceError(message="Cache operation '$operation' failed:$details",code="REF_CACHE_ERROR")} enum class CacheStrategy {NONE,READ_WRITE,READ_ONLY} 
File: ./domain/validation/validators/module/ModuleValidator.kt
-------------------------------------------
package org.blackerp.domain.validation.validators.module import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.ad.base.ADModule import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.validation.Validator class ModuleValidator :Validator<ADModule> {override suspend fun validate(entity:ADModule):Either<ValidationError,ADModule> {val errors=mutableListOf<ValidationError>() // Validate module name format if (!entity.name.value.matches(Regex("^[a-z][a-z0-9-]*$"))) {errors.add(ValidationError.InvalidFormat("Module name must start with lowercase letter and contain only lowercase letters,numbers,and hyphens"))} // Validate display name if (entity.displayName.value.isBlank()) {errors.add(ValidationError.Required("display name"))} // Validate description length if present entity.description?.value?.let {desc->if (desc.length> 255) {errors.add(ValidationError.InvalidLength("description",0,255))}} return if (errors.isEmpty()) {entity.right()} else {errors.first().left()}}} 
File: ./domain/validation/ValidatorRegistry.kt
-------------------------------------------
// domain/validation/ValidatorRegistry.kt package org.blackerp.domain.validation interface ValidatorRegistry {fun <T> getValidator(type:Class<T>):Validator<T>?} 
File: ./domain/validation/Validator.kt
-------------------------------------------
// domain/validation/Validator.kt package org.blackerp.domain.validation import arrow.core.Either import org.blackerp.domain.core.shared.ValidationError interface Validator<T> {suspend fun validate(entity:T):Either<ValidationError,T>} 
File: ./domain/validation/BaseValidator.kt
-------------------------------------------
// domain/validation/BaseValidator.kt package org.blackerp.domain.validation import arrow.core.Either import arrow.core.right import org.blackerp.domain.core.shared.ValidationError abstract class BaseValidator<T> :Validator<T> {override suspend fun validate(entity:T):Either<ValidationError,T>=entity.right()} 
File: ./domain/events/WorkflowEvents.kt
-------------------------------------------
package org.blackerp.domain.events import java.util.UUID import org.blackerp.domain.core.ad.workflow.NodeType import org.blackerp.domain.core.ad.workflow.WorkflowNode sealed class WorkflowEvent :DomainEvent {data class NodeCreated(override val metadata:EventMetadata,val node:WorkflowNode) :WorkflowEvent() data class NodeUpdated(override val metadata:EventMetadata,val nodeId:UUID,val changes:Map<String,ChangePair>) :WorkflowEvent() data class NodeDeleted(override val metadata:EventMetadata,val nodeId:UUID,val nodeName:String) :WorkflowEvent()} 
File: ./domain/events/RelationshipEvents.kt
-------------------------------------------
package org.blackerp.domain.events import java.util.UUID import org.blackerp.domain.core.ad.table.RelationshipType import org.blackerp.domain.core.ad.table.CascadeType sealed class RelationshipEvent :DomainEvent {data class RelationshipCreated(override val metadata:EventMetadata,val relationshipId:UUID,val sourceTableId:UUID,val targetTableId:UUID,val type:RelationshipType,val sourceColumn:String,val targetColumn:String,val onDelete:CascadeType,val onUpdate:CascadeType) :RelationshipEvent() data class RelationshipModified(override val metadata:EventMetadata,val relationshipId:UUID,val previousType:RelationshipType,val newType:RelationshipType,val previousOnDelete:CascadeType,val newOnDelete:CascadeType,val previousOnUpdate:CascadeType,val newOnUpdate:CascadeType) :RelationshipEvent() data class RelationshipDeleted(override val metadata:EventMetadata,val relationshipId:UUID,val sourceTableId:UUID,val targetTableId:UUID) :RelationshipEvent()} 
File: ./domain/events/EventMetadata.kt
-------------------------------------------
package org.blackerp.domain.events import java.time.Instant import java.util.UUID data class EventMetadata(val id:UUID=UUID.randomUUID(),val timestamp:Instant=Instant.now(),val user:String,val version:Int=1,val correlationId:String?=null) 
File: ./domain/events/DomainEvent.kt
-------------------------------------------
package org.blackerp.domain.events interface DomainEvent {val metadata:EventMetadata} data class ChangePair(val oldValue:Any?,val newValue:Any?) {val hasChanged:Boolean get()=oldValue != newValue} 
File: ./domain/events/ConstraintEvents.kt
-------------------------------------------
package org.blackerp.domain.events import java.util.UUID import org.blackerp.domain.core.ad.table.ConstraintType sealed class ConstraintEvent :DomainEvent {data class ConstraintCreated(override val metadata:EventMetadata,val constraintId:UUID,val tableId:UUID,val name:String,val type:ConstraintType,val columns:List<String>,val expression:String?) :ConstraintEvent() data class ConstraintModified(override val metadata:EventMetadata,val constraintId:UUID,val previousName:String,val newName:String,val previousColumns:List<String>,val newColumns:List<String>,val previousExpression:String?,val newExpression:String?) :ConstraintEvent() data class ConstraintDeleted(override val metadata:EventMetadata,val constraintId:UUID,val tableId:UUID,val name:String) :ConstraintEvent() data class ConstraintViolated(override val metadata:EventMetadata,val constraintId:UUID,val tableId:UUID,val violationType:ViolationType,val violationDetails:String) :ConstraintEvent()} enum class ViolationType {UNIQUE_VIOLATION,CHECK_VIOLATION,FOREIGN_KEY_VIOLATION} 
File: ./domain/events/DocumentEvents.kt
-------------------------------------------
package org.blackerp.domain.events import org.blackerp.domain.core.ad.document.DocumentStatus import java.util.UUID sealed class DocumentEvent :DomainEvent {data class StatusChanged(override val metadata:EventMetadata,val documentId:UUID,val previousStatus:DocumentStatus,val newStatus:DocumentStatus,val reason:String?) :DocumentEvent() data class DocumentCreated(override val metadata:EventMetadata,val documentId:UUID,val type:String,val status:DocumentStatus) :DocumentEvent() data class DocumentModified(override val metadata:EventMetadata,val documentId:UUID,val changes:Map<String,ChangePair>) :DocumentEvent()} 
File: ./build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") version "1.9.20" apply false kotlin("plugin.spring") version "1.9.20" apply false id("org.springframework.boot") version "3.2.0" apply false id("io.spring.dependency-management") version "1.1.4" apply false} allprojects {group="org.blackerp" version="0.0.1-SNAPSHOT" repositories {mavenCentral()}} subprojects {apply(plugin="org.jetbrains.kotlin.jvm") apply(plugin="org.springframework.boot") apply(plugin="io.spring.dependency-management") tasks.withType<JavaCompile> {sourceCompatibility=JavaVersion.VERSION_17.toString() targetCompatibility=JavaVersion.VERSION_17.toString()} tasks.withType<org.jetbrains.kotlin.gradle.tasks.KotlinCompile> {kotlinOptions {jvmTarget="17" freeCompilerArgs=listOf("-Xjsr305=strict")}}} 
File: ./application/services/ADMetadataService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.metadata.AuditInfo import org.blackerp.domain.core.metadata.VersionInfo import org.blackerp.domain.core.error.TableError import org.blackerp.domain.core.security.SecurityContext import arrow.core.Either import arrow.core.right import arrow.core.left import java.util.UUID import java.time.Instant @Service class ADMetadataService(private val securityContext:SecurityContext) {@Transactional fun generateMetadata(tableName:String):Either<TableError,EntityMetadata> {val currentUser=securityContext.user.username return EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy=currentUser,updatedBy=currentUser),version=VersionInfo()).right()} @Transactional fun incrementVersion(metadata:EntityMetadata):Either<TableError,EntityMetadata> {val currentUser=securityContext.user.username return metadata.copy(audit=metadata.audit.copy(updatedBy=currentUser,updatedAt=Instant.now()),version=metadata.version.copy(version=metadata.version.version + 1)).right()}} 
File: ./application/services/CoroutineConfig.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import kotlinx.coroutines.CoroutineDispatcher import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.asCoroutineDispatcher import java.util.concurrent.Executors @Configuration class CoroutineConfig {@Bean fun ioDispatcher():CoroutineDispatcher=Executors.newFixedThreadPool(10).asCoroutineDispatcher()} 
File: ./application/services/cache/CacheStrategy.kt
-------------------------------------------
package org.blackerp.application.services.cache enum class CacheStrategy {NONE,READ_WRITE,READ_ONLY} 
File: ./application/services/error/DomainProcessError.kt
-------------------------------------------
package org.blackerp.application.services.error import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.ad.process.ProcessError sealed class DomainProcessError(override val message:String) :DomainError(message) {data class ValidationFailed(val details:String) :DomainProcessError("Validation failed:$details") data class ExecutionFailed(val details:String) :DomainProcessError("Execution failed:$details") data class NotFound(val id:String) :DomainProcessError("Process not found:$id") data class UnexpectedError(override val message:String) :DomainProcessError(message) companion object {fun fromProcessError(error:ProcessError):DomainProcessError=when (error) {is ProcessError.ValidationFailed->ValidationFailed(error.details) is ProcessError.ExecutionFailed->ExecutionFailed(error.details) is ProcessError.NotFound->NotFound(error.id.toString()) is ProcessError.UnexpectedError->UnexpectedError(error.message)}}} 
File: ./application/services/docstatus/DocStatusService.kt
-------------------------------------------
package org.blackerp.application.services.docstatus import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.docstatus.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import java.util.UUID @Service class DocStatusService {// In-memory storage for POC private val statuses=mutableMapOf<String,DocStatus>() suspend fun getStatus(code:String):Either<DocStatusError,DocStatus?> {val status=statuses[code] return status?.right() ?:DocStatusError.NotFound(UUID.randomUUID()).left()} suspend fun validateTransition(from:String,to:String):Either<DocStatusError,Unit> {return when (val status=statuses[from]) {null->DocStatusError.NotFound(UUID.randomUUID()).left() else->{if (status.allowedTransitions.contains(to)) Unit.right() else DocStatusError.StatusTransitionInvalid(from,to).left()}}}} 
File: ./application/services/docaction/DocActionService.kt
-------------------------------------------
package org.blackerp.application.services.docaction import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.docaction.* import org.blackerp.application.services.docstatus.DocStatusService import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import org.slf4j.LoggerFactory import java.util.UUID @Service class DocActionService(private val docStatusService:DocStatusService) :DocActionOperations {private val logger=LoggerFactory.getLogger(DocActionService::class.java) // In-memory storage for POC private val actions=mutableMapOf<String,DocAction>() override suspend fun register(action:DocAction):Either<DocActionError,DocAction> {logger.debug("Registering action:${action.code}") actions[action.code]=action return action.right()} override suspend fun findByCode(code:String):Either<DocActionError,DocAction?> {val action=actions[code] return action?.right() ?:DocActionError.NotFound(code).left()} override suspend fun execute(code:String,context:DocActionContext):Either<DocActionError,DocActionResult> {val action=actions[code] ?:return DocActionError.NotFound(code).left() return action.execute(context)} override suspend fun listActions():Flow<DocAction>=flowOf(*actions.values.toTypedArray())} 
File: ./application/services/SecurityService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.springframework.security.crypto.password.PasswordEncoder import org.blackerp.domain.core.security.* import arrow.core.Either import kotlinx.coroutines.flow.* import java.util.UUID @Service class SecurityService(private val passwordEncoder:PasswordEncoder) :SecurityOperations {override suspend fun authenticate(credentials:Credentials):Either<SecurityError,AuthToken>=TODO() override suspend fun validateToken(token:String):Either<SecurityError,SecurityContext>=TODO() override suspend fun getUserRoles(userId:UUID):Flow<Role>=flow {} override suspend fun getRolePermissions(roleId:UUID):Flow<Permission>=flow {} override suspend fun hasPermission(context:SecurityContext,permission:String):Boolean=TODO()} 
File: ./application/services/config/SecurityConfig.kt
-------------------------------------------
package org.blackerp.application.services.config import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder import org.springframework.security.crypto.password.PasswordEncoder @Configuration class SecurityConfig {@Bean fun passwordEncoder():PasswordEncoder=BCryptPasswordEncoder()} 
File: ./application/services/SecurityFilter.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.web.server.ServerWebExchange import org.springframework.web.server.WebFilter import org.springframework.web.server.WebFilterChain import org.springframework.stereotype.Component import org.springframework.http.HttpStatus import reactor.core.publisher.Mono import kotlinx.coroutines.runBlocking import org.slf4j.LoggerFactory @Component class SecurityFilter(private val securityService:SecurityService) :WebFilter {private val logger=LoggerFactory.getLogger(SecurityFilter::class.java) private val publicPaths=setOf("/api/auth/login","/api/auth/refresh") override fun filter(exchange:ServerWebExchange,chain:WebFilterChain):Mono<Void> {val path=exchange.request.path.value() if (publicPaths.any {path.startsWith(it)}) {return chain.filter(exchange)} val authHeader=exchange.request.headers.getFirst("Authorization") val authToken=authHeader?.removePrefix("Bearer ") if (authToken == null) {exchange.response.statusCode=HttpStatus.UNAUTHORIZED return exchange.response.setComplete()} return Mono.defer {runBlocking {securityService.validateToken(authToken)}.fold({error->logger.error("Authentication failed:$error") exchange.response.statusCode=HttpStatus.UNAUTHORIZED exchange.response.setComplete()},{context->exchange.attributes["securityContext"]=context chain.filter(exchange)}) Mono.empty()}}} 
File: ./application/services/process/ProcessServiceImpl.kt
-------------------------------------------
package org.blackerp.application.services.process import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.process.* import org.blackerp.infrastructure.process.executor.ProcessExecutorImpl import org.blackerp.infrastructure.process.tracking.ProcessExecutionTracker import org.blackerp.infrastructure.process.validation.ParameterValidator import arrow.core.Either import arrow.core.flatMap import kotlinx.coroutines.flow.* import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Service class ProcessServiceImpl(private val processOperations:ProcessOperations,private val processExecutor:ProcessExecutorImpl,private val executionTracker:ProcessExecutionTracker,private val parameterValidator:ParameterValidator) :ProcessService {private val logger=LoggerFactory.getLogger(ProcessServiceImpl::class.java) override suspend fun execute(id:UUID,parameters:Map<String,Any>,async:Boolean):Either<ProcessError,ProcessResult> {logger.debug("Executing process $id with parameters:$parameters") return processOperations.findById(id).flatMap {process->process?.let {p->// Validate parameters validateParameters(id,parameters).flatMap {validatedParams->// Execute process processExecutor.execute(id,validatedParams,async).map {result->// Track execution trackExecution(id,parameters,result) result}}} ?:ProcessError.NotFound(id).left()}} override suspend fun validateParameters(id:UUID,parameters:Map<String,Any>):Either<ProcessError,Map<String,Any>> {return processOperations.findById(id).flatMap {process->process?.let {p->parameterValidator.validate(parameters,p.parameters)} ?:ProcessError.NotFound(id).left()}} private fun trackExecution(processId:UUID,parameters:Map<String,Any>,result:ProcessResult) {val execution=ProcessExecution(processId=processId,startTime=Instant.now(),endTime=Instant.now(),status=if (result.success) ExecutionStatus.COMPLETED else ExecutionStatus.FAILED,parameters=parameters,result=result,user="system" // TODO:Get from security context) executionTracker.trackExecution(processId,execution)}} 
File: ./application/services/DocumentService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.document.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import java.util.UUID @Service class DocumentService :DocumentOperations {override suspend fun create(document:Document):Either<DocumentError,Document>=document.right() override suspend fun findById(id:UUID):Either<DocumentError,Document?>=null.right() override suspend fun search(criteria:SearchCriteria):Flow<Document>=flowOf() override suspend fun delete(id:UUID):Either<DocumentError,Unit>=Unit.right() override suspend fun update(id:UUID,document:Document):Either<DocumentError,Document>=document.right() override suspend fun changeStatus(id:UUID,status:DocumentStatus):Either<DocumentError,Document>=DocumentError.NotFound(id).left()} 
File: ./application/services/interfaces/ProcessInterfaces.kt
-------------------------------------------
package org.blackerp.application.services.interfaces import java.util.UUID import arrow.core.Either import org.blackerp.domain.core.error.ProcessError data class ProcessResult(val success:Boolean,val message:String) interface ProcessExecutor {suspend fun execute(processId:UUID,params:Map<String,Any>,async:Boolean=false):Either<ProcessError,ProcessResult>} interface ProcessRepository {suspend fun save(process:Process):Either<ProcessError,Process> suspend fun findById(id:UUID):Either<ProcessError,Process?>} 
File: ./application/services/core/ServiceImports.kt
-------------------------------------------
package org.blackerp.application.services.core import org.springframework.transaction.annotation.Transactional import org.springframework.transaction.annotation.Propagation import org.springframework.stereotype.Service import org.springframework.context.annotation.Bean import org.springframework.context.annotation.Configuration import kotlinx.coroutines.* import arrow.core.* import java.util.UUID 
File: ./application/services/core/ServiceBase.kt
-------------------------------------------
package org.blackerp.application.services.core import org.springframework.transaction.annotation.Transactional import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import arrow.core.Either import arrow.core.left import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.error.UnexpectedError abstract class ServiceBase {@Transactional(readOnly=true) protected suspend fun <T> withTransaction(block:suspend ()->Either<DomainError,T>):Either<DomainError,T>=withContext(Dispatchers.IO) {try {block()} catch (e:Exception) {UnexpectedError(e.message ?:"Unknown error").left()}}} 
File: ./application/services/TableService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.table.TableOperations import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.error.TableError import arrow.core.Either import java.util.UUID import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext @Service class TableService(private val tableOperations:TableOperations) {@Transactional(readOnly=true) suspend fun findAll():Either<TableError,List<ADTable>>=withContext(Dispatchers.IO) {tableOperations.findAll()} @Transactional suspend fun save(table:ADTable):Either<TableError,ADTable>=withContext(Dispatchers.IO) {tableOperations.save(table)} suspend fun findById(id:UUID):Either<TableError,ADTable?>=withContext(Dispatchers.IO) {tableOperations.findById(id)} @Transactional suspend fun delete(id:UUID):Either<TableError,Unit>=withContext(Dispatchers.IO) {tableOperations.delete(id)}} 
File: ./application/services/ImportTransactional.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.transaction.annotation.Transactional import org.springframework.transaction.annotation.Propagation 
File: ./application/services/ProcessService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.process.* import arrow.core.* import kotlinx.coroutines.flow.* import java.util.UUID @Service class ProcessService :ProcessOperations {override suspend fun getExecutionHistory(id:UUID,pageSize:Int,page:Int):Flow<ProcessExecution>=flowOf() override suspend fun save(process:ADProcess):Either<ProcessError,ADProcess>=process.right() override suspend fun findById(id:UUID):Either<ProcessError,ADProcess?>=null.right() override suspend fun delete(id:UUID):Either<ProcessError,Unit>=Unit.right() override suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADProcess>=flowOf() override suspend fun execute(id:UUID,parameters:Map<String,Any>,async:Boolean):Either<ProcessError,ProcessResult>=ProcessResult(success=true,message="Success",data=null).right() override suspend fun validateParameters(id:UUID,parameters:Map<String,Any>):Either<ProcessError,Map<String,List<String>>>=mapOf<String,List<String>>().right() override suspend fun schedule(id:UUID,schedule:ProcessSchedule):Either<ProcessError,ADProcess>=ProcessError.NotFound(id).left()} 
File: ./application/services/common/ServiceImports.kt
-------------------------------------------
package org.blackerp.application.services.common import org.springframework.transaction.annotation.Transactional import org.springframework.transaction.annotation.Propagation import org.springframework.stereotype.Service import kotlinx.coroutines.* import arrow.core.* import java.util.UUID 
File: ./application/services/common/ServiceBase.kt
-------------------------------------------
package org.blackerp.application.services.common import org.springframework.transaction.annotation.Transactional import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import arrow.core.Either import arrow.core.left import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.error.UnexpectedError abstract class ServiceBase {@Transactional(readOnly=true) protected suspend fun <T> withTransaction(block:suspend ()->Either<DomainError,T>):Either<DomainError,T>=withContext(Dispatchers.IO) {try {block()} catch (e:Exception) {UnexpectedError(e.message ?:"Unknown error").left()}}} 
File: ./application/services/WorkflowService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.workflow.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import kotlinx.coroutines.flow.flowOf import org.slf4j.LoggerFactory import java.util.UUID @Service class WorkflowService(private val workflowOperations:WorkflowOperations) :WorkflowOperations {private val logger=LoggerFactory.getLogger(WorkflowService::class.java) override suspend fun save(node:WorkflowNode):Either<WorkflowError,WorkflowNode>=workflowOperations.save(node) override suspend fun findById(id:UUID):Either<WorkflowError,WorkflowNode?>=workflowOperations.findById(id) override suspend fun delete(id:UUID):Either<WorkflowError,Unit>=workflowOperations.delete(id) override suspend fun validateWorkflow(nodes:List<WorkflowNode>):Either<WorkflowError,Unit>=validateWorkflowStructure(nodes) private fun validateWorkflowStructure(nodes:List<WorkflowNode>):Either<WorkflowError,Unit> {// Basic validation rules if (nodes.isEmpty()) {return WorkflowError.ValidationFailed("Workflow must contain at least one node").left()} // Check for start and end nodes val startNodes=nodes.filter {it.type == NodeType.START} val endNodes=nodes.filter {it.type == NodeType.END} if (startNodes.isEmpty()) {return WorkflowError.ValidationFailed("Workflow must have a start node").left()} if (endNodes.isEmpty()) {return WorkflowError.ValidationFailed("Workflow must have an end node").left()} return Unit.right()}} 
File: ./application/services/DocumentProcessService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.events.DocumentEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.domain.events.DomainEventPublisher import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID import org.slf4j.LoggerFactory @Service class DocumentProcessService(private val documentOperations:DocumentOperations,private val processHandler:DocumentProcessHandler,private val eventPublisher:DomainEventPublisher) {private val logger=LoggerFactory.getLogger(DocumentProcessService::class.java) suspend fun executeDocumentProcess(documentId:UUID,processId:UUID,parameters:Map<String,Any>):Either<DocumentError,ProcessResult> {logger.debug("Executing process $processId for document $documentId") return documentOperations.findById(documentId) .flatMap {document->if (document == null) {DocumentError.NotFound(documentId).left()} else {processHandler.executeDocumentProcess(document,processId,parameters) .also {result->result.fold({error->logger.error("Process execution failed:${error.message}")},{processResult->publishProcessExecutionEvent(document,processId,processResult)})}}}} private fun publishProcessExecutionEvent(document:Document,processId:UUID,result:ProcessResult) {eventPublisher.publish(DocumentEvent.ProcessExecuted(metadata=EventMetadata(user="system",// TODO:Get from security context correlationId=UUID.randomUUID().toString()),documentId=UUID.fromString(document.id),processId=processId,success=result.success,message=result.message))}} 
File: ./application/services/ReferenceService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.reference.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.Flow import java.util.UUID @Service class ReferenceService(private val referenceRepository:ReferenceRepository,private val referenceCache:ReferenceCache,private val metadataService:ADMetadataService) :ReferenceOperations {override suspend fun save(reference:ADReference):Either<ReferenceError,ADReference>=referenceRepository.save(reference) override suspend fun findById(id:UUID):Either<ReferenceError,ADReference?>=referenceRepository.findById(id) override suspend fun findByName(refName:String):Either<ReferenceError,ADReference?>=referenceRepository.findByName(refName) // Other implementations... override suspend fun search(query:String,pageSize:Int,page:Int):Flow<ADReference>=referenceRepository.search(query,pageSize,page) override suspend fun getValues(referenceId:UUID,searchText:String?,pageSize:Int,page:Int):Either<ReferenceError,List<ReferenceValue<*>>>=TODO() override suspend fun validateValue(referenceId:UUID,value:Any):Either<ReferenceError,Boolean>=TODO() override suspend fun getHierarchy(rootId:UUID?):Either<ReferenceError,List<ADReference>>=TODO() override suspend fun delete(id:UUID):Either<ReferenceError,Unit>=TODO()} 
File: ./application/services/base/CoroutineBaseService.kt
-------------------------------------------
package org.blackerp.application.services.base import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import arrow.core.Either import arrow.core.left import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.error.UnexpectedError abstract class CoroutineBaseService {protected suspend fun <T> withTransaction(block:suspend ()->Either<DomainError,T>):Either<DomainError,T>=withContext(Dispatchers.IO) {try {block()} catch (e:Exception) {UnexpectedError(e.message ?:"Unknown error").left()}}} 
File: ./application/services/table/TableManagementService.kt
-------------------------------------------
package org.blackerp.application.services.table import org.springframework.stereotype.Service import org.springframework.transaction.annotation.Transactional import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.error.TableError import org.blackerp.domain.core.metadata.* import org.blackerp.application.services.metrics.TableMetrics import arrow.core.* import kotlinx.coroutines.flow.* import java.util.UUID @Service class TableManagementService(private val tableOperations:TableOperations,private val tableValidator:TableValidator,private val tableMetrics:TableMetrics) {@Transactional suspend fun createTable(command:CreateTableCommand):Either<TableError,ADTable>=tableValidator.validateCreate(command).flatMap {validatedCommand->val table=ADTable(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system"),version=VersionInfo()),name=validatedCommand.name,displayName=validatedCommand.displayName,description=validatedCommand.description,accessLevel=validatedCommand.accessLevel,columns=emptyList()) tableOperations.save(table)} suspend fun findTables():Flow<ADTable>=flow {tableOperations.findAll().fold({emitAll(flowOf())},{tables->emitAll(flowOf(*tables.toTypedArray()))})}} 
File: ./application/services/workflow/WorkflowServiceImpl.kt
-------------------------------------------
// application/services/workflow/WorkflowServiceImpl.kt package org.blackerp.application.services.workflow import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.events.WorkflowEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import org.blackerp.domain.core.shared.ValidationError import arrow.core.* import kotlinx.coroutines.flow.Flow import java.util.UUID import org.slf4j.LoggerFactory @Service class WorkflowServiceImpl(private val workflowOperations:WorkflowOperations,private val eventPublisher:DomainEventPublisher) :WorkflowService {private val logger=LoggerFactory.getLogger(WorkflowServiceImpl::class.java) override suspend fun createWorkflow(command:CreateWorkflowCommand):Either<WorkflowError,WorkflowNode> {logger.debug("Creating workflow node:{}",command.displayName) return command.toNode().flatMap {node->workflowOperations.save(node).also {result->result.fold({error->logger.error("Failed to create node:{}",error.message)},{savedNode->eventPublisher.publish(WorkflowEvent.NodeCreated(metadata=EventMetadata(user="system"),node=savedNode))})}}} override suspend fun updateWorkflow(id:UUID,command:UpdateWorkflowCommand):Either<WorkflowError,WorkflowNode> {logger.debug("Updating workflow node:{}",id) return workflowOperations.findById(id).flatMap {existing->existing?.let {node->val updated=node.copy(displayName=command.displayName ?:node.displayName,description=command.description ?:node.description) workflowOperations.save(updated).also {result->result.fold({error->logger.error("Failed to update node:{}",error.message)},{updatedNode->eventPublisher.publish(WorkflowEvent.NodeUpdated(metadata=EventMetadata(user="system"),nodeId=UUID.fromString(updatedNode.id),changes=mapOf() // Add actual changes tracking))})}} ?:WorkflowError.NotFound(id).left()}} override suspend fun validateWorkflow(id:UUID):Either<WorkflowError,ValidationResult> {logger.debug("Validating workflow:{}",id) return workflowOperations.findById(id).flatMap {node->node?.let {workflowOperations.validateWorkflow(listOf(it)).map {ValidationResult(valid=true)}} ?:WorkflowError.NotFound(id).left()}} override suspend fun executeWorkflow(id:UUID,context:WorkflowContext):Either<WorkflowError,WorkflowResult> {logger.debug("Executing workflow:{} for document:{}",id,context.document.id) return workflowOperations.findById(id).flatMap {node->node?.let {// Implement actual workflow execution logic WorkflowResult(completed=true,currentNode=UUID.fromString(node.id),nextNodes=emptyList(),attributes=context.attributes).right()} ?:WorkflowError.NotFound(id).left()}}}
File: ./application/services/workflow/WorkflowExecutionTracker.kt
-------------------------------------------
package org.blackerp.application.services.workflow import org.springframework.stereotype.Component import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Component class WorkflowExecutionTracker {private val logger=LoggerFactory.getLogger(WorkflowExecutionTracker::class.java) // In-memory tracking for POC - replace with persistence private val activeExecutions=mutableMapOf<UUID,WorkflowExecutionState>() fun startExecution(workflowId:UUID,document:UUID) {val executionId=UUID.randomUUID() activeExecutions[executionId]=WorkflowExecutionState(id=executionId,workflowId=workflowId,documentId=document,startTime=Instant.now(),status=ExecutionStatus.RUNNING) logger.info("Started workflow execution:{} for document:{}",executionId,document)} fun updateExecutionStatus(executionId:UUID,status:ExecutionStatus) {activeExecutions[executionId]?.let {state->activeExecutions[executionId]=state.copy(status=status,endTime=if (status.isTerminal()) Instant.now() else null) logger.info("Updated execution status:{}->{}",executionId,status)}} fun getExecutionState(executionId:UUID):WorkflowExecutionState?=activeExecutions[executionId]} data class WorkflowExecutionState(val id:UUID,val workflowId:UUID,val documentId:UUID,val startTime:Instant,val endTime:Instant?=null,val status:ExecutionStatus,val currentNode:UUID?=null,val attributes:Map<String,Any>=emptyMap()) enum class ExecutionStatus {RUNNING,COMPLETED,FAILED,CANCELLED;fun isTerminal()=this != RUNNING} 
File: ./application/services/workflow/WorkflowExecutionEngine.kt
-------------------------------------------
package org.blackerp.application.services.workflow import org.springframework.stereotype.Component import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.events.WorkflowEvent import org.blackerp.infrastructure.events.publishers.DomainEventPublisher import org.blackerp.domain.core.ad.document.Document import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import java.util.UUID import org.slf4j.LoggerFactory @Component class WorkflowExecutionEngine(private val workflowOperations:WorkflowOperations,private val eventPublisher:DomainEventPublisher) {private val logger=LoggerFactory.getLogger(WorkflowExecutionEngine::class.java) suspend fun executeNode(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult>=withContext(Dispatchers.IO) {logger.debug("Executing workflow node:{} of type:{}",node.id,node.type) try {when (node.type) {NodeType.START->handleStartNode(node,context) NodeType.ACTIVITY->executeActivity(node,context) NodeType.DECISION->evaluateDecision(node,context) NodeType.END->handleEndNode(node,context)}} catch (e:Exception) {logger.error("Error executing node:${node.id}",e) WorkflowError.ValidationFailed("Node execution failed:${e.message}").left()}} private suspend fun handleStartNode(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult> {// Initialize workflow context and validate initial state val nextNodes=node.transitions.filter {transition->transition.condition?.let {evaluateCondition(it,context)} ?:true}.map {it.targetNode} return WorkflowExecutionResult(nodeId=UUID.fromString(node.id),status=NodeExecutionStatus.COMPLETED,nextNodes=nextNodes,outputAttributes=context.attributes).right()} private suspend fun executeActivity(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult> {// Execute activity action if present node.action?.let {action->when (action) {is NodeAction.Process->executeProcess(action,context) is NodeAction.UserTask->handleUserTask(action,context) is NodeAction.Notification->sendNotification(action,context)}} // Determine next nodes based on transitions val nextNodes=node.transitions.filter {transition->transition.condition?.let {evaluateCondition(it,context)} ?:true}.map {it.targetNode} return WorkflowExecutionResult(nodeId=UUID.fromString(node.id),status=NodeExecutionStatus.COMPLETED,nextNodes=nextNodes,outputAttributes=context.attributes).right()} private suspend fun evaluateDecision(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult> {// Evaluate conditions and determine next path val nextNodes=node.transitions .filter {transition->transition.condition?.let {evaluateCondition(it,context)} ?:false} .map {it.targetNode} if (nextNodes.isEmpty()) {return WorkflowError.ValidationFailed("No valid transition found for decision node").left()} return WorkflowExecutionResult(nodeId=UUID.fromString(node.id),status=NodeExecutionStatus.COMPLETED,nextNodes=nextNodes,outputAttributes=context.attributes).right()} private suspend fun handleEndNode(node:WorkflowNode,context:WorkflowContext):Either<WorkflowError,WorkflowExecutionResult> {// Finalize workflow execution return WorkflowExecutionResult(nodeId=UUID.fromString(node.id),status=NodeExecutionStatus.COMPLETED,nextNodes=emptyList(),outputAttributes=context.attributes).right()} private fun evaluateCondition(condition:TransitionCondition,context:WorkflowContext):Boolean {// Simple condition evaluation - can be enhanced with expression engine return try {// Example:evaluate basic expressions on context attributes true // Placeholder for actual evaluation} catch (e:Exception) {logger.error("Error evaluating condition:${condition.expression}",e) false}} private suspend fun executeProcess(action:NodeAction.Process,context:WorkflowContext) {// Implement process execution logger.debug("Executing process:{}",action.processId)} private suspend fun handleUserTask(action:NodeAction.UserTask,context:WorkflowContext) {// Implement user task handling logger.debug("Creating user task for role:{}",action.roleId)} private suspend fun sendNotification(action:NodeAction.Notification,context:WorkflowContext) {// Implement notification sending logger.debug("Sending notification:{}",action.template)}} // Add additional data classes for execution data class WorkflowExecutionResult(val nodeId:UUID,val status:NodeExecutionStatus,val nextNodes:List<UUID>,val outputAttributes:Map<String,Any>) enum class NodeExecutionStatus {PENDING,IN_PROGRESS,COMPLETED,FAILED,CANCELLED} 
File: ./application/services/workflow/WorkflowExtensions.kt
-------------------------------------------
package org.blackerp.application.services.workflow import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.application.api.process.CreateWorkflowCommand import arrow.core.* import java.util.UUID fun CreateWorkflowCommand.toNode():Either<WorkflowError,WorkflowNode> {val metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")) return DisplayName.create(displayName) .mapLeft {WorkflowError.ValidationFailed(it.message)} .flatMap {displayName->val desc=description?.let {Description.create(it).fold({WorkflowError.ValidationFailed(it.message).left()},{it.right()})} ?:null.right() desc.map {description->WorkflowNode(metadata=metadata,displayName=displayName,description=description,type=type,action=action,transitions=transitions.map {t->WorkflowTransition(id=UUID.randomUUID(),sourceNode=UUID.randomUUID(),targetNode=t.targetNodeId,condition=t.condition?.let {TransitionCondition(it,"Auto-generated")})})}}} 
File: ./application/services/TableMetrics.kt
-------------------------------------------
package org.blackerp.application.services.metrics import org.springframework.stereotype.Component import io.micrometer.core.instrument.MeterRegistry import java.time.Duration import java.util.concurrent.TimeUnit @Component class TableMetrics(private val meterRegistry:MeterRegistry) {private val createTableCounter=meterRegistry.counter("table.create.count") private val createTableTimer=meterRegistry.timer("table.create.duration") fun incrementCreateCounter()=createTableCounter.increment() fun <T> timeCreateOperation(operation:()->T):T {val start=System.nanoTime() return try {operation()} finally {val duration=System.nanoTime() - start createTableTimer.record(duration,TimeUnit.NANOSECONDS)}}} 
File: ./application/services/DocumentLifecycleService.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.ad.docstatus.AD_DocStatus import org.blackerp.domain.core.ad.docaction.DocActionRegistry import org.blackerp.domain.events.DocumentEvent import org.blackerp.domain.events.EventMetadata import org.blackerp.domain.events.DomainEventPublisher import org.blackerp.infrastructure.persistence.repositories.DocumentHistoryRepository import arrow.core.Either import arrow.core.left import arrow.core.right import java.util.UUID import java.time.Instant import org.slf4j.LoggerFactory @Service class DocumentLifecycleService(private val documentOperations:DocumentOperations,private val docActionRegistry:DocActionRegistry,private val eventPublisher:DomainEventPublisher,private val historyRepository:DocumentHistoryRepository) {private val logger=LoggerFactory.getLogger(DocumentLifecycleService::class.java) suspend fun changeStatus(id:UUID,command:ChangeStatusCommand):Either<DocumentError,Document> {logger.debug("Changing document status:$id->${command.targetStatus}") return documentOperations.findById(id) .flatMap {document->if (document == null) {DocumentError.NotFound(id).left()} else {validateStatusTransition(document,command.targetStatus) .flatMap {executeRequiredAction(document,command.targetStatus) .flatMap {documentOperations.changeStatus(id,command.targetStatus) .also {result->result.fold({/* error handled by caller */},{updatedDoc->trackStatusChange(document.status,updatedDoc.status,id,command.reason)})}}}}}} suspend fun getHistory(id:UUID,fromDate:Instant?=null,toDate:Instant?=null):Either<DocumentError,List<DocumentChange>>=documentOperations.findById(id).map {document->if (fromDate != null && toDate != null) {historyRepository.getHistoryBetween(id,fromDate,toDate)} else {historyRepository.getHistory(id)}} private fun trackStatusChange(previousStatus:DocumentStatus,newStatus:DocumentStatus,documentId:UUID,reason:String?) {// Track in history historyRepository.trackChange(DocumentChange(id=UUID.randomUUID(),documentId=documentId,changedAt=Instant.now(),changedBy="system",// TODO:Get from security context changes=mapOf("status" to ChangePair(previousStatus,newStatus)))) // Publish event eventPublisher.publish(DocumentEvent.StatusChanged(metadata=EventMetadata(user="system",// TODO:Get from security context correlationId=UUID.randomUUID().toString()),documentId=documentId,previousStatus=previousStatus,newStatus=newStatus,reason=reason))} // ... rest of the existing methods ...} 
File: ./application/services/TransactionalImports.kt
-------------------------------------------
package org.blackerp.application.services import org.springframework.transaction.annotation.Transactional import org.springframework.transaction.annotation.Propagation 
File: ./application/services/JwtProperties.kt
-------------------------------------------
package org.blackerp.application.services data class JwtProperties(val secret:String,val expirationHours:Int=24) 
File: ./application/api/mappers/TableMapper.kt
-------------------------------------------
// application/api/mappers/TableMapper.kt package org.blackerp.application.api.mappers import org.springframework.stereotype.Component import org.blackerp.application.api.dto.requests.CreateTableRequest import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.values.* import org.blackerp.domain.core.metadata.AuditInfo import org.blackerp.domain.core.shared.ValidationError import arrow.core.Either import java.util.UUID @Component class TableMapper {fun toDomain(request:CreateTableRequest):Either<ValidationError,ADTable>=TableName.create(request.name).map {tableName->ADTable(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),name=tableName,displayName=DisplayName.create(request.displayName).fold({throw IllegalArgumentException(it.message)},{it}),description=request.description?.let {desc->Description.create(desc).fold({throw IllegalArgumentException(it.message)},{it})},accessLevel=AccessLevel.valueOf(request.accessLevel.uppercase()))}} 
File: ./application/api/dto/requests/TableRequests.kt
-------------------------------------------
package org.blackerp.application.api.dto.requests import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.metadata.* import arrow.core.* import java.util.UUID data class CreateTableRequest(val name:String,val displayName:String,val description:String?,val accessLevel:String) {fun toDomain():Either<ValidationError,ADTable>=TableName.create(name).flatMap {tableName->DisplayName.create(displayName).flatMap {dispName->val descriptionResult=description?.let {desc->Description.create(desc)} ?:Either.Right(null) descriptionResult.map {desc->ADTable(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),displayName=dispName,description=desc,name=tableName,accessLevel=AccessLevel.valueOf(accessLevel.uppercase()))}}}} 
File: ./application/api/dto/requests/CreateDocumentRequest.kt
-------------------------------------------
package org.blackerp.application.api.dto.requests import java.util.UUID data class CreateDocumentRequest(val displayName:String,val description:String?,val typeId:UUID,val attributes:Map<String,Any>=emptyMap()) 
File: ./application/api/dto/requests/CreateProcessRequest.kt
-------------------------------------------
package org.blackerp.application.api.dto.requests import org.blackerp.domain.core.ad.process.* import java.util.UUID data class CreateProcessRequest(val displayName:String,val type:String,val parameters:List<ProcessParameterRequest>) data class ProcessParameterRequest(val name:String,val displayName:String,val description:String?,val mandatory:Boolean=false) 
File: ./application/api/dto/ParameterMapping.kt
-------------------------------------------
package org.blackerp.application.api.dto import org.blackerp.domain.core.ad.process.ProcessParameter as DomainProcessParameter import org.blackerp.domain.core.ad.process.ParameterType import org.blackerp.domain.core.values.DataType import java.util.UUID fun toDomainParameter(dto:org.blackerp.application.api.process.ProcessParameter):DomainProcessParameter {return DomainProcessParameter(id=UUID.randomUUID(),name=dto.name,displayName=dto.displayName,description=dto.description,parameterType=when(dto.dataType) {DataType.STRING->ParameterType.STRING DataType.INTEGER->ParameterType.NUMBER DataType.DATE->ParameterType.DATE DataType.BOOLEAN->ParameterType.BOOLEAN else->ParameterType.STRING},isMandatory=dto.mandatory,validationRule=null)} 
File: ./application/api/dto/TableDTO.kt
-------------------------------------------
package org.blackerp.application.api.dto import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.values.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.shared.ValidationError import java.util.UUID import arrow.core.Either import arrow.core.getOrElse data class TableDTO(val id:String?=null,val name:String,val displayName:String,val description:String?,val accessLevel:String) {companion object {fun fromDomain(table:ADTable)=TableDTO(id=table.id,name=table.name.value,displayName=table.displayName.value,description=table.description?.value,accessLevel=table.accessLevel.name)} fun toDomain():Either<ValidationError,ADTable>=TableName.create(name).map {tableName->ADTable(metadata=EntityMetadata(id=id ?:UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),name=tableName,displayName=DisplayName.create(displayName).getOrElse {throw IllegalArgumentException("Invalid display name")},description=description?.let {Description.create(it).getOrElse {null}},accessLevel=AccessLevel.valueOf(accessLevel))}} 
File: ./application/api/dto/responses/TableResponses.kt
-------------------------------------------
package org.blackerp.api.dto.responses // Auto-fixed by fix_application.sh import java.util.UUID data class TableResponse(val id:UUID,val name:String,val displayName:String,val description:String?,val accessLevel:String) data class TablesResponse(val tables:List<TableResponse>) 
File: ./application/api/controllers/DocumentLifecycleController.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.domain.core.ad.document.* import org.blackerp.application.services.DocumentLifecycleService import java.util.UUID @RestController @RequestMapping("/api/documents") class DocumentLifecycleController(private val lifecycleService:DocumentLifecycleService) {@PostMapping("/{id}/status") suspend fun changeStatus(@PathVariable id:UUID,@RequestBody command:ChangeStatusCommand):ResponseEntity<Document>=lifecycleService.changeStatus(id,command).fold({error->ResponseEntity.badRequest().build()},{document->ResponseEntity.ok(document)}) @GetMapping("/{id}/history") suspend fun getHistory(@PathVariable id:UUID):ResponseEntity<List<DocumentChange>>=lifecycleService.getHistory(id).fold({error->ResponseEntity.badRequest().build()},{history->ResponseEntity.ok(history)}) @PostMapping("/{id}/validate") suspend fun validateTransition(@PathVariable id:UUID,@RequestBody targetStatus:DocumentStatus):ResponseEntity<Boolean>=lifecycleService.validateStatusTransition(id,targetStatus).fold({error->ResponseEntity.badRequest().build()},{valid->ResponseEntity.ok(valid)})} 
File: ./application/api/controllers/DocumentController.kt
-------------------------------------------
package org.blackerp.api.controllers import org.springframework.web.bind.annotation.* import org.blackerp.domain.core.ad.document.* import org.springframework.http.ResponseEntity import java.util.UUID @RestController @RequestMapping("/api/documents") class DocumentController(private val documentService:DocumentOperations) {@GetMapping("/{id}/history") suspend fun getHistory(@PathVariable id:UUID):ResponseEntity<Any>=documentService.findById(id) .fold({ResponseEntity.badRequest().body(it)},{ResponseEntity.ok(it)})} 
File: ./application/api/controllers/Imports.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.blackerp.domain.core.shared.* import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import jakarta.validation.Valid import kotlinx.coroutines.flow.Flow import java.util.UUID 
File: ./application/api/controllers/TableController.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.application.api.dto.TableDTO import org.blackerp.application.api.dto.requests.CreateTableRequest import org.blackerp.application.services.table.TableManagementService import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.shared.ValidationError import arrow.core.* import jakarta.validation.Valid import kotlinx.coroutines.flow.map import kotlinx.coroutines.flow.toList @RestController @RequestMapping("/api/tables") class TableController(private val tableService:TableManagementService) {@GetMapping suspend fun getTables():ResponseEntity<List<TableDTO>>=tableService.findTables() .map {TableDTO.fromDomain(it)} .toList() .let {ResponseEntity.ok(it)} @PostMapping suspend fun createTable(@Valid @RequestBody request:CreateTableRequest):ResponseEntity<TableDTO>=Either.catch {TableName.create(request.name).orNull()?.let {tableName->DisplayName.create(request.displayName).orNull()?.let {displayName->val description=request.description?.let {desc->Description.create(desc).orNull()} CreateTableCommand(name=tableName,displayName=displayName,description=description,accessLevel=AccessLevel.valueOf(request.accessLevel.uppercase()),columns=emptyList())}} ?:throw IllegalArgumentException("Invalid input")}.fold({ResponseEntity.badRequest().build()},{command->tableService.createTable(command).fold({ResponseEntity.badRequest().build()},{ResponseEntity.ok(TableDTO.fromDomain(it))})})} 
File: ./application/api/controllers/ReferenceController.kt
-------------------------------------------
package org.blackerp.api.controllers // Auto-fixed by fix_application.sh import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.domain.core.ad.reference.* import org.blackerp.application.services.ReferenceService import jakarta.validation.Valid import org.slf4j.LoggerFactory import java.util.UUID @RestController @RequestMapping("/api/references") class ReferenceController(private val referenceService:ReferenceService) {private val logger=LoggerFactory.getLogger(ReferenceController::class.java) @PostMapping suspend fun createReference(@Valid @RequestBody request:CreateReferenceRequest):ResponseEntity<ADReference> {logger.debug("Creating reference:${request.name}") return referenceService.save(request.toDomain()).fold({error->ResponseEntity.badRequest().build()},{reference->ResponseEntity.ok(reference)})} @GetMapping("/{id}") suspend fun getReference(@PathVariable id:UUID):ResponseEntity<ADReference> {return referenceService.findById(id).fold({error->ResponseEntity.notFound().build()},{reference->reference?.let {ResponseEntity.ok(it)} ?:ResponseEntity.notFound().build()})} @GetMapping("/{id}/values") suspend fun getReferenceValues(@PathVariable id:UUID,@RequestParam(required=false) search:String?,@RequestParam(defaultValue="20") pageSize:Int,@RequestParam(defaultValue="0") page:Int):ResponseEntity<List<ReferenceValue<*>>> {return referenceService.getValues(id,search,pageSize,page).fold({error->ResponseEntity.badRequest().build()},{values->ResponseEntity.ok(values)})} @GetMapping("/{id}/hierarchy") suspend fun getReferenceHierarchy(@PathVariable id:UUID):ResponseEntity<List<ADReference>> {return referenceService.getHierarchy(id).fold({error->ResponseEntity.badRequest().build()},{hierarchy->ResponseEntity.ok(hierarchy)})} @DeleteMapping("/{id}") suspend fun deleteReference(@PathVariable id:UUID):ResponseEntity<Unit> {return referenceService.delete(id).fold({error->ResponseEntity.badRequest().build()},{ResponseEntity.noContent().build()})} data class CreateReferenceRequest(val name:String,val displayName:String,val description:String?,val type:ReferenceTypeRequest,val validationRule:ValidationRuleRequest?,val parentId:UUID?,val sortOrder:Int?,val cacheStrategy:String?) {fun toDomain():ADReference {// Implement conversion to domain object TODO("Implement conversion")}} data class ReferenceTypeRequest(val type:String,val config:Map<String,String>) data class ValidationRuleRequest(val expression:String,val errorMessage:String,val parameters:Map<String,String>)} 
File: ./application/api/controllers/WorkflowController.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.blackerp.application.usecases.workflow.* import org.blackerp.application.api.process.CreateWorkflowCommand import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity @RestController @RequestMapping("/api/workflows") class WorkflowController(private val createWorkflowUseCase:CreateWorkflowUseCase) {@PostMapping suspend fun createWorkflow(@RequestBody command:CreateWorkflowCommand):ResponseEntity<Any>=createWorkflowUseCase.execute(command) .fold({error->ResponseEntity.badRequest().body(error)},{workflow->ResponseEntity.ok(workflow)})} 
File: ./application/api/controllers/ProcessController.kt
-------------------------------------------
package org.blackerp.application.api.controllers import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.blackerp.domain.core.ad.process.* import org.blackerp.application.services.ProcessService import jakarta.validation.Valid import org.slf4j.LoggerFactory import java.util.UUID import kotlinx.coroutines.flow.toList @RestController @RequestMapping("/api/processes") class ProcessController(private val processService:ProcessService) {private val logger=LoggerFactory.getLogger(ProcessController::class.java) @GetMapping("/{id}/history") suspend fun getProcessHistory(@PathVariable id:UUID,@RequestParam(defaultValue="20") pageSize:Int,@RequestParam(defaultValue="0") page:Int):ResponseEntity<List<ProcessExecution>> {val executions=processService.getExecutionHistory(id,pageSize,page).toList() return ResponseEntity.ok(executions)} @PostMapping("/{id}/execute") suspend fun executeProcess(@PathVariable id:UUID,@RequestBody parameters:Map<String,Any>,@RequestParam(defaultValue="false") async:Boolean):ResponseEntity<ProcessResult>=processService.execute(id,parameters,async).fold({error->ResponseEntity.badRequest().build()},{result->ResponseEntity.ok(result)}) @PostMapping("/{id}/schedule") suspend fun scheduleProcess(@PathVariable id:UUID,@Valid @RequestBody schedule:ProcessSchedule):ResponseEntity<ADProcess>=processService.schedule(id,schedule).fold({error->ResponseEntity.badRequest().build()},{process->ResponseEntity.ok(process)})} 
File: ./application/api/extensions/ProcessExtensions.kt
-------------------------------------------
package org.blackerp.application.api.extensions import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.application.api.process.CreateProcessCommand import arrow.core.* import java.util.UUID fun CreateProcessCommand.toDomain():Either<ProcessError,ADProcess>=DisplayName.create(displayName).bimap({ProcessError.ValidationFailed(it.message)},{displayName->ADProcess(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),displayName=displayName,description=description?.let {Description.create(it).orNull()},type=type,parameters=parameters.map {param->ProcessParameter(id=UUID.randomUUID(),name=param.name,displayName=param.displayName,description=param.description,parameterType=ParameterType.STRING,isMandatory=false,validationRule=null)},implementation=implementation,schedule=schedule)}) 
File: ./application/api/extensions/DomainExtensions.kt
-------------------------------------------
package org.blackerp.application.api.extensions import org.blackerp.domain.core.ad.document.Document import org.blackerp.domain.core.ad.process.ADProcess import org.blackerp.application.api.dto.requests.CreateDocumentRequest import org.blackerp.application.api.dto.requests.CreateProcessRequest import org.blackerp.domain.core.error.DomainError import arrow.core.Either import arrow.core.right fun CreateDocumentRequest.toDomain():Either<DomainError,Document>=TODO() fun CreateProcessRequest.toDomain():Either<DomainError,ADProcess>=TODO() 
File: ./application/api/process/CreateProcessCommand.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.ad.process.* import java.util.UUID data class CreateProcessCommand(val displayName:String,val description:String?,val type:ProcessType,val parameters:List<ProcessParameter>,val implementation:ProcessImplementation,val schedule:ProcessSchedule?) 
File: ./application/api/process/ApiCreateProcessCommand.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.values.* data class ApiCreateProcessCommand(val displayName:String,val description:String?,val type:ProcessType,val parameters:List<ProcessParameter>,val implementation:ProcessImplementation,val schedule:ProcessSchedule?) 
File: ./application/api/process/ProcessExtensions.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import arrow.core.* import java.util.UUID fun CreateProcessCommand.toDomain():Either<ProcessError,ADProcess> {return DisplayName.create(displayName) .mapLeft {ProcessError.ValidationFailed(it.message)} .flatMap {displayName->val descriptionValue=description?.let {desc->Description.create(desc).fold({ProcessError.ValidationFailed(it.message).left()},{it.right()})} ?:null.right() descriptionValue.map {desc->val metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")) ADProcess(metadata=metadata,displayName=displayName,description=desc,type=type,parameters=parameters.map {param->ProcessParameter(id=UUID.randomUUID(),name=param.name,displayName=param.displayName,description=param.description,parameterType=ParameterType.STRING,isMandatory=false,validationRule=null)},implementation=implementation,schedule=schedule)}}} 
File: ./application/api/process/DomainProcessParameter.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.values.DataType import org.blackerp.domain.core.ad.process.* import java.util.UUID interface Parameter {val id:UUID val name:String val displayName:String val description:String? val parameterType:ParameterType val isMandatory:Boolean val validationRule:String?} data class DomainProcessParameter(override val name:String,override val displayName:String,val dataType:DataType,val mandatory:Boolean=false,override val description:String?=null) :Parameter {override val id=UUID.randomUUID() override val parameterType=toParameterType(dataType) override val isMandatory=mandatory override val validationRule:String?=null private fun toParameterType(type:DataType):ParameterType=when(type) {DataType.STRING->ParameterType.STRING DataType.INTEGER->ParameterType.NUMBER DataType.DATE->ParameterType.DATE DataType.BOOLEAN->ParameterType.BOOLEAN else->ParameterType.STRING}} 
File: ./application/api/process/commands.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.values.DataType import org.blackerp.domain.core.ad.workflow.NodeType data class ProcessCommand(val name:String,val displayName:String,val description:String?,val type:String,val parameters:List<ProcessParameter>) data class ProcessParameter(val name:String,val displayName:String,val description:String?,val dataType:DataType,val mandatory:Boolean=false) data class WorkflowCommand(val name:String,val displayName:String,val description:String?,val nodeType:NodeType,val action:String?,val transitions:List<TransitionCommand>) data class TransitionCommand(val targetNode:String,val condition:String?) 
File: ./application/api/process/WorkflowCommands.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.ad.workflow.NodeType import org.blackerp.domain.core.ad.workflow.NodeAction import java.util.UUID data class CreateWorkflowCommand(val displayName:String,val description:String?,val type:NodeType,val action:NodeAction?,val transitions:List<CreateTransitionCommand>) data class CreateTransitionCommand(val targetNodeId:UUID,val condition:String?) 
File: ./application/api/process/types.kt
-------------------------------------------
package org.blackerp.application.api.process import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.process.* import arrow.core.* import java.util.UUID data class ProcessRequest(val name:String,val displayName:String,val description:String?,val parameters:List<DomainProcessParameter>) {fun toDomain():Either<ProcessError,ADProcess> {val metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")) return DisplayName.create(displayName) .mapLeft {ProcessError.ValidationFailed(it.message)} .flatMap {dispName->val desc=description?.let {Description.create(it).fold({ProcessError.ValidationFailed(it.message).left()},{it.right()})} ?:null.right() desc.map {description->ADProcess(metadata=metadata,displayName=dispName,description=description,type=ProcessType.CUSTOM,parameters=parameters.map {ProcessParameter(id=UUID.randomUUID(),name=it.name,displayName=it.displayName,description=it.description,parameterType=ParameterType.STRING,isMandatory=false,validationRule=null)},implementation=ProcessImplementation.JavaClass(name),schedule=null)}}}} 
File: ./application/api/common/Imports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.shared.* import org.blackerp.domain.core.values.* import java.util.UUID 
File: ./application/api/common/BaseService.kt
-------------------------------------------
package org.blackerp.application.api.common import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext import arrow.core.Either import arrow.core.left import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.error.UnexpectedError abstract class BaseService {protected suspend fun <T> withTransaction(block:suspend ()->Either<DomainError,T>):Either<DomainError,T>=withContext(Dispatchers.IO) {try {block()} catch (e:Exception) {UnexpectedError(e.message ?:"Unknown error").left()}}} 
File: ./application/api/common/SharedImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.blackerp.domain.core.* import org.blackerp.domain.core.error.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.metadata.* import java.util.UUID 
File: ./application/api/common/ApiImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import org.springframework.stereotype.Component import jakarta.validation.Valid import org.blackerp.domain.core.error.DomainError import org.blackerp.domain.core.ad.table.ADTable import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import java.util.* import arrow.core.Either import kotlinx.coroutines.flow.Flow 
File: ./application/api/common/ServiceImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.error.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import arrow.core.Either import arrow.core.right import arrow.core.left import kotlinx.coroutines.flow.* import java.util.UUID 
File: ./application/api/common/DomainImports.kt
-------------------------------------------
package org.blackerp.application.api.common import org.blackerp.domain.core.* import org.blackerp.domain.core.error.* import org.blackerp.domain.core.shared.ValidationError import org.blackerp.domain.core.values.* import org.blackerp.domain.core.ad.table.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.ad.process.* import java.util.UUID 
File: ./application/api/common/WebImports.kt
-------------------------------------------
package org.blackerp.api.common import org.springframework.web.bind.annotation.* import org.springframework.http.ResponseEntity import kotlinx.coroutines.* import arrow.core.Either import arrow.core.left import arrow.core.right import org.slf4j.LoggerFactory import jakarta.validation.Valid import java.util.UUID 
File: ./application/api/advice/ErrorHandler.kt
-------------------------------------------
package org.blackerp.application.api.advice import org.springframework.web.bind.annotation.ExceptionHandler import org.springframework.web.bind.annotation.RestControllerAdvice import org.springframework.http.ResponseEntity import org.blackerp.domain.core.error.DomainError @RestControllerAdvice class ErrorHandler {@ExceptionHandler fun handle(error:DomainError):ResponseEntity<Any>=ResponseEntity.badRequest().body(error.message)} 
File: ./application/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") kotlin("plugin.spring") id("org.springframework.boot")} sourceSets {main {kotlin.srcDirs("api","services","usecases",".") resources.srcDirs("resources")}} dependencies {api(project(":domain")) implementation(project(":infrastructure")) implementation("org.springframework.boot:spring-boot-starter-web") implementation("org.springframework.boot:spring-boot-starter-security") implementation("org.springframework.boot:spring-boot-starter-validation") implementation("org.springframework.boot:spring-boot-starter-data-jpa") implementation("org.jetbrains.kotlin:kotlin-reflect") implementation("com.fasterxml.jackson.module:jackson-module-kotlin") implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3") implementation("org.jetbrains.kotlinx:kotlinx-coroutines-reactor:1.7.3") implementation("io.micrometer:micrometer-core") implementation("io.arrow-kt:arrow-core:1.1.3") runtimeOnly("com.h2database:h2")} 
File: ./application/Application.kt
-------------------------------------------
package org.blackerp import org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication @SpringBootApplication class Application fun main(args:Array<String>) {runApplication<Application>(*args)} 
File: ./application/usecases/process/CreateProcessUseCase.kt
-------------------------------------------
package org.blackerp.application.usecases.process import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.process.* import org.blackerp.application.api.process.ProcessRequest import arrow.core.Either import arrow.core.flatMap import kotlinx.coroutines.withContext import kotlinx.coroutines.Dispatchers @Service class CreateProcessUseCase(private val processOperations:ProcessOperations) {suspend fun execute(request:ProcessRequest):Either<ProcessError,ADProcess>=withContext(Dispatchers.IO) {request.toDomain().flatMap {process->processOperations.save(process)}}} 
File: ./application/usecases/process/ProcessExtensions.kt
-------------------------------------------
package org.blackerp.application.usecases.process import org.blackerp.domain.core.ad.process.* import org.blackerp.domain.core.values.* import org.blackerp.domain.core.metadata.* import org.blackerp.application.api.dto.requests.CreateProcessRequest import arrow.core.* import java.util.UUID fun CreateProcessRequest.toDomain():Either<ProcessError,ADProcess>=DisplayName.create(displayName).bimap({ProcessError.ValidationFailed(it.message)},{displayName->ADProcess(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),displayName=displayName,description=null,type=ProcessType.valueOf(type.uppercase()),parameters=parameters.map {param->ProcessParameter(id=UUID.randomUUID(),name=param.name,displayName=param.displayName,description=param.description,parameterType=ParameterType.STRING,isMandatory=param.mandatory,validationRule=null)},implementation=ProcessImplementation.JavaClass("process"),schedule=null)}) 
File: ./application/usecases/document/CreateDocumentUseCase.kt
-------------------------------------------
package org.blackerp.application.usecases.document import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.document.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.application.services.base.CoroutineBaseService import arrow.core.* import java.util.UUID import kotlinx.coroutines.withContext import kotlinx.coroutines.Dispatchers @Service class CreateDocumentUseCase(private val documentOperations:DocumentOperations) :CoroutineBaseService() {suspend fun execute(command:CreateDocumentCommand):Either<DocumentError,Document>=withContext(Dispatchers.IO) {val description=command.description?.let {desc->Description.create(desc).fold({DocumentError.ValidationFailed("Invalid description").left()},{it.right()})} ?:DocumentError.ValidationFailed("Description required").left() description.flatMap {desc->DisplayName.create(command.displayName).fold({DocumentError.ValidationFailed("Invalid display name").left()},{displayName->val document=Document(metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")),displayName=displayName,description=desc,type=command.documentType) documentOperations.create(document)})}}} 
File: ./application/usecases/document/CreateDocumentCommand.kt
-------------------------------------------
package org.blackerp.application.usecases.document import org.blackerp.domain.core.ad.document.DocumentType data class CreateDocumentCommand(val displayName:String,val description:String?,val documentType:DocumentType) 
File: ./application/usecases/workflow/CreateWorkflowUseCase.kt
-------------------------------------------
package org.blackerp.application.usecases.workflow import org.springframework.stereotype.Service import org.blackerp.domain.core.ad.workflow.* import org.blackerp.application.api.process.CreateWorkflowCommand import arrow.core.Either import arrow.core.flatMap import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.withContext @Service class CreateWorkflowUseCase(private val workflowOperations:WorkflowOperations) {suspend fun execute(command:CreateWorkflowCommand):Either<WorkflowError,WorkflowNode> {return withContext(Dispatchers.IO) {command.toNode().flatMap {node->workflowOperations.save(node)}}}} 
File: ./application/usecases/workflow/WorkflowExtensions.kt
-------------------------------------------
package org.blackerp.application.usecases.workflow import org.blackerp.domain.core.ad.workflow.* import org.blackerp.domain.core.metadata.* import org.blackerp.domain.core.values.* import org.blackerp.application.api.process.CreateWorkflowCommand import arrow.core.* import java.util.UUID suspend fun CreateWorkflowCommand.toNode():Either<WorkflowError,WorkflowNode> {val metadata=EntityMetadata(id=UUID.randomUUID().toString(),audit=AuditInfo(createdBy="system",updatedBy="system")) return DisplayName.create(displayName) .mapLeft {WorkflowError.ValidationFailed(it.message)} .flatMap {displayName->val desc=description?.let {Description.create(it).fold({WorkflowError.ValidationFailed(it.message).left()},{it.right()})} ?:null.right() desc.map {description->WorkflowNode(metadata=metadata,displayName=displayName,description=description,type=type,action=action,transitions=transitions.map {t->WorkflowTransition(id=UUID.randomUUID(),sourceNode=UUID.randomUUID(),targetNode=t.targetNodeId,condition=t.condition?.let {TransitionCondition(it,"Auto-generated")})})}}} 
File: ./test-import/settings.gradle.kts
-------------------------------------------
rootProject.name="test-import" include("domain") 
File: ./test-import/domain/build.gradle.kts
-------------------------------------------
// /test-import/domain/build.gradle.kts plugins {kotlin("jvm")} kotlin {jvmToolchain(17)} sourceSets {main {kotlin {// Explicitly list all source directories srcDirs("core","core/metadata","core/shared","core/values")}}} dependencies {implementation("org.jetbrains.kotlin:kotlin-stdlib") implementation("io.arrow-kt:arrow-core:1.2.0")}
File: ./test-import/domain/core/values/TableName.kt
-------------------------------------------
// /test-import/domain/core/values/TableName.kt package org.blackerp.domain.core.values import arrow.core.Either import arrow.core.left import arrow.core.right import org.blackerp.domain.core.DomainEntity import org.blackerp.domain.core.metadata.EntityMetadata import org.blackerp.domain.core.shared.ValidationError @JvmInline value class TableName private constructor(val value:String) {companion object {fun create(value:String):Either<ValidationError,TableName>=when {!value.matches(Regex("^[a-z][a-z0-9_]*$"))->ValidationError.InvalidFormat("Table name must start with lowercase letter and contain only lowercase letters,numbers,and underscores").left() else->TableName(value).right()}}}
File: ./test-import/domain/core/DomainEntity.kt
-------------------------------------------
package org.blackerp.domain.core import org.blackerp.domain.core.metadata.EntityMetadata interface DomainEntity {val metadata:EntityMetadata}
File: ./test-import/domain/core/shared/ValidationError.kt
-------------------------------------------
package org.blackerp.domain.core.shared sealed class ValidationError(val message:String) {data class InvalidFormat(val error:String) :ValidationError(error)} 
File: ./test-import/domain/core/metadata/EntityMetadata.kt
-------------------------------------------
package org.blackerp.domain.core.metadata import java.util.UUID import java.time.Instant data class EntityMetadata(val id:UUID=UUID.randomUUID(),val created:Instant=Instant.now(),val createdBy:String)
File: ./test-import/build.gradle.kts
-------------------------------------------
plugins {kotlin("jvm") version "1.9.20" apply false} allprojects {repositories {mavenCentral()}} 